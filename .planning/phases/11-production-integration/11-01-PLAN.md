---
phase: 11-production-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/qm_nmr_calc/data/scaling_factors.json
  - src/qm_nmr_calc/shifts.py
  - src/qm_nmr_calc/tasks.py
  - src/qm_nmr_calc/benchmark/runner.py
  - pyproject.toml
autonomous: true

must_haves:
  truths:
    - "Production calculations use DELTA50-derived regression factors instead of CHESHIRE TMS references"
    - "Factor lookup fails explicitly with ValueError when solvent/functional combination not supported"
    - "Scaling factors are loaded lazily at runtime (not at import time)"
    - "ISiCLE is no longer a declared dependency"
    - "tasks.py calls shielding_to_shift with the new signature"
    - "benchmark/runner.py calls shielding_to_shift with the new signature"
  artifacts:
    - path: "src/qm_nmr_calc/data/scaling_factors.json"
      provides: "B3LYP scaling factors for CHCl3 and DMSO solvents"
      contains: "B3LYP/6-311+G(2d,p)/1H/CHCl3"
    - path: "src/qm_nmr_calc/shifts.py"
      provides: "Shielding-to-shift conversion with regression factors"
      exports: ["load_scaling_factors", "get_scaling_factor", "shielding_to_shift"]
    - path: "src/qm_nmr_calc/tasks.py"
      provides: "Updated NMR task with new shielding_to_shift call"
      contains: "shielding_to_shift(result['shielding_data'], functional="
    - path: "src/qm_nmr_calc/benchmark/runner.py"
      provides: "Updated benchmark runner with new shielding_to_shift call"
      contains: "shielding_to_shift(result[\"shielding_data\"], functional="
    - path: "pyproject.toml"
      provides: "Project configuration with data file inclusion"
      contains: "force-include"
  key_links:
    - from: "src/qm_nmr_calc/shifts.py"
      to: "src/qm_nmr_calc/data/scaling_factors.json"
      via: "importlib.resources.files()"
      pattern: 'files\("qm_nmr_calc"\)'
    - from: "src/qm_nmr_calc/tasks.py"
      to: "src/qm_nmr_calc/shifts.py"
      via: "shielding_to_shift import"
      pattern: "shielding_to_shift\\(.*functional="
    - from: "src/qm_nmr_calc/benchmark/runner.py"
      to: "src/qm_nmr_calc/shifts.py"
      via: "shielding_to_shift import"
      pattern: "shielding_to_shift\\(.*functional="
---

<objective>
Integrate DELTA50-derived scaling factors into production calculations and remove ISiCLE dependency

Purpose: Replace the hardcoded CHESHIRE TMS reference factors with our NWChem-derived regression factors from Phase 10 benchmarking, enabling more accurate chemical shift predictions. Also removes the ISiCLE dependency from project configuration.

Output: Updated shifts.py module that loads factors from bundled JSON, configured build system to include data files, cleaned pyproject.toml without ISiCLE, and updated tasks.py and benchmark/runner.py to call shielding_to_shift with the new signature.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-production-integration/11-CONTEXT.md
@.planning/phases/11-production-integration/11-RESEARCH.md
@src/qm_nmr_calc/shifts.py
@src/qm_nmr_calc/tasks.py
@src/qm_nmr_calc/benchmark/runner.py
@data/benchmark/delta50/scaling_factors.json
@pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Copy scaling factors and configure hatchling build</name>
  <files>
    src/qm_nmr_calc/data/scaling_factors.json
    pyproject.toml
  </files>
  <action>
1. Create `src/qm_nmr_calc/data/` directory
2. Copy `data/benchmark/delta50/scaling_factors.json` to `src/qm_nmr_calc/data/scaling_factors.json`
3. Update pyproject.toml:
   - Remove "isicle" from dependencies list
   - Remove `[tool.uv.sources]` section with isicle path
   - Add `[tool.hatch.build.targets.wheel.force-include]` to bundle scaling_factors.json:
     ```toml
     [tool.hatch.build.targets.wheel.force-include]
     "src/qm_nmr_calc/data" = "qm_nmr_calc/data"
     ```

Note: Keep data/benchmark/delta50/scaling_factors.json in place for reproducibility (don't delete original).
  </action>
  <verify>
    Run: `uv pip install -e . && python -c "from importlib.resources import files; print(files('qm_nmr_calc').joinpath('data/scaling_factors.json').read_text()[:100])"`
    Should print first 100 chars of JSON without error.

    Run: `uv pip list | grep -i isicle`
    Should return empty (ISiCLE not installed).

    Run: `grep -r "from isicle\|import isicle" src/ --include="*.py" | grep -v "# .*ISiCLE\|# .*isicle" || echo "No ISiCLE code imports found - OK"`
    Should find no code imports (only attribution comments allowed).
  </verify>
  <done>
    - src/qm_nmr_calc/data/scaling_factors.json exists with 4 factor entries
    - pyproject.toml has force-include configuration
    - isicle removed from dependencies
    - Package data accessible via importlib.resources
    - ISiCLE not installed in environment
    - No ISiCLE imports in source code (attribution comments OK)
  </done>
</task>

<task type="auto">
  <name>Task 2: Rewrite shifts.py to use DELTA50 regression factors</name>
  <files>
    src/qm_nmr_calc/shifts.py
  </files>
  <action>
Replace the hardcoded SCALING_FACTORS dict with JSON loading. Key changes:

1. Add imports at top:
   ```python
   from functools import cache
   from importlib.resources import files
   import orjson
   ```

2. Add cached factor loading function:
   ```python
   @cache
   def load_scaling_factors() -> dict:
       """Load scaling factors from package data (cached after first call).

       Returns:
           Dict mapping factor keys to factor dicts.
           Key format: "B3LYP/6-311+G(2d,p)/1H/CHCl3"
           Value: {slope, intercept, r_squared, mae, rmsd, n_points, ...}
       """
       data_dir = files("qm_nmr_calc").joinpath("data")
       json_bytes = data_dir.joinpath("scaling_factors.json").read_bytes()
       return orjson.loads(json_bytes)
   ```

3. Add factor lookup function with explicit error:
   ```python
   def get_scaling_factor(
       functional: str,
       basis_set: str,
       nucleus: str,
       solvent: str
   ) -> dict:
       """Get scaling factor for specific calculation parameters.

       Args:
           functional: DFT functional (e.g., 'B3LYP')
           basis_set: Basis set (e.g., '6-311+G(2d,p)')
           nucleus: Nucleus type ('1H' or '13C')
           solvent: Solvent name (e.g., 'CHCl3', 'DMSO')

       Returns:
           Dict with: slope, intercept, r_squared, mae, rmsd, n_points

       Raises:
           ValueError: If no factor exists for this combination
       """
       key = f"{functional}/{basis_set}/{nucleus}/{solvent}"
       factors = load_scaling_factors()

       if key not in factors:
           available = list(factors.keys())
           raise ValueError(
               f"No scaling factor for {key}.\n"
               f"Supported combinations: {available}"
           )

       return factors[key]
   ```

4. Update shielding_to_shift() signature to accept calculation params instead of preset:
   ```python
   def shielding_to_shift(
       shielding_data: dict,
       functional: str,
       basis_set: str,
       solvent: str,
   ) -> dict[str, list[dict]]:
   ```

   Inside the function:
   - For each atom, determine nucleus ('1H' for H, '13C' for C)
   - Call get_scaling_factor(functional, basis_set, nucleus, solvent)
   - Apply: shift = slope * shielding + intercept
   - Keep the same return structure: {'1H': [...], '13C': [...]}

5. Remove the old SCALING_FACTORS dict and get_scaling_factors() function.

6. Update module docstring to reference DELTA50 instead of CHESHIRE.
  </action>
  <verify>
    Run: `python -c "
from qm_nmr_calc.shifts import get_scaling_factor, shielding_to_shift

# Test factor lookup
h1_chcl3 = get_scaling_factor('B3LYP', '6-311+G(2d,p)', '1H', 'CHCl3')
print(f'1H CHCl3 slope: {h1_chcl3[\"slope\"]:.4f}, MAE: {h1_chcl3[\"mae\"]:.4f}')

# Test missing factor raises ValueError
try:
    get_scaling_factor('WP04', '6-311+G(2d,p)', '1H', 'CHCl3')
except ValueError as e:
    print('ValueError raised for missing factor: OK')

# Test shielding_to_shift
data = {'index': [1, 2], 'atom': ['H', 'C'], 'shielding': [29.5, 150.0]}
result = shielding_to_shift(data, 'B3LYP', '6-311+G(2d,p)', 'CHCl3')
print(f'1H shift: {result[\"1H\"][0][\"shift\"]}, 13C shift: {result[\"13C\"][0][\"shift\"]}')
"`
  </verify>
  <done>
    - load_scaling_factors() returns cached dict from JSON
    - get_scaling_factor() retrieves by composite key or raises ValueError
    - shielding_to_shift() accepts functional/basis_set/solvent params
    - Old CHESHIRE SCALING_FACTORS dict removed
  </done>
</task>

<task type="auto">
  <name>Task 3: Update tasks.py and benchmark/runner.py to use new shielding_to_shift signature</name>
  <files>
    src/qm_nmr_calc/tasks.py
    src/qm_nmr_calc/benchmark/runner.py
  </files>
  <action>
The shielding_to_shift() signature changes from `shielding_to_shift(data, preset=...)` to `shielding_to_shift(data, functional, basis_set, solvent)`.

**Update tasks.py:**

1. Find the call to shielding_to_shift in run_nmr_task() (around line 119):
   ```python
   # OLD:
   shifts = shielding_to_shift(result['shielding_data'], preset=job_status.input.preset)

   # NEW:
   shifts = shielding_to_shift(
       result['shielding_data'],
       functional=preset['functional'].upper(),  # 'b3lyp' -> 'B3LYP'
       basis_set=preset['nmr_basis_set'],
       solvent=solvent,
   )
   ```

2. Note: The preset dict is already loaded earlier in the function (line 91-92):
   ```python
   preset_name = PresetName(job_status.input.preset)
   preset = PRESETS[preset_name]
   ```
   And solvent is already available from `solvent = job_status.input.solvent` (line 94).

**Update benchmark/runner.py:**

1. Find the call at line 239 in run_single_calculation():
   ```python
   # OLD:
   shifts_data = shielding_to_shift(result["shielding_data"], preset="production")

   # NEW - use explicit params matching the benchmark configuration:
   shifts_data = shielding_to_shift(
       result["shielding_data"],
       functional=functional.upper(),  # Already have functional from task params
       basis_set=BENCHMARK_PRESETS[functional]["nmr_basis_set"],
       solvent=solvent,  # Already have solvent from task params
   )
   ```

2. Note: The `functional` and `solvent` variables are already available in run_single_calculation() from the function parameters (lines 184-187).
  </action>
  <verify>
    Run: `grep -n "shielding_to_shift" src/qm_nmr_calc/tasks.py src/qm_nmr_calc/benchmark/runner.py`
    Should show new signature with functional= keyword in both files.

    Run: `python -c "from qm_nmr_calc.tasks import run_nmr_task; print('tasks.py imports OK')"`
    Should not raise import errors.

    Run: `python -c "from qm_nmr_calc.benchmark.runner import run_single_calculation; print('runner.py imports OK')"`
    Should not raise import errors.
  </verify>
  <done>
    - tasks.py calls shielding_to_shift with functional, basis_set, solvent params
    - benchmark/runner.py calls shielding_to_shift with functional, basis_set, solvent params
    - No runtime errors on import
  </done>
</task>

</tasks>

<verification>
1. Package installs without isicle dependency: `uv sync` completes without isicle errors
2. Scaling factors load at runtime: `python -c "from qm_nmr_calc.shifts import load_scaling_factors; print(len(load_scaling_factors()))` prints 4
3. Factor lookup works: get_scaling_factor returns valid dict for B3LYP/CHCl3 and B3LYP/DMSO
4. Missing factor fails explicitly: get_scaling_factor('WP04', ...) raises ValueError
5. tasks.py uses new signature: grep shows functional= in shielding_to_shift call
6. benchmark/runner.py uses new signature: grep shows functional= in shielding_to_shift call
7. Tests pass: `pytest tests/ -q` (tests may need updating for new signature)
</verification>

<success_criteria>
- DELTA50 scaling factors bundled in package and accessible via importlib.resources
- shifts.py uses regression formula: shift = slope * shielding + intercept
- Factor lookup is by composite key: functional/basis_set/nucleus/solvent
- ISiCLE removed from pyproject.toml dependencies
- No import-time I/O (factors loaded lazily on first call)
- tasks.py calls shielding_to_shift with new signature
- benchmark/runner.py calls shielding_to_shift with new signature
</success_criteria>

<output>
After completion, create `.planning/phases/11-production-integration/11-01-SUMMARY.md`
</output>
