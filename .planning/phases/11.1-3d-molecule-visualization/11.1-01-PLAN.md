---
phase: 11.1-3d-molecule-visualization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/qm_nmr_calc/storage.py
  - src/qm_nmr_calc/tasks.py
  - src/qm_nmr_calc/api/routers/jobs.py
autonomous: true

must_haves:
  truths:
    - "Initial RDKit geometry is saved when job starts running"
    - "API returns XYZ geometry for any job (initial if running, optimized if complete)"
    - "API returns shift assignments only when job is complete"
  artifacts:
    - path: "src/qm_nmr_calc/storage.py"
      provides: "get_initial_geometry_file() helper function"
      contains: "def get_initial_geometry_file"
    - path: "src/qm_nmr_calc/tasks.py"
      provides: "Initial geometry storage at task start"
      contains: "initial.xyz"
    - path: "src/qm_nmr_calc/api/routers/jobs.py"
      provides: "geometry.json endpoint"
      contains: "geometry.json"
  key_links:
    - from: "src/qm_nmr_calc/tasks.py"
      to: "initial.xyz file"
      via: "RDKit 3D coordinate generation"
      pattern: "initial\\.xyz"
    - from: "src/qm_nmr_calc/api/routers/jobs.py"
      to: "storage.py"
      via: "get_initial_geometry_file and get_geometry_file"
      pattern: "get_initial_geometry_file|get_geometry_file"
---

<objective>
Add backend infrastructure for 3D molecule visualization: store initial RDKit geometry at job start and expose geometry + shift data via API endpoint.

Purpose: Enable frontend 3D viewer to display molecule geometry during calculation (RDKit geometry) and after completion (NWChem optimized geometry with shift labels).

Output: `get_initial_geometry_file()` storage helper, initial geometry saving in task execution, and `/api/v1/jobs/{job_id}/geometry.json` endpoint.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11.1-3d-molecule-visualization/11.1-CONTEXT.md
@.planning/phases/11.1-3d-molecule-visualization/11.1-RESEARCH.md

# Existing code to modify
@src/qm_nmr_calc/storage.py
@src/qm_nmr_calc/tasks.py
@src/qm_nmr_calc/api/routers/jobs.py

# Reference for RDKit 3D generation patterns
@src/qm_nmr_calc/nwchem/geometry.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add storage helper and save initial geometry in task</name>
  <files>
    src/qm_nmr_calc/storage.py
    src/qm_nmr_calc/tasks.py
  </files>
  <action>
1. In storage.py, add `get_initial_geometry_file(job_id: str) -> Optional[Path]`:
   - Returns `get_job_dir(job_id) / "output" / "initial.xyz"` if exists, else None
   - Pattern matches existing `get_geometry_file()` (line 196-199)

2. In tasks.py, add initial geometry generation early in `run_nmr_task()`:
   - After job status validation, before first `start_step()` call
   - Generate 3D coords using RDKit ETKDGv3 with deterministic seed 0xF00D (project standard)
   - Generate XYZ format: line 1 = atom count, line 2 = SMILES as comment, line 3+ = coordinates
   - Save to `job_dir / "output" / "initial.xyz"`
   - Use existing RDKit patterns from nwchem/geometry.py

XYZ generation code pattern:
```python
from rdkit import Chem
from rdkit.Chem import AllChem

def _generate_initial_xyz(smiles: str, output_path: Path) -> None:
    """Generate and save RDKit 3D geometry for immediate visualization."""
    mol = Chem.MolFromSmiles(smiles)
    mol = Chem.AddHs(mol)

    # ETKDGv3 with deterministic seed (project standard: 0xF00D)
    params = AllChem.ETKDGv3()
    params.randomSeed = 0xF00D
    AllChem.EmbedMolecule(mol, params)
    AllChem.MMFFOptimizeMoleculeConfs(mol)

    # Generate XYZ
    xyz_lines = [str(mol.GetNumAtoms()), smiles]
    conf = mol.GetConformer()
    for atom in mol.GetAtoms():
        pos = conf.GetAtomPosition(atom.GetIdx())
        xyz_lines.append(f"{atom.GetSymbol()} {pos.x:.6f} {pos.y:.6f} {pos.z:.6f}")

    output_path.write_text("\n".join(xyz_lines))
```

Place helper function in tasks.py (not storage.py - it uses RDKit which storage doesn't import).
  </action>
  <verify>
Run test: `uv run pytest tests/test_tasks.py -v -k test_` to verify tasks still work.
Manually check: Submit a job via API and verify `data/jobs/{job_id}/output/initial.xyz` is created.
  </verify>
  <done>
- `get_initial_geometry_file()` returns path to initial.xyz
- `run_nmr_task()` saves initial.xyz before geometry optimization step
- Initial XYZ contains valid atom count, SMILES comment, and 3D coordinates
  </done>
</task>

<task type="auto">
  <name>Task 2: Create geometry.json API endpoint</name>
  <files>
    src/qm_nmr_calc/api/routers/jobs.py
  </files>
  <action>
Add new endpoint `GET /api/v1/jobs/{job_id}/geometry.json` in jobs.py:

```python
@router.get(
    "/{job_id}/geometry.json",
    responses={
        200: {"description": "Geometry and shift data for 3D visualization"},
        404: {"model": ProblemDetail, "description": "Job not found"},
    },
)
async def get_geometry_data(job_id: str):
    """Get geometry and shift data for 3D visualization.

    Returns initial RDKit geometry for running jobs,
    optimized NWChem geometry for complete jobs.
    Shift assignments included only when job is complete.
    """
    job_status = load_job_status(job_id)
    if job_status is None:
        raise HTTPException(
            status_code=404,
            detail={
                "type": "https://qm-nmr-calc.example/problems/job-not-found",
                "title": "Job Not Found",
                "status": 404,
                "detail": f"No job exists with ID '{job_id}'",
            },
        )

    # Determine which geometry to return
    if job_status.status == "complete":
        geometry_file = get_geometry_file(job_id)  # optimized.xyz
    else:
        geometry_file = get_initial_geometry_file(job_id)  # initial.xyz

    if geometry_file is None:
        raise HTTPException(
            status_code=404,
            detail={
                "type": "https://qm-nmr-calc.example/problems/geometry-not-found",
                "title": "Geometry Not Found",
                "status": 404,
                "detail": f"Geometry file not available for job '{job_id}'",
            },
        )

    xyz_content = geometry_file.read_text()

    # Build shift assignments only for complete jobs
    h1_assignments = {}
    c13_assignments = {}
    if job_status.status == "complete" and job_status.nmr_results:
        for s in job_status.nmr_results.h1_shifts:
            h1_assignments[str(s.index)] = s.shift
        for s in job_status.nmr_results.c13_shifts:
            c13_assignments[str(s.index)] = s.shift

    return {
        "job_id": job_id,
        "status": job_status.status,
        "xyz": xyz_content,
        "h1_assignments": h1_assignments if h1_assignments else None,
        "c13_assignments": c13_assignments if c13_assignments else None,
    }
```

Add import for `get_initial_geometry_file` at top of file.
  </action>
  <verify>
Run tests: `uv run pytest tests/test_api.py -v`

Manual verification:
1. Submit job: `curl -X POST http://localhost:8000/api/v1/jobs -H "Content-Type: application/json" -d '{"smiles": "CCO", "solvent": "CHCl3"}'`
2. While running: `curl http://localhost:8000/api/v1/jobs/{job_id}/geometry.json` should return XYZ with null assignments
3. After complete: Same endpoint should return optimized XYZ with h1_assignments and c13_assignments
  </verify>
  <done>
- `/api/v1/jobs/{job_id}/geometry.json` returns JSON with xyz, status, and shift assignments
- Running jobs return initial.xyz with null assignments
- Complete jobs return optimized.xyz with populated assignments
- 404 error for missing jobs or unavailable geometry
  </done>
</task>

</tasks>

<verification>
1. Storage helper exists: `grep "def get_initial_geometry_file" src/qm_nmr_calc/storage.py`
2. Initial XYZ generation: `grep "initial.xyz" src/qm_nmr_calc/tasks.py`
3. API endpoint exists: `grep "geometry.json" src/qm_nmr_calc/api/routers/jobs.py`
4. Tests pass: `uv run pytest tests/ -v --tb=short`
</verification>

<success_criteria>
- [ ] `get_initial_geometry_file()` added to storage.py
- [ ] Initial XYZ saved in `run_nmr_task()` before geometry optimization
- [ ] geometry.json endpoint returns appropriate data for running vs complete jobs
- [ ] All existing tests pass
- [ ] Manual API test confirms endpoint works
</success_criteria>

<output>
After completion, create `.planning/phases/11.1-3d-molecule-visualization/11.1-01-SUMMARY.md`
</output>
