---
phase: 13-rdkit-conformer-generation
plan: "03"
type: execute
wave: 2
depends_on: ["13-01", "13-02"]
files_modified:
  - src/qm_nmr_calc/conformers/pipeline.py
  - tests/test_conformer_pipeline.py
autonomous: true

must_haves:
  truths:
    - "Single function call generates, optimizes, deduplicates, and filters a conformer ensemble from SMILES"
    - "XYZ files are written to per-conformer output directories"
    - "ConformerEnsemble model is populated with correct conformer data, energies, and file paths"
    - "Pipeline statistics track total_generated, total_after_pre_filter counts"
    - "App works without CREST/xTB installed -- RDKit-only mode produces valid ensembles"
  artifacts:
    - path: "src/qm_nmr_calc/conformers/pipeline.py"
      provides: "End-to-end conformer pipeline orchestration"
      exports: ["generate_conformer_ensemble"]
    - path: "tests/test_conformer_pipeline.py"
      provides: "Integration tests for full pipeline"
      min_lines: 80
  key_links:
    - from: "src/qm_nmr_calc/conformers/pipeline.py"
      to: "src/qm_nmr_calc/conformers/generator.py"
      via: "imports generate_conformers_kdg, optimize_conformers_mmff, calculate_num_conformers"
      pattern: "from.*generator import"
    - from: "src/qm_nmr_calc/conformers/pipeline.py"
      to: "src/qm_nmr_calc/conformers/filters.py"
      via: "imports deduplicate_by_rmsd, filter_by_energy_window"
      pattern: "from.*filters import"
    - from: "src/qm_nmr_calc/conformers/pipeline.py"
      to: "src/qm_nmr_calc/models.py"
      via: "creates ConformerEnsemble with ConformerData instances"
      pattern: "ConformerEnsemble|ConformerData"
    - from: "src/qm_nmr_calc/conformers/pipeline.py"
      to: "src/qm_nmr_calc/storage.py"
      via: "calls create_conformer_directories for per-conformer isolation"
      pattern: "create_conformer_directories"
    - from: "src/qm_nmr_calc/conformers/pipeline.py"
      to: "rdkit.Chem.rdmolfiles"
      via: "MolToXYZFile for writing conformer geometries"
      pattern: "MolToXYZFile"
---

<objective>
Wire the conformer generation pipeline end-to-end: generate, optimize, deduplicate, filter, write XYZ files, and populate ConformerEnsemble model.

Purpose: This plan connects the generator (Plan 01) and filters (Plan 02) into a single callable pipeline that takes a SMILES string and returns a fully populated ConformerEnsemble with XYZ files on disk. This is the function that Phase 15 (NWChem integration) will call to get conformers ready for DFT.

Output: `conformers/pipeline.py` with `generate_conformer_ensemble()` function and integration tests proving the full workflow.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-rdkit-conformer-generation/13-RESEARCH.md
@.planning/phases/13-rdkit-conformer-generation/13-01-SUMMARY.md
@.planning/phases/13-rdkit-conformer-generation/13-02-SUMMARY.md

@src/qm_nmr_calc/models.py
@src/qm_nmr_calc/storage.py
@src/qm_nmr_calc/conformers/generator.py
@src/qm_nmr_calc/conformers/filters.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create conformer pipeline orchestration</name>
  <files>src/qm_nmr_calc/conformers/pipeline.py</files>
  <action>
    Create `generate_conformer_ensemble()` function that orchestrates the full pipeline:

    ```python
    def generate_conformer_ensemble(
        smiles: str,
        job_id: str,
        max_conformers: int | None = None,
        energy_window_kcal: float = 6.0,
        rmsd_threshold: float = 0.5,
        random_seed: int = 0xF00D,
    ) -> ConformerEnsemble:
    ```

    Pipeline steps:
    1. Calculate adaptive conformer count via calculate_num_conformers(smiles, max_conformers)
    2. Generate conformers via generate_conformers_kdg(smiles, num_confs, random_seed)
    3. Optimize with MMFF via optimize_conformers_mmff(mol) -- returns (not_converged, energy) tuples
    4. Extract conf_ids and energies as parallel lists
    5. Filter by energy window via filter_by_energy_window(conf_ids, energies, energy_window_kcal)
    6. Deduplicate by RMSD via deduplicate_by_rmsd(mol, rmsd_threshold) -- BUT only on the energy-filtered mol
       - IMPORTANT: Before dedup, remove conformers that failed energy filter from the mol.
         Approach: create a mapping of kept conf_ids after energy filter, then pass to dedup.
         Actually, deduplicate_by_rmsd works on the full mol but we only need to dedup among
         the energy-filtered set. Simplest: run dedup on full mol, then intersect with energy-filtered set.
         Better approach: Run energy filter first to get kept_ids, then for dedup, iterate only
         over kept_ids comparing pairwise with GetBestRMS. Implement this by passing the
         energy-filtered conf_ids into a version of dedup that accepts a subset.

         SIMPLEST correct approach: Run dedup FIRST (on all conformers), then energy filter on the
         deduped set. Order doesn't affect correctness because:
         - Dedup removes geometric duplicates (same structure, ~same energy)
         - Energy filter removes high-energy outliers
         Both are independent filters. Run dedup first to reduce the set, then energy filter.

    Revised pipeline order (dedup before energy filter):
    4. Extract conf_ids and energies
    5. Deduplicate by RMSD: kept_ids = deduplicate_by_rmsd(mol, rmsd_threshold)
    6. Filter kept_ids/energies to only deduped ones
    7. Apply energy window filter on the deduped subset

    8. Create per-conformer storage directories via create_conformer_directories(job_id, conformer_string_ids)
       - conformer_string_ids are "conf_001", "conf_002", etc. (1-based, zero-padded to 3 digits)
    9. Write XYZ files for each surviving conformer using rdmolfiles.MolToXYZFile(mol, path, confId=conf_id)
       - Write to the output/conformers/{conf_id}/ directory as "geometry.xyz"
    10. Build ConformerData list:
        - conformer_id: "conf_001", "conf_002", etc.
        - energy: MMFF energy (kcal/mol)
        - energy_unit: "kcal_mol"
        - geometry_file: relative path "output/conformers/conf_001/geometry.xyz"
        - status: "pending" (ready for DFT in Phase 15)
    11. Build and return ConformerEnsemble:
        - method: "rdkit_kdg"
        - conformers: the ConformerData list
        - pre_dft_energy_window_kcal: energy_window_kcal
        - total_generated: number of conformers from step 2
        - total_after_pre_filter: number surviving dedup + energy filter

    Import from:
    - `from .generator import generate_conformers_kdg, optimize_conformers_mmff, calculate_num_conformers`
    - `from .filters import deduplicate_by_rmsd, filter_by_energy_window`
    - `from ..models import ConformerData, ConformerEnsemble`
    - `from ..storage import create_conformer_directories`
    - `from rdkit.Chem import rdmolfiles`

    Also update `src/qm_nmr_calc/conformers/__init__.py` to export `generate_conformer_ensemble`
    for clean public API:
    ```python
    from .pipeline import generate_conformer_ensemble
    ```
  </action>
  <verify>
    ```bash
    cd /home/chris/develop/qm-nmr-calc && python -c "from qm_nmr_calc.conformers import generate_conformer_ensemble; print('Import OK')"
    ```
  </verify>
  <done>
    pipeline.py exists with generate_conformer_ensemble function.
    Function imports from generator.py, filters.py, models.py, and storage.py.
    __init__.py re-exports generate_conformer_ensemble.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integration tests for full conformer pipeline</name>
  <files>tests/test_conformer_pipeline.py</files>
  <action>
    Create integration tests that exercise the full pipeline. Use real RDKit operations
    (not mocks) since these are fast (< 1 second per molecule).

    Test class: TestConformerPipeline

    Tests to write:

    1. test_generates_ensemble_for_ethanol:
       - SMILES: "CCO"
       - Call generate_conformer_ensemble("CCO", "test_job_001", tmp_path as job dir)
       - Assert returns ConformerEnsemble with method="rdkit_kdg"
       - Assert len(ensemble.conformers) >= 1
       - Assert total_generated >= len(ensemble.conformers) (filtering reduces count)
       - Assert all conformers have energy (float, not None)
       - Assert all conformers have energy_unit == "kcal_mol"
       - Assert all conformers have geometry_file (not None)
       - Assert all conformers have status == "pending"

    2. test_generates_ensemble_for_flexible_molecule:
       - SMILES: "CCCCCCCCCC" (decane -- many rotatable bonds)
       - Call with default params
       - Assert total_generated > 50 (adaptive count should be 200 for >8 rotatable bonds)
       - Assert conformers list is not empty

    3. test_writes_xyz_files_to_disk:
       - SMILES: "CCO"
       - Monkeypatch storage.DATA_DIR to tmp_path
       - Call generate_conformer_ensemble
       - For each conformer in result, check that the geometry_file path exists on disk
       - Check that XYZ files have content (non-empty)
       - Check XYZ file starts with atom count line (first line is integer)

    4. test_creates_conformer_directories:
       - SMILES: "CCO"
       - Monkeypatch storage.DATA_DIR to tmp_path
       - Call generate_conformer_ensemble
       - Assert output/conformers/ directory exists with subdirectories
       - Assert scratch/conformers/ directory exists with subdirectories

    5. test_energy_window_reduces_conformer_count:
       - SMILES: "CCCCCCCC" (octane -- flexible, generates diverse conformers)
       - Call with energy_window_kcal=0.5 (very tight window)
       - Assert total_after_pre_filter < total_generated (some should be filtered)

    6. test_max_conformers_override:
       - SMILES: "CCO"
       - Call with max_conformers=3
       - Assert total_generated <= 3

    7. test_conformer_ids_are_sequential:
       - SMILES: "CCO"
       - Call generate_conformer_ensemble
       - Assert conformer IDs are "conf_001", "conf_002", etc. (sequential, 1-based)

    8. test_invalid_smiles_raises_error:
       - SMILES: "invalid_smiles"
       - Assert raises ValueError

    IMPORTANT: For tests that need filesystem (tests 3, 4, 5), monkeypatch
    `qm_nmr_calc.storage.DATA_DIR` to `tmp_path` so tests use temp directories.
    Follow the pattern from tests/test_conformer_models.py.

    Use pytest fixtures:
    - `tmp_path` for temp directories
    - `monkeypatch` for DATA_DIR patching
  </action>
  <verify>
    ```bash
    cd /home/chris/develop/qm-nmr-calc && python -m pytest tests/test_conformer_pipeline.py -v
    ```
    All tests pass. Full regression check:
    ```bash
    cd /home/chris/develop/qm-nmr-calc && python -m pytest --tb=short -q
    ```
  </verify>
  <done>
    - 8 integration tests covering end-to-end pipeline
    - Tests verify ConformerEnsemble population, XYZ file writing, directory creation
    - Tests verify adaptive count, energy filtering, conformer ID naming
    - All tests pass, no regressions
  </done>
</task>

</tasks>

<verification>
Full test suite passes:
```bash
cd /home/chris/develop/qm-nmr-calc && python -m pytest --tb=short -q
```

Pipeline produces valid output:
```bash
cd /home/chris/develop/qm-nmr-calc && python -c "
from qm_nmr_calc.conformers import generate_conformer_ensemble
# Quick smoke test (will fail on storage since no tmp_path, but validates import chain)
print('Pipeline module loaded successfully')
print('generate_conformer_ensemble callable:', callable(generate_conformer_ensemble))
"
```
</verification>

<success_criteria>
- generate_conformer_ensemble("CCO", job_id) returns ConformerEnsemble with conformers
- XYZ files written to per-conformer output directories
- ConformerData populated with energy, energy_unit, geometry_file, status
- ConformerEnsemble has correct method, total_generated, total_after_pre_filter
- All 8+ integration tests pass
- Full test suite passes (no regressions)
- RDKit-only mode works (no CREST/xTB needed)
</success_criteria>

<output>
After completion, create `.planning/phases/13-rdkit-conformer-generation/13-03-SUMMARY.md`
</output>
