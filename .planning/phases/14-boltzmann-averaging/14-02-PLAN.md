---
phase: 14-boltzmann-averaging
plan: "02"
type: tdd
wave: 2
depends_on: ["14-01"]
files_modified:
  - src/qm_nmr_calc/conformers/boltzmann.py
  - tests/test_boltzmann.py
  - src/qm_nmr_calc/conformers/__init__.py
autonomous: true

must_haves:
  truths:
    - "System computes population-weighted average chemical shifts across conformer ensemble"
    - "Atom matching works correctly by index across all conformers"
    - "Averaged shifts preserve atom metadata (index, atom type)"
    - "Single-conformer ensemble returns that conformer's shifts unchanged"
    - "H1 and C13 shifts are both averaged independently"
    - "ConformerData.weight populated for each conformer after averaging"
    - "Returned NMRResults has correct functional, basis_set, solvent metadata"
  artifacts:
    - path: "src/qm_nmr_calc/conformers/boltzmann.py"
      provides: "Boltzmann weight calculation AND ensemble NMR averaging"
      exports: ["calculate_boltzmann_weights", "average_nmr_shifts", "average_ensemble_nmr"]
      min_lines: 100
    - path: "tests/test_boltzmann.py"
      provides: "Tests for both weight calculation and NMR averaging"
      min_lines: 200
    - path: "src/qm_nmr_calc/conformers/__init__.py"
      provides: "Public API exports including Boltzmann functions"
  key_links:
    - from: "src/qm_nmr_calc/conformers/boltzmann.py"
      to: "models.AtomShift"
      via: "import for constructing averaged shift results"
      pattern: "AtomShift"
    - from: "src/qm_nmr_calc/conformers/boltzmann.py"
      to: "models.NMRResults"
      via: "import for constructing averaged NMR results"
      pattern: "NMRResults"
    - from: "src/qm_nmr_calc/conformers/boltzmann.py"
      to: "models.ConformerEnsemble"
      via: "import for high-level averaging function"
      pattern: "ConformerEnsemble"
    - from: "src/qm_nmr_calc/conformers/boltzmann.py"
      to: "calculate_boltzmann_weights"
      via: "internal call from average_ensemble_nmr"
      pattern: "calculate_boltzmann_weights"
---

<objective>
Implement ensemble NMR shift averaging using Boltzmann weights, plus the high-level orchestration function, using TDD.

Purpose: This completes the Boltzmann averaging pipeline. Once weights are calculated (Plan 01), this plan uses them to compute population-weighted average chemical shifts across all conformers. The high-level `average_ensemble_nmr` function ties everything together: it takes a ConformerEnsemble + per-conformer NMR results, calculates weights, averages shifts, populates ConformerData.weight, and returns a single NMRResults.

Output: Two new functions in `conformers/boltzmann.py` (`average_nmr_shifts`, `average_ensemble_nmr`) with comprehensive tests, plus updated `__init__.py` exports.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-boltzmann-averaging/14-01-SUMMARY.md

@src/qm_nmr_calc/models.py
@src/qm_nmr_calc/conformers/boltzmann.py
@src/qm_nmr_calc/shifts.py
@tests/test_boltzmann.py
</context>

<feature>
  <name>Ensemble NMR Shift Averaging</name>
  <files>
    src/qm_nmr_calc/conformers/boltzmann.py
    tests/test_boltzmann.py
    src/qm_nmr_calc/conformers/__init__.py
  </files>
  <behavior>
    Function 1: average_nmr_shifts(per_conformer_shifts: list[list[AtomShift]], weights: list[float]) -> list[AtomShift]
    - Takes a list of per-conformer shift lists (one list[AtomShift] per conformer) and corresponding weights
    - Returns a single list[AtomShift] with population-weighted average shifts
    - Atom matching is by index field (NWChem 1-based atom index)

    Test cases for average_nmr_shifts:
    - Two conformers, equal weights [0.5, 0.5]:
      Conf1: [AtomShift(index=1, atom="H", shielding=30.0, shift=2.0)]
      Conf2: [AtomShift(index=1, atom="H", shielding=32.0, shift=1.5)]
      Result: [AtomShift(index=1, atom="H", shielding=31.0, shift=1.75)]
    - Two conformers, unequal weights [0.75, 0.25]:
      Conf1: [AtomShift(index=1, atom="H", shielding=30.0, shift=2.0)]
      Conf2: [AtomShift(index=1, atom="H", shielding=34.0, shift=1.0)]
      Result: [AtomShift(index=1, atom="H", shielding=31.0, shift=1.75)]
      (shielding: 0.75*30 + 0.25*34 = 31.0, shift: 0.75*2.0 + 0.25*1.0 = 1.75)
    - Single conformer, weight [1.0]:
      Returns identical shifts (identity case)
    - Multiple atoms (H and C):
      Three atoms across two conformers -> correctly averages each atom independently
    - Mismatched conformer count and weight count -> ValueError

    Function 2: average_ensemble_nmr(ensemble: ConformerEnsemble, per_conformer_nmr: list[NMRResults]) -> NMRResults
    - High-level orchestration function
    - Takes ConformerEnsemble (for energies, energy_unit, temperature_k) and per-conformer NMRResults
    - Calculates Boltzmann weights from ensemble conformer energies
    - Averages H1 shifts and C13 shifts independently
    - Populates ConformerData.weight for each conformer in the ensemble (mutates ensemble)
    - Returns single NMRResults with averaged shifts, functional/basis_set/solvent from first conformer's results

    Test cases for average_ensemble_nmr:
    - Two conformers with known energies and shifts:
      Ensemble: conformers with energies [0.0, 0.59] kcal/mol at 298.15 K
      NMR: two NMRResults with different shifts
      Result: Weights ~[0.73, 0.27], shifts are weighted averages
      Verify: ensemble.conformers[0].weight approx 0.73, ensemble.conformers[1].weight approx 0.27
    - Single conformer ensemble:
      Returns NMRResults identical to input
      Weight = 1.0
    - Shifts sorted descending by shift value (standard NMR convention)
    - functional, basis_set, solvent copied from first NMRResults

    Edge cases:
    - Empty per_conformer_nmr list -> ValueError
    - Mismatched count (ensemble.conformers length != per_conformer_nmr length) -> ValueError
    - Conformers with None energy -> ValueError("All conformers must have energies")
    - Conformers with None energy_unit -> ValueError("All conformers must have energy_unit")
  </behavior>
  <implementation>
    Add to existing src/qm_nmr_calc/conformers/boltzmann.py (which already has calculate_boltzmann_weights from Plan 01):

    Function 1: average_nmr_shifts(
        per_conformer_shifts: list[list[AtomShift]],
        weights: list[float],
    ) -> list[AtomShift]

    Implementation:
    1. Validate len(per_conformer_shifts) == len(weights)
    2. If single conformer, return that conformer's shifts directly (fast path)
    3. Build dict keyed by atom index: {index: {shielding_sum, shift_sum, atom, count}}
    4. For each conformer i, for each AtomShift in per_conformer_shifts[i]:
       - Accumulate: shielding_sum += weights[i] * atom_shift.shielding
       - Accumulate: shift_sum += weights[i] * atom_shift.shift
       - Store atom type from first conformer encountered
    5. Build result list[AtomShift] from accumulated values
    6. Round shift to 2 decimal places, shielding to 4 (matching existing conventions in shifts.py)
    7. Return sorted by shift descending (NMR convention)

    Function 2: average_ensemble_nmr(
        ensemble: ConformerEnsemble,
        per_conformer_nmr: list[NMRResults],
    ) -> NMRResults

    Implementation:
    1. Validate inputs: non-empty, matching lengths, all conformers have energy and energy_unit
    2. Extract energies from ensemble.conformers (list of .energy values)
    3. Get energy_unit from first conformer (all should match -- validate this)
    4. Call calculate_boltzmann_weights(energies, ensemble.temperature_k, energy_unit)
    5. Populate ensemble.conformers[i].weight = weights[i] for each conformer (mutate in place)
    6. Collect H1 shifts: per_conformer_h1 = [nmr.h1_shifts for nmr in per_conformer_nmr]
    7. Collect C13 shifts: per_conformer_c13 = [nmr.c13_shifts for nmr in per_conformer_nmr]
    8. Average H1: avg_h1 = average_nmr_shifts(per_conformer_h1, weights)
    9. Average C13: avg_c13 = average_nmr_shifts(per_conformer_c13, weights)
    10. Return NMRResults(
          h1_shifts=sorted(avg_h1, key=lambda x: x.shift, reverse=True),
          c13_shifts=sorted(avg_c13, key=lambda x: x.shift, reverse=True),
          functional=per_conformer_nmr[0].functional,
          basis_set=per_conformer_nmr[0].basis_set,
          solvent=per_conformer_nmr[0].solvent,
        )

    Update src/qm_nmr_calc/conformers/__init__.py:
    - Add imports: calculate_boltzmann_weights, average_nmr_shifts, average_ensemble_nmr
    - Update __all__ to include all three functions plus existing generate_conformer_ensemble

    IMPORTANT: AtomShift uses strict=True in ConfigDict, so construct with all 4 fields.
    IMPORTANT: NMRResults uses strict=True, so pass exact types (no coercion).
    IMPORTANT: average_nmr_shifts should handle the case where a nucleus type has zero atoms across all conformers (return empty list).
  </implementation>
</feature>

<verification>
```bash
cd /home/chris/develop/qm-nmr-calc && python -m pytest tests/test_boltzmann.py -v
```
All tests pass (including Plan 01 tests). No regressions in existing tests:
```bash
cd /home/chris/develop/qm-nmr-calc && python -m pytest --tb=short -q
```
</verification>

<success_criteria>
- average_nmr_shifts with equal weights [0.5, 0.5] returns arithmetic mean of shifts
- average_nmr_shifts with [0.75, 0.25] weights returns correctly weighted shifts
- average_ensemble_nmr populates ConformerData.weight for each conformer
- average_ensemble_nmr returns NMRResults with averaged h1_shifts and c13_shifts
- Single-conformer ensemble returns identical NMRResults with weight=1.0
- Shifts sorted descending by shift value in returned NMRResults
- Mismatched input sizes raise ValueError
- Missing energy/energy_unit raises ValueError
- __init__.py exports all Boltzmann functions
- At least 10 new test cases for averaging functions
- All existing tests still pass (including Plan 01 tests)
</success_criteria>

<output>
After completion, create `.planning/phases/14-boltzmann-averaging/14-02-SUMMARY.md`
</output>
