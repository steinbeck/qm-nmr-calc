---
phase: 14-boltzmann-averaging
plan: "01"
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/qm_nmr_calc/conformers/boltzmann.py
  - tests/test_boltzmann.py
autonomous: true

must_haves:
  truths:
    - "System calculates Boltzmann weights from energies using exp-normalize trick with no overflow/underflow"
    - "Equal energies produce equal weights (each = 1/N)"
    - "Single conformer returns weight = 1.0"
    - "Large energy difference (20 kcal/mol at 298K) gives dominant conformer weight near 1.0"
    - "Two conformers 0.59 kcal/mol apart produce approximately 73%/27% at 298K"
    - "Temperature parameter correctly applied (default 298.15 K)"
    - "Energy unit conversion handles hartree, kcal_mol, and kj_mol correctly"
    - "Weights always sum to 1.0 (within floating-point tolerance)"
  artifacts:
    - path: "src/qm_nmr_calc/conformers/boltzmann.py"
      provides: "Boltzmann weight calculation with energy conversion and numerical stability"
      exports: ["calculate_boltzmann_weights"]
      min_lines: 40
    - path: "tests/test_boltzmann.py"
      provides: "Unit tests for Boltzmann weight calculation"
      min_lines: 100
  key_links:
    - from: "src/qm_nmr_calc/conformers/boltzmann.py"
      to: "math.exp"
      via: "exp-normalize trick for numerical stability"
      pattern: "exp\\("
    - from: "src/qm_nmr_calc/conformers/boltzmann.py"
      to: "models.EnergyUnit"
      via: "energy_unit parameter type"
      pattern: "EnergyUnit"
---

<objective>
Implement numerically stable Boltzmann weight calculation from DFT energies using TDD.

Purpose: This is the core statistical mechanics computation for conformer weighting. Boltzmann weights determine each conformer's population contribution to the ensemble-averaged NMR spectrum. Numerical stability via the exp-normalize trick is critical because DFT energy differences can span 0-20+ kcal/mol, which would cause overflow/underflow with naive exponentiation.

Output: Tested `conformers/boltzmann.py` module with `calculate_boltzmann_weights` function covering energy unit conversion, numerical stability, and edge cases.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/qm_nmr_calc/models.py
@src/qm_nmr_calc/conformers/filters.py
@tests/test_conformer_filters.py
</context>

<feature>
  <name>Boltzmann Weight Calculation</name>
  <files>
    src/qm_nmr_calc/conformers/boltzmann.py
    tests/test_boltzmann.py
  </files>
  <behavior>
    Function: calculate_boltzmann_weights(energies, temperature_k=298.15, energy_unit="kcal_mol") -> list[float]

    Energy conversion cases:
    - energies=[10.0, 11.0], energy_unit="kcal_mol" -> uses values directly
    - energies=[-76.0, -75.999], energy_unit="hartree" -> converts to kcal/mol (* 627.5095)
    - energies=[41.84, 46.02], energy_unit="kj_mol" -> converts to kcal/mol (/ 4.184)

    Weight calculation cases (all at 298.15 K where RT = 0.5922 kcal/mol):
    - Single conformer: [0.0] -> [1.0]
    - Equal energies: [5.0, 5.0, 5.0] -> [0.3333, 0.3333, 0.3333] (within tolerance)
    - Two conformers 0.59 kcal/mol apart: [0.0, 0.59] -> approx [0.73, 0.27]
      (Exact: exp(0)/[exp(0)+exp(-0.59/0.5922)] = 1/[1+0.3691] = 0.7305)
    - Large gap 20 kcal/mol: [0.0, 20.0] -> approx [1.0, ~0.0] (dominant conformer)
    - Five conformers [0.0, 0.5, 1.0, 2.0, 5.0] -> weights summing to 1.0, monotonically decreasing

    Numerical stability:
    - Energies [0.0, 100.0] (extreme range) -> no overflow/underflow, weights sum to 1.0
    - Energies [-1000.0, -999.0] (large negatives) -> same result as [0.0, 1.0] (relative differences matter)
    - Energies [500.0, 500.5, 501.0] (large absolute values) -> correct relative weights

    Edge cases:
    - Empty list [] -> ValueError("At least one energy value required")
    - temperature_k=0 -> ValueError (division by zero prevention)
    - temperature_k < 0 -> ValueError (non-physical temperature)

    Return contract:
    - Returns list[float] same length as input
    - All weights >= 0.0
    - Sum of weights = 1.0 (within 1e-10 tolerance)
    - Lower energy -> higher weight (monotonic relationship)
  </behavior>
  <implementation>
    Create src/qm_nmr_calc/conformers/boltzmann.py with:

    Constants:
    - R_KCAL = 0.001987204  # Gas constant in kcal/(mol*K)
    - HARTREE_TO_KCAL = 627.5095  # Conversion factor
    - KJ_TO_KCAL = 1.0 / 4.184  # Conversion factor

    Function: calculate_boltzmann_weights(
        energies: list[float],
        temperature_k: float = 298.15,
        energy_unit: EnergyUnit = "kcal_mol",
    ) -> list[float]

    Implementation steps:
    1. Validate inputs: non-empty list, temperature > 0
    2. Convert energies to kcal/mol based on energy_unit:
       - "kcal_mol": use as-is
       - "hartree": multiply by HARTREE_TO_KCAL (627.5095)
       - "kj_mol": multiply by KJ_TO_KCAL (1/4.184)
    3. Single conformer shortcut: if len == 1, return [1.0]
    4. Calculate RT = R_KCAL * temperature_k
    5. Apply exp-normalize trick:
       a. Find min_energy = min(energies_kcal)
       b. Compute relative energies: e_rel_i = e_i - min_energy (all >= 0)
       c. Compute unnormalized weights: w_i = exp(-e_rel_i / RT)
       d. Normalize: weight_i = w_i / sum(w_i)
    6. Return list of normalized weights

    Use math.exp (not numpy) -- this is pure Python, no numpy dependency.
    Import EnergyUnit from models for type annotation.

    IMPORTANT: Do NOT use numpy. The project uses pure Python + Pydantic.
    The exp-normalize trick ensures stability:
    - Subtracting min_energy means all exponent arguments are <= 0
    - exp(0) = 1.0 for the minimum energy conformer (no overflow)
    - exp(-large_negative) approaches 0.0 (underflow to 0 is fine -- those conformers have negligible population)
  </implementation>
</feature>

<verification>
```bash
cd /home/chris/develop/qm-nmr-calc && python -m pytest tests/test_boltzmann.py -v
```
All tests pass. No regressions in existing tests:
```bash
cd /home/chris/develop/qm-nmr-calc && python -m pytest --tb=short -q
```
</verification>

<success_criteria>
- calculate_boltzmann_weights([0.0, 0.59]) returns weights approximately [0.73, 0.27] at 298.15 K
- Single conformer [X] returns [1.0] for any energy value
- Equal energies return equal weights (1/N each)
- Extreme energy range [0.0, 100.0] produces valid weights without overflow/underflow
- Hartree energies correctly converted (1 hartree = 627.5095 kcal/mol)
- Weights always sum to 1.0 within floating-point tolerance
- Empty input and invalid temperature raise ValueError
- At least 12 test cases covering all behavior categories above
- No existing tests broken
</success_criteria>

<output>
After completion, create `.planning/phases/14-boltzmann-averaging/14-01-SUMMARY.md`
</output>
