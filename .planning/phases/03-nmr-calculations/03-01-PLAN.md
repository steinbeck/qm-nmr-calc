---
phase: 03-nmr-calculations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/qm_nmr_calc/presets.py
  - src/qm_nmr_calc/shifts.py
  - src/qm_nmr_calc/solvents.py
autonomous: true

must_haves:
  truths:
    - "Preset configurations define different calculation parameters"
    - "Shielding values can be converted to chemical shifts"
    - "Solvent names can be validated against supported list"
  artifacts:
    - path: "src/qm_nmr_calc/presets.py"
      provides: "PresetName enum and PRESETS configuration dict"
      exports: ["PresetName", "PRESETS", "DEFAULT_PRESET", "CalculationPreset"]
    - path: "src/qm_nmr_calc/shifts.py"
      provides: "Shielding-to-shift conversion with scaling factors"
      exports: ["shielding_to_shift", "SCALING_FACTORS"]
    - path: "src/qm_nmr_calc/solvents.py"
      provides: "COSMO solvent validation"
      exports: ["validate_solvent", "SUPPORTED_SOLVENTS"]
  key_links:
    - from: "src/qm_nmr_calc/presets.py"
      to: "DFT parameters"
      via: "PRESETS dict with functional, basis_set, nmr_basis_set"
      pattern: "PRESETS.*functional.*basis_set"
    - from: "src/qm_nmr_calc/shifts.py"
      to: "NMR chemical shifts"
      via: "Linear regression: shift = m * shielding + b"
      pattern: "m.*shielding.*b"
---

<objective>
Create the foundational modules for NMR calculations: preset configurations, shielding-to-shift conversion, and solvent validation.

Purpose: These modules provide the configuration and conversion logic needed by the NMR calculation pipeline. Presets define different quality/speed tradeoffs, shifts.py converts raw shielding to user-friendly ppm values, and solvents.py validates user-provided solvent names.

Output: Three new Python modules in src/qm_nmr_calc/ ready for import by the calculation pipeline.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-nmr-calculations/03-CONTEXT.md
@.planning/phases/03-nmr-calculations/03-RESEARCH.md
@src/qm_nmr_calc/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create presets module</name>
  <files>src/qm_nmr_calc/presets.py</files>
  <action>
Create presets.py with:

1. PresetName enum (str, Enum) with values: DRAFT = "draft", PRODUCTION = "production"

2. CalculationPreset TypedDict with fields:
   - name: str
   - description: str
   - functional: str
   - basis_set: str (for geometry optimization)
   - nmr_basis_set: str (for NMR shielding - can differ)
   - processes: int
   - max_iter: int

3. PRESETS dict mapping PresetName to CalculationPreset:
   - DRAFT: functional='b3lyp', basis_set='6-31G*', nmr_basis_set='6-31G*', processes=4, max_iter=100
   - PRODUCTION: functional='b3lyp', basis_set='6-31G*', nmr_basis_set='6-311+G(2d,p)', processes=4, max_iter=150

4. DEFAULT_PRESET = PresetName.PRODUCTION

Reference RESEARCH.md Pattern 2 for exact structure. Use TypedDict (not BaseModel) for preset config since it's just configuration data, not API validation.
  </action>
  <verify>python -c "from qm_nmr_calc.presets import PresetName, PRESETS, DEFAULT_PRESET; print(PRESETS[PresetName.PRODUCTION]['nmr_basis_set'])"</verify>
  <done>PresetName enum exists with draft/production, PRESETS dict contains both configurations with correct parameters, DEFAULT_PRESET is production</done>
</task>

<task type="auto">
  <name>Task 2: Create shifts module</name>
  <files>src/qm_nmr_calc/shifts.py</files>
  <action>
Create shifts.py with:

1. SCALING_FACTORS dict with linear regression parameters for B3LYP/6-311+G(2d,p):
   - 'H': {'m': -1.0, 'b': 31.8} (TMS reference for 1H)
   - 'C': {'m': -1.0, 'b': 182.5} (TMS reference for 13C)

2. shielding_to_shift(shielding_data: dict, scaling: dict = SCALING_FACTORS) -> dict function:
   - Input format (from NWChemParser): {'index': [1,2,3...], 'atom': ['H','C'...], 'shielding': [29.1, 156.2...]}
   - For each atom, if atom type in scaling: shift = m * shielding + b
   - Build list of dicts: {'index': idx, 'atom': atom, 'shielding': shield, 'shift': round(shift, 2)}
   - Separate into h_shifts (atom == 'H') and c_shifts (atom == 'C')
   - Sort each by shift value descending (highest ppm first, standard NMR convention)
   - Return: {'1H': h_shifts, '13C': c_shifts}

Reference RESEARCH.md Pattern 3 for implementation. Handle case where shielding_data might be missing 'index', 'atom', or 'shielding' keys - raise ValueError with descriptive message.
  </action>
  <verify>python -c "from qm_nmr_calc.shifts import shielding_to_shift; result = shielding_to_shift({'index': [1,2], 'atom': ['H','C'], 'shielding': [29.0, 155.0]}); print(result['1H'][0]['shift'], result['13C'][0]['shift'])"</verify>
  <done>shielding_to_shift converts shielding to shifts using linear regression, returns separate 1H and 13C lists sorted by shift descending</done>
</task>

<task type="auto">
  <name>Task 3: Create solvents module</name>
  <files>src/qm_nmr_calc/solvents.py</files>
  <action>
Create solvents.py with:

1. SUPPORTED_SOLVENTS dict mapping NWChem COSMO solvent names to descriptions:
   - 'chcl3': 'Chloroform (CDCl3)'
   - 'dmso': 'Dimethylsulfoxide (DMSO-d6)'
   - 'methanol': 'Methanol (CD3OD)'
   - 'acetone': 'Acetone (acetone-d6)'
   - 'benzene': 'Benzene (C6D6)'
   - 'h2o': 'Water (D2O)'
   - 'acetntrl': 'Acetonitrile (CD3CN)'
   - 'dcm': 'Dichloromethane (CD2Cl2)'
   - 'thf': 'Tetrahydrofuran (THF-d8)'
   - 'pyridine': 'Pyridine (pyridine-d5)'
   - 'toluene': 'Toluene (toluene-d8)'

2. validate_solvent(solvent: str) -> str | None function:
   - Normalize input: lower().strip()
   - If normalized name in SUPPORTED_SOLVENTS, return normalized name
   - Otherwise return None

3. get_supported_solvents() -> list[str] function:
   - Returns sorted list of supported solvent names (for API documentation)

Reference RESEARCH.md Pattern 4 for solvent list from NWChem documentation.
  </action>
  <verify>python -c "from qm_nmr_calc.solvents import validate_solvent, get_supported_solvents; print(validate_solvent('CDCl3'), validate_solvent('chcl3'), len(get_supported_solvents()))"</verify>
  <done>validate_solvent normalizes and validates solvent names, get_supported_solvents returns list for API documentation, common NMR solvents supported</done>
</task>

</tasks>

<verification>
All three modules importable and functional:
```bash
python -c "
from qm_nmr_calc.presets import PresetName, PRESETS, DEFAULT_PRESET
from qm_nmr_calc.shifts import shielding_to_shift, SCALING_FACTORS
from qm_nmr_calc.solvents import validate_solvent, SUPPORTED_SOLVENTS

# Test presets
assert DEFAULT_PRESET == PresetName.PRODUCTION
assert PRESETS[PresetName.DRAFT]['nmr_basis_set'] == '6-31G*'
assert PRESETS[PresetName.PRODUCTION]['nmr_basis_set'] == '6-311+G(2d,p)'

# Test shifts
result = shielding_to_shift({'index': [1], 'atom': ['H'], 'shielding': [29.0]})
assert '1H' in result and '13C' in result
assert result['1H'][0]['shift'] == 2.8  # 31.8 - 29.0 = 2.8

# Test solvents
assert validate_solvent('CHCl3') == 'chcl3'
assert validate_solvent('invalid') is None

print('All verifications passed')
"
```
</verification>

<success_criteria>
- presets.py exports PresetName, PRESETS, DEFAULT_PRESET, CalculationPreset
- shifts.py exports shielding_to_shift with correct TMS-referenced conversion
- solvents.py exports validate_solvent with case-insensitive matching
- All modules follow existing codebase patterns (type hints, docstrings)
</success_criteria>

<output>
After completion, create `.planning/phases/03-nmr-calculations/03-01-SUMMARY.md`
</output>
