---
phase: 03-nmr-calculations
plan: 03
type: execute
wave: 3
depends_on: ["03-01", "03-02"]
files_modified:
  - src/qm_nmr_calc/isicle_wrapper.py
  - src/qm_nmr_calc/tasks.py
  - src/qm_nmr_calc/storage.py
  - src/qm_nmr_calc/api/routers/jobs.py
autonomous: true

must_haves:
  truths:
    - "NMR calculation runs geometry optimization then shielding calculation"
    - "Completed jobs have 1H and 13C chemical shifts stored"
    - "User can submit job with preset and solvent parameters"
    - "Different presets use different basis sets for NMR"
  artifacts:
    - path: "src/qm_nmr_calc/isicle_wrapper.py"
      provides: "run_nmr_calculation function for two-step DFT workflow"
      exports: ["run_nmr_calculation"]
    - path: "src/qm_nmr_calc/tasks.py"
      provides: "run_nmr_task Huey task"
      exports: ["run_nmr_task"]
  key_links:
    - from: "src/qm_nmr_calc/tasks.py"
      to: "src/qm_nmr_calc/isicle_wrapper.py"
      via: "run_nmr_task calls run_nmr_calculation"
      pattern: "run_nmr_calculation"
    - from: "src/qm_nmr_calc/isicle_wrapper.py"
      to: "isicle.qm.dft"
      via: "Two DFT calls: optimize then shielding"
      pattern: "tasks=\\['shielding'\\]"
    - from: "src/qm_nmr_calc/api/routers/jobs.py"
      to: "src/qm_nmr_calc/tasks.py"
      via: "Submit endpoint queues run_nmr_task"
      pattern: "run_nmr_task"
---

<objective>
Implement the NMR calculation pipeline: two-step DFT workflow (geometry optimization + NMR shielding), Huey task orchestration, and API endpoint updates to accept preset/solvent.

Purpose: This is the core calculation functionality. When a user submits a job with a solvent and preset, the system runs DFT geometry optimization followed by NMR shielding calculation, converts shielding to chemical shifts, and stores the results.

Output: Working NMR calculation pipeline that produces 1H and 13C chemical shifts for submitted molecules.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-nmr-calculations/03-CONTEXT.md
@.planning/phases/03-nmr-calculations/03-RESEARCH.md
@.planning/phases/03-nmr-calculations/03-01-SUMMARY.md
@.planning/phases/03-nmr-calculations/03-02-SUMMARY.md
@src/qm_nmr_calc/isicle_wrapper.py
@src/qm_nmr_calc/tasks.py
@src/qm_nmr_calc/storage.py
@src/qm_nmr_calc/api/routers/jobs.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add run_nmr_calculation to isicle_wrapper</name>
  <files>src/qm_nmr_calc/isicle_wrapper.py</files>
  <action>
Add run_nmr_calculation() function to isicle_wrapper.py (keep existing run_geometry_optimization):

```python
def run_nmr_calculation(
    smiles: str,
    job_dir: Path,
    preset: dict,  # CalculationPreset from presets.py
    solvent: str,
    processes: int = 4,
) -> dict:
    """
    Run geometry optimization + NMR shielding calculation via ISiCLE/NWChem.

    Args:
        smiles: SMILES string of molecule
        job_dir: Job directory for outputs and scratch
        preset: Calculation preset dict with functional, basis_set, nmr_basis_set
        solvent: NWChem COSMO solvent name
        processes: Number of MPI processes

    Returns:
        dict with 'geometry_file', 'shielding_data', 'energy'

    Raises:
        Exception: If calculation fails (propagate to Huey for error handling)
    """
```

Implementation steps:
1. Load molecule: geom = isicle.load(smiles)
2. Initial optimize: geom = geom.initial_optimize(embed=True, forcefield='UFF', ff_iter=200)
3. Create scratch_dir = job_dir / 'scratch'; mkdir
4. DFT geometry optimization:
   - wrapper = isicle.qm.dft(geom, backend='NWChem', tasks=['optimize'],
     functional=preset['functional'], basis_set=preset['basis_set'],
     cosmo=True, solvent=solvent, max_iter=preset['max_iter'],
     scratch_dir=str(scratch_dir), processes=processes)
   - result = wrapper.parse()
   - optimized_geom = result['geometry']
5. Save optimized geometry to output/optimized.xyz
6. DFT NMR shielding calculation on optimized geometry:
   - nmr_wrapper = isicle.qm.dft(optimized_geom, backend='NWChem', tasks=['shielding'],
     functional=preset['functional'], basis_set=preset['nmr_basis_set'],
     cosmo=True, solvent=solvent, scratch_dir=str(scratch_dir), processes=processes)
   - nmr_result = nmr_wrapper.parse()
7. Return {'geometry_file': str(output_file), 'shielding_data': nmr_result.get('shielding'), 'energy': nmr_result.get('energy')}

Handle None shielding_data by raising RuntimeError("NMR calculation did not produce shielding data").

Reference RESEARCH.md Pattern 1 for the two-step workflow.
  </action>
  <verify>python -c "from qm_nmr_calc.isicle_wrapper import run_nmr_calculation; print('run_nmr_calculation function exists')"</verify>
  <done>run_nmr_calculation function added to isicle_wrapper.py with two-step DFT workflow (optimize + shielding)</done>
</task>

<task type="auto">
  <name>Task 2: Create run_nmr_task and update storage</name>
  <files>src/qm_nmr_calc/tasks.py, src/qm_nmr_calc/storage.py</files>
  <action>
1. Update storage.py - extend create_job_directory to accept preset and solvent:

```python
def create_job_directory(
    smiles: str,
    isicle_version: str,
    nwchem_version: str,
    name: Optional[str] = None,
    preset: str = "production",  # NEW
    solvent: str = "chcl3",      # NEW
) -> JobStatus:
```

Update JobStatus creation to include input with preset and solvent.

2. Add run_nmr_task to tasks.py (alongside existing run_optimization_task):

```python
@huey.task()
def run_nmr_task(job_id: str) -> dict:
    """Execute NMR calculation (geometry opt + shielding) for a queued job."""
```

Implementation:
1. Load job_status via load_job_status(job_id)
2. Validate status is 'queued', raise ValueError if not
3. Get preset config: from .presets import PRESETS, PresetName; preset = PRESETS[PresetName(job_status.input.preset)]
4. Call run_nmr_calculation(smiles, job_dir, preset, job_status.input.solvent)
5. Convert shielding to shifts: from .shifts import shielding_to_shift; shifts = shielding_to_shift(result['shielding_data'])
6. Build NMRResults object from shifts
7. Update job status with nmr_results (use update_job_status or direct write)
8. Save nmr_results.json to output/ directory using orjson
9. Return success dict with job_id and output files

Import NMRResults, AtomShift from models. The signal handlers in queue.py will handle status='running' and status='complete' transitions.
  </action>
  <verify>python -c "from qm_nmr_calc.tasks import run_nmr_task; from qm_nmr_calc.storage import create_job_directory; print('run_nmr_task and extended storage exist')"</verify>
  <done>run_nmr_task Huey task created, storage.create_job_directory accepts preset/solvent, task converts shielding to shifts and stores NMR results</done>
</task>

<task type="auto">
  <name>Task 3: Update API endpoints for preset/solvent</name>
  <files>src/qm_nmr_calc/api/routers/jobs.py</files>
  <action>
Update jobs.py router to accept and validate preset/solvent:

1. Add imports at top:
   - from ...solvents import validate_solvent, SUPPORTED_SOLVENTS
   - from ...tasks import run_nmr_task (add alongside run_optimization_task)

2. Update submit_smiles endpoint:
   - Change request type handling to extract preset and solvent from JobSubmitRequest
   - Validate solvent using validate_solvent(); if None, return 422 with error about invalid solvent
   - Pass preset and solvent to create_job_directory()
   - Change task call from run_optimization_task to run_nmr_task

3. Update submit_file endpoint similarly:
   - Add solvent to Form parameters (required)
   - Add preset to Form parameters (optional, default='production')
   - Validate solvent
   - Pass to create_job_directory
   - Call run_nmr_task instead of run_optimization_task

4. Add endpoint to list supported solvents:
```python
@router.get("/solvents", response_model=list[str])
async def list_solvents():
    """List supported NMR solvents for COSMO solvation."""
    from ...solvents import get_supported_solvents
    return get_supported_solvents()
```

Error response for invalid solvent should be RFC 7807 ProblemDetail format with type "https://qm-nmr-calc.example/problems/invalid-solvent".
  </action>
  <verify>cd /home/christoph_steinbeck_gmail_com/develop/qm-nmr-calc && python -c "from qm_nmr_calc.api.routers.jobs import router; print([r.path for r in router.routes])"</verify>
  <done>API endpoints accept preset/solvent, validate solvent against supported list, queue run_nmr_task, /solvents endpoint returns supported list</done>
</task>

</tasks>

<verification>
Full integration verification:
```bash
# 1. Test imports
python -c "
from qm_nmr_calc.isicle_wrapper import run_nmr_calculation
from qm_nmr_calc.tasks import run_nmr_task
from qm_nmr_calc.storage import create_job_directory
from qm_nmr_calc.api.routers.jobs import router
print('All imports successful')
"

# 2. Test job creation with preset/solvent
python -c "
from qm_nmr_calc.storage import create_job_directory
from qm_nmr_calc.isicle_wrapper import get_versions
v = get_versions()
job = create_job_directory(
    smiles='CCO',
    isicle_version=v.isicle,
    nwchem_version=v.nwchem,
    preset='draft',
    solvent='chcl3'
)
assert job.input.preset == 'draft'
assert job.input.solvent == 'chcl3'
print(f'Job created: {job.job_id} with preset={job.input.preset}, solvent={job.input.solvent}')
"

# 3. Test API (without running consumer)
cd /home/christoph_steinbeck_gmail_com/develop/qm-nmr-calc && python -c "
from fastapi.testclient import TestClient
from qm_nmr_calc.api.app import app

client = TestClient(app)

# Test solvent validation
resp = client.post('/api/v1/jobs', json={'smiles': 'CCO', 'solvent': 'invalid'})
assert resp.status_code == 422

# Test valid submission
resp = client.post('/api/v1/jobs', json={'smiles': 'CCO', 'solvent': 'chcl3'})
assert resp.status_code == 202
data = resp.json()
assert data['preset'] == 'production'
assert data['solvent'] == 'chcl3'

# Test solvents list
resp = client.get('/api/v1/jobs/solvents')
assert resp.status_code == 200
assert 'chcl3' in resp.json()

print('API tests passed')
"
```
</verification>

<success_criteria>
- run_nmr_calculation performs two-step DFT: optimize then shielding
- run_nmr_task orchestrates calculation and stores NMR results
- API accepts preset (default: production) and solvent (required)
- Invalid solvent returns 422 with descriptive error
- GET /api/v1/jobs/solvents returns list of supported solvents
- Existing API patterns maintained (202 Accepted, Location header, etc.)
</success_criteria>

<output>
After completion, create `.planning/phases/03-nmr-calculations/03-03-SUMMARY.md`
</output>
