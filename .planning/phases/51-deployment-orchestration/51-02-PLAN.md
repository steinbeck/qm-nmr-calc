---
phase: 51-deployment-orchestration
plan: 02
type: execute
wave: 2
depends_on: ["51-01"]
files_modified:
  - gcp/deploy-auto.sh
autonomous: true

must_haves:
  truths:
    - "Running ./deploy-auto.sh with valid config.toml deploys end-to-end with zero interactive prompts"
    - "Running ./deploy-auto.sh --dry-run shows all planned actions and cost estimate without executing"
    - "Failed deployment cleans up orphaned VM automatically via trap"
    - "Cost estimate displayed before VM creation with itemized breakdown"
    - "Timestamped progress feedback shown for every step (config, pricing, machine, infra, startup, VM)"
    - "deploy-auto.sh sources gcp/lib/{config,pricing,machine,infra}.sh and calls their functions"
    - "No interactive prompts, no DNS checks, no domain requirements anywhere in the script"
  artifacts:
    - path: "gcp/deploy-auto.sh"
      provides: "Main deployment orchestrator replacing v2.6 deploy-vm.sh"
      min_lines: 100
  key_links:
    - from: "gcp/deploy-auto.sh"
      to: "gcp/lib/config.sh"
      via: "source and load_config()"
      pattern: "source.*lib/config.sh"
    - from: "gcp/deploy-auto.sh"
      to: "gcp/lib/pricing.sh"
      via: "source and get_pricing_table()"
      pattern: "source.*lib/pricing.sh"
    - from: "gcp/deploy-auto.sh"
      to: "gcp/lib/machine.sh"
      via: "source and select_machine()"
      pattern: "source.*lib/machine.sh"
    - from: "gcp/deploy-auto.sh"
      to: "gcp/lib/infra.sh"
      via: "source and infrastructure functions"
      pattern: "source.*lib/infra.sh"
---

<objective>
Create the main deployment orchestrator (gcp/deploy-auto.sh) that replaces v2.6's interactive deploy-vm.sh with a fully automated, non-interactive deployment pipeline.

Purpose: This is the "single command" that deploys end-to-end (DEP-01). It orchestrates all Phase 49-51 libraries in sequence: load config, select machine, create infrastructure, generate startup script, display costs, create VM. Supports --dry-run mode and cleans up on failure.

Output: gcp/deploy-auto.sh -- executable orchestrator script that replaces deploy-vm.sh.
</objective>

<execution_context>
@/Users/steinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/steinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/51-deployment-orchestration/51-RESEARCH.md
@.planning/phases/51-deployment-orchestration/51-01-SUMMARY.md
@gcp/lib/config.sh
@gcp/lib/pricing.sh
@gcp/lib/machine.sh
@gcp/lib/infra.sh
@gcp/deploy-vm.sh
@gcp/select_machine.py
@gcp/config.toml.example
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create gcp/deploy-auto.sh orchestrator</name>
  <files>gcp/deploy-auto.sh</files>
  <action>
Create gcp/deploy-auto.sh as an executable bash script (chmod +x). This is the v2.7 replacement for deploy-vm.sh (RPL-01).

**Header and argument parsing:**
```bash
#!/bin/bash
# Automated GCP deployment for qm-nmr-calc (v2.7)
#
# Deploys end-to-end from TOML config with zero interactive prompts.
# Replaces v2.6 interactive deploy-vm.sh.
#
# Usage:
#   ./deploy-auto.sh                    # Full deployment
#   ./deploy-auto.sh --dry-run          # Show planned actions without executing
#   ./deploy-auto.sh --config path.toml # Use custom config file
#
# Prerequisites:
#   - gcloud CLI installed and authenticated
#   - config.toml created from config.toml.example
#   - jq installed (apt-get install jq)
```

Parse arguments:
- `--dry-run` sets DRY_RUN=true (exported so infra.sh sees it)
- `--config <path>` sets CONFIG_PATH (default: gcp/config.toml)
- Unknown args: log_error and exit 1

**Setup:**
```bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source all libraries
source "$SCRIPT_DIR/lib/config.sh"
source "$SCRIPT_DIR/lib/pricing.sh"
source "$SCRIPT_DIR/lib/machine.sh"
source "$SCRIPT_DIR/lib/infra.sh"

# Register cleanup trap (from infra.sh)
trap cleanup_on_failure EXIT
```

**Main function pipeline (6 steps):**

```bash
main() {
    log_info "=========================================="
    log_info "  qm-nmr-calc Automated GCP Deployment"
    log_info "=========================================="
    [[ "$DRY_RUN" == "true" ]] && log_warn "DRY-RUN MODE: No resources will be created"
    echo ""

    # ── Step 1: Load and validate config ──
    log_info "Step 1/6: Loading configuration..."
    load_config "$CONFIG_PATH" || { log_error "Config validation failed"; exit 1; }
    log_info "  Project:     $GCP_PROJECT_ID"
    log_info "  Prefix:      $RESOURCE_PREFIX"
    log_info "  CPU cores:   $CPU_CORES"
    log_info "  RAM:         ${RAM_GB}GB"
    log_info "  Disk:        ${DISK_SIZE_GB}GB"
    echo ""

    # ── Step 2: Check gcloud authentication ──
    log_info "Step 2/6: Checking gcloud authentication..."
    local active_account
    active_account=$(gcloud auth list --filter=status:ACTIVE --format="value(account)" 2>/dev/null || true)
    if [[ -z "$active_account" ]]; then
        log_error "Not authenticated with gcloud. Run: gcloud auth login"
        exit 1
    fi
    log_info "  Authenticated as: $active_account"
    gcloud config set project "$GCP_PROJECT_ID" --quiet
    echo ""

    # ── Step 3: Select machine and zone ──
    log_info "Step 3/6: Finding cheapest machine type and zone..."
    local machine_json
    machine_json=$(select_machine "$CPU_CORES" "$RAM_GB") || { log_error "Machine selection failed"; exit 1; }

    local machine_type zone region spot_price_hourly
    machine_type=$(echo "$machine_json" | jq -r '.machine_type')
    zone=$(echo "$machine_json" | jq -r '.zone')
    region=$(echo "$machine_json" | jq -r '.region')

    log_info "  Machine type: $machine_type"
    log_info "  Zone:         $zone"
    log_info "  Region:       $region"
    echo ""

    # Get spot pricing for cost estimate
    local pricing_json
    pricing_json=$(get_pricing_table "$CPU_CORES" "$RAM_GB") || true
    spot_price_hourly=$(echo "$pricing_json" | jq -r '.[0].spot_price_hourly // "0.05"')

    # ── Step 4: Display cost estimate ──
    log_info "Step 4/6: Cost estimate..."
    display_cost_estimate "$machine_type" "$spot_price_hourly" "$DISK_SIZE_GB"
    echo ""

    # ── Step 5: Create infrastructure ──
    log_info "Step 5/6: Creating infrastructure..."
    local ip_name="${RESOURCE_PREFIX}-ip"
    local disk_name="${RESOURCE_PREFIX}-data"
    local vm_name="${RESOURCE_PREFIX}-vm"

    local static_ip
    static_ip=$(create_static_ip "$ip_name" "$region")
    create_firewall_rules "$RESOURCE_PREFIX"
    create_persistent_disk "$disk_name" "$zone" "$DISK_SIZE_GB"
    echo ""

    # ── Step 6: Generate startup script and create VM ──
    log_info "Step 6/6: Creating Spot VM..."

    # Generate dynamic startup script using Phase 50 library
    local startup_tmp
    startup_tmp=$(mktemp /tmp/startup-XXXXXX.sh)
    generate_startup "$CPU_CORES" "$RAM_GB" "$RESOURCE_PREFIX" "$DISK_SIZE_GB" > "$startup_tmp"
    log_info "  Startup script generated ($startup_tmp)"

    # Use existing shutdown.sh from gcp/
    local shutdown_script="$SCRIPT_DIR/shutdown.sh"
    if [[ ! -f "$shutdown_script" ]]; then
        log_error "Shutdown script not found: $shutdown_script"
        exit 1
    fi

    create_vm "$vm_name" "$zone" "$machine_type" "$static_ip" "$disk_name" \
        "$startup_tmp" "$shutdown_script" "$RESOURCE_PREFIX"

    # Clean up temp file
    rm -f "$startup_tmp"
    echo ""

    # ── Summary ──
    log_info "=========================================="
    log_info "  Deployment Complete!"
    log_info "=========================================="
    echo ""
    log_info "VM Name:     $vm_name"
    log_info "Zone:        $zone"
    log_info "Machine:     $machine_type"
    log_info "Static IP:   $static_ip"
    log_info "Access:      http://$static_ip"
    echo ""
    log_info "The VM is starting up (2-3 minutes for Docker + containers)."
    log_info "Monitor progress:"
    log_info "  gcloud compute ssh $vm_name --zone=$zone --command='tail -f /var/log/startup-script.log'"
    echo ""
    log_info "Lifecycle commands:"
    log_info "  Status:  ./status-vm.sh"
    log_info "  SSH:     ./ssh-vm.sh"
    log_info "  Logs:    ./logs-vm.sh"
    log_info "  Stop:    ./stop-vm.sh"
    log_info "  Start:   ./start-vm.sh"
    log_info "  Delete:  ./delete-vm.sh"
    echo ""
}

main "$@"
```

**Important details:**
- NO interactive prompts anywhere (DEP-01, RPL-02)
- NO DNS checks or domain requirements (RPL-03) -- HTTP-only deployment
- NO HTTPS/Caddy references
- ALL gcloud create commands go through execute() wrapper from infra.sh (DEP-09 dry-run)
- select_machine() calls Phase 50 Python which calls Phase 49 Python for pricing
- generate_startup() calls Phase 50 Python for dynamic startup script generation
- Cleanup trap registered before main() so any failure triggers cleanup_on_failure()
- DRY_RUN mode: All execute() calls echo instead of run, but existence checks still execute
- Temp startup script created with mktemp, cleaned up after VM creation
- chmod +x the file after creation

**Do NOT create any tests for this script** -- it's pure infrastructure glue code that requires GCP credentials to test. Verification is via syntax check and grep patterns.
  </action>
  <verify>
Run: `bash -n gcp/deploy-auto.sh` to verify syntax.
Run: `test -x gcp/deploy-auto.sh && echo "executable" || echo "not executable"` to verify permissions.
Run: `grep -c 'source.*lib/' gcp/deploy-auto.sh` should return 4 (config.sh, pricing.sh, machine.sh, infra.sh).
Run: `grep -c 'log_info\|log_warn\|log_error' gcp/deploy-auto.sh` should be many (timestamped progress).
Run: `grep 'read\|prompt\|INPUT\|DOMAIN\|DNS\|dns\|domain\|Caddy\|caddy\|443\|https' gcp/deploy-auto.sh` should return nothing (no interactive prompts, no DNS, no HTTPS).
Run: `grep 'DRY_RUN\|dry-run\|dry_run' gcp/deploy-auto.sh` should find dry-run support.
Run: `grep 'trap.*cleanup' gcp/deploy-auto.sh` should find cleanup trap registration.
  </verify>
  <done>
gcp/deploy-auto.sh is an executable script that deploys end-to-end with zero prompts by sourcing all 4 Phase 49-51 libraries. Supports --dry-run flag. Registers cleanup trap. Displays cost estimate before VM creation. Shows timestamped progress for all 6 steps. No interactive prompts, no DNS, no HTTPS. Replaces v2.6 deploy-vm.sh.
  </done>
</task>

</tasks>

<verification>
1. `bash -n gcp/deploy-auto.sh` exits 0 (valid syntax)
2. Script is executable (chmod +x)
3. Sources all 4 libraries (config.sh, pricing.sh, machine.sh, infra.sh)
4. No interactive prompts (no `read`, no `INPUT`, no `DOMAIN`)
5. No DNS checks or domain requirements
6. No HTTPS/443/Caddy references
7. --dry-run flag support present
8. Cleanup trap registered
9. Cost estimate displayed (display_cost_estimate call)
10. Timestamped feedback throughout (log_info calls)
11. Pipeline: config -> auth -> machine -> cost -> infra -> VM
</verification>

<success_criteria>
- Single command `./deploy-auto.sh` deploys end-to-end with zero prompts (DEP-01, RPL-02)
- `./deploy-auto.sh --dry-run` shows all planned actions without executing (DEP-09)
- All gcloud commands use --quiet (DEP-02)
- Infrastructure operations are idempotent via infra.sh functions (DEP-03)
- VM created as Spot instance with correct machine type (DEP-04)
- Dynamic startup script from generate_startup() (DEP-05)
- Cost estimate displayed before VM creation (PRC-05)
- Timestamped progress feedback (DEP-07)
- Failed deployment triggers cleanup (DEP-08)
- Replaces deploy-vm.sh (RPL-01)
- No DNS/domain/HTTPS references (RPL-03)
</success_criteria>

<output>
After completion, create `.planning/phases/51-deployment-orchestration/51-02-SUMMARY.md`
</output>
