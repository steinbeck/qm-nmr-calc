---
phase: 02-input-and-api
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - src/qm_nmr_calc/validation.py
  - src/qm_nmr_calc/api/__init__.py
  - src/qm_nmr_calc/api/schemas.py
autonomous: true

must_haves:
  truths:
    - "RDKit validates SMILES strings and returns specific error messages"
    - "RDKit validates MOL/SDF file content and rejects multi-molecule files"
    - "API request/response schemas match existing JobStatus model structure"
  artifacts:
    - path: "src/qm_nmr_calc/validation.py"
      provides: "SMILES and MOL/SDF validation functions"
      exports: ["validate_smiles", "validate_mol_file"]
    - path: "src/qm_nmr_calc/api/schemas.py"
      provides: "Pydantic models for API requests and responses"
      exports: ["JobSubmitRequest", "JobStatusResponse", "ProblemDetail"]
  key_links:
    - from: "src/qm_nmr_calc/validation.py"
      to: "rdkit.Chem"
      via: "MolFromSmiles, MolFromMolBlock, SDMolSupplier"
      pattern: "Chem\\.MolFrom"
    - from: "src/qm_nmr_calc/api/schemas.py"
      to: "src/qm_nmr_calc/models.py"
      via: "field compatibility with JobStatus"
      pattern: "job_id.*status.*created_at"
---

<objective>
Install FastAPI dependencies, create molecule validation module, and define API schemas.

Purpose: Establish the foundational components for the API layer - validation logic and data contracts. These are independent building blocks that the router tasks will combine.

Output:
- FastAPI + python-multipart + uvicorn installed
- validation.py with validate_smiles() and validate_mol_file()
- api/schemas.py with request/response Pydantic models
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-input-and-api/02-CONTEXT.md
@.planning/phases/02-input-and-api/02-RESEARCH.md

# Existing code to integrate with
@src/qm_nmr_calc/models.py
@src/qm_nmr_calc/storage.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install FastAPI dependencies</name>
  <files>pyproject.toml, uv.lock</files>
  <action>
Install the required dependencies for FastAPI:

```bash
uv add fastapi python-multipart uvicorn
```

Verify the installation:
- fastapi >= 0.115.0
- python-multipart >= 0.0.19 (required for file uploads)
- uvicorn >= 0.34.0

Do NOT start the server yet - just verify imports work:
```python
from fastapi import FastAPI, UploadFile
from starlette import status
import uvicorn
```
  </action>
  <verify>
`uv run python -c "from fastapi import FastAPI, UploadFile; from starlette import status; import uvicorn; print('OK')"` succeeds
  </verify>
  <done>FastAPI and dependencies installed and importable</done>
</task>

<task type="auto">
  <name>Task 2: Create molecule validation module</name>
  <files>src/qm_nmr_calc/validation.py</files>
  <action>
Create `src/qm_nmr_calc/validation.py` with two functions:

**validate_smiles(smiles: str) -> tuple[Chem.Mol | None, str | None]:**
- Use RDKit Chem.MolFromSmiles() to parse
- RDKit returns None for invalid SMILES (doesn't raise exceptions)
- Capture RDKit error messages from stderr for detailed error info
- Return (mol, None) on success, (None, error_message) on failure
- If no stderr captured but mol is None, use generic "Invalid SMILES string"

**validate_mol_file(content: bytes, filename: str) -> tuple[Chem.Mol | None, str | None]:**
- Decode bytes to string (utf-8, replace errors)
- Detect SDF vs MOL by checking for '$$$$' delimiter in content
- For SDF: Use Chem.SDMolSupplier to iterate molecules
  - Reject if 0 valid molecules: "No valid molecules found in SDF file"
  - Reject if >1 valid molecules: "SDF file contains N molecules. Only single-molecule files are accepted."
- For MOL: Use Chem.MolFromMolBlock()
  - Reject if None: "Invalid MOL file format"
- Return (mol, None) on success, (None, error_message) on failure

Use the pattern from 02-RESEARCH.md for stderr capture.
  </action>
  <verify>
```bash
uv run python -c "
from qm_nmr_calc.validation import validate_smiles, validate_mol_file

# Test valid SMILES
mol, err = validate_smiles('CCO')
assert mol is not None, 'Valid SMILES failed'
assert err is None

# Test invalid SMILES
mol, err = validate_smiles('not-a-smiles')
assert mol is None, 'Invalid SMILES should return None'
assert err is not None, 'Should have error message'

print('Validation module OK')
"
```
  </verify>
  <done>validate_smiles and validate_mol_file functions return (mol, None) or (None, error_msg)</done>
</task>

<task type="auto">
  <name>Task 3: Create API schemas</name>
  <files>src/qm_nmr_calc/api/__init__.py, src/qm_nmr_calc/api/schemas.py</files>
  <action>
Create the api package and schemas:

**src/qm_nmr_calc/api/__init__.py:**
```python
"""FastAPI application and schemas for QM NMR Calculator."""
```

**src/qm_nmr_calc/api/schemas.py:**
Create Pydantic models matching the API contract from RESEARCH.md:

**JobSubmitRequest:**
- smiles: str (required) - SMILES string
- name: Optional[str] = None - User label, max_length=100
- Add Field() with description and examples for OpenAPI docs

**JobStatusResponse:**
- Must be compatible with existing JobStatus model fields:
  - job_id: str
  - status: str (queued/running/complete/failed)
  - created_at: str (ISO 8601)
  - started_at: Optional[str]
  - completed_at: Optional[str]
  - input_smiles: str (flatten from JobStatus.input.smiles for simpler API response)
  - input_name: Optional[str] (optional molecule name, NEW - add to models.py too)
  - error_message: Optional[str]
- Use Field() with descriptions for OpenAPI

**ProblemDetail:**
- RFC 7807 error response format
- type: str = "about:blank"
- title: str
- status: int
- detail: Optional[str] = None
- instance: Optional[str] = None

**IMPORTANT:** Also update models.py to add `name` field to JobInput:
```python
class JobInput(BaseModel):
    smiles: str
    name: Optional[str] = None  # Add this
```

And update storage.py create_job_directory() to accept name parameter:
```python
def create_job_directory(
    smiles: str,
    isicle_version: str,
    nwchem_version: str,
    name: Optional[str] = None,  # Add this
) -> JobStatus:
    # ...
    input=JobInput(smiles=smiles, name=name),  # Update this
```
  </action>
  <verify>
```bash
uv run python -c "
from qm_nmr_calc.api.schemas import JobSubmitRequest, JobStatusResponse, ProblemDetail
from qm_nmr_calc.models import JobInput

# Test schemas are valid Pydantic models
req = JobSubmitRequest(smiles='CCO', name='Ethanol')
assert req.smiles == 'CCO'
assert req.name == 'Ethanol'

# Test JobInput has name field
inp = JobInput(smiles='CCO', name='Test')
assert inp.name == 'Test'

print('Schemas OK')
"
```
  </verify>
  <done>JobSubmitRequest, JobStatusResponse, ProblemDetail schemas defined; JobInput model updated with name field</done>
</task>

</tasks>

<verification>
All tasks complete when:
1. `uv run python -c "from fastapi import FastAPI"` succeeds
2. `uv run python -c "from qm_nmr_calc.validation import validate_smiles, validate_mol_file"` succeeds
3. `uv run python -c "from qm_nmr_calc.api.schemas import JobSubmitRequest, JobStatusResponse, ProblemDetail"` succeeds
4. Invalid SMILES returns (None, error_message)
5. Valid SMILES returns (mol, None)
</verification>

<success_criteria>
- FastAPI, python-multipart, uvicorn installed
- validation.py provides SMILES and MOL/SDF validation with specific error messages
- api/schemas.py provides request/response models with OpenAPI documentation
- JobInput model extended with optional name field
- All imports work correctly
</success_criteria>

<output>
After completion, create `.planning/phases/02-input-and-api/02-01-SUMMARY.md`
</output>
