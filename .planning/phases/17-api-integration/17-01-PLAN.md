---
phase: 17-api-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/qm_nmr_calc/tasks.py
  - src/qm_nmr_calc/api/routers/jobs.py
  - src/qm_nmr_calc/api/routers/web.py
  - src/qm_nmr_calc/storage.py
  - src/qm_nmr_calc/nwchem/runner.py
  - tests/test_tasks.py
autonomous: true

must_haves:
  truths:
    - "Job submission with conformer_mode='ensemble' executes run_ensemble_nmr_task"
    - "Job submission with conformer_mode='single' executes run_nmr_task (v1.x behavior)"
    - "Ensemble task generates conformers, runs DFT+NMR, and produces Boltzmann-averaged shifts"
    - "CREST method requested but unavailable falls back to RDKit with warning in job metadata"
    - "Job status shows progress during conformer processing (X/N counts)"
  artifacts:
    - path: "src/qm_nmr_calc/tasks.py"
      provides: "run_ensemble_nmr_task function"
      contains: "def run_ensemble_nmr_task"
    - path: "src/qm_nmr_calc/api/routers/jobs.py"
      provides: "Mode-aware task dispatch in submit_smiles"
      contains: "run_ensemble_nmr_task"
    - path: "src/qm_nmr_calc/storage.py"
      provides: "create_job_directory with conformer parameters"
      contains: "conformer_mode"
    - path: "src/qm_nmr_calc/nwchem/runner.py"
      provides: "run_ensemble_dft_and_nmr with progress_callback"
      contains: "progress_callback"
  key_links:
    - from: "src/qm_nmr_calc/api/routers/jobs.py"
      to: "src/qm_nmr_calc/tasks.py"
      via: "run_ensemble_nmr_task import and dispatch"
      pattern: "run_ensemble_nmr_task\\(job_status\\.job_id\\)"
    - from: "src/qm_nmr_calc/tasks.py"
      to: "src/qm_nmr_calc/conformers/pipeline.py"
      via: "generate_conformer_ensemble call"
      pattern: "generate_conformer_ensemble\\("
    - from: "src/qm_nmr_calc/tasks.py"
      to: "src/qm_nmr_calc/nwchem/runner.py"
      via: "run_ensemble_dft_and_nmr call with progress_callback"
      pattern: "run_ensemble_dft_and_nmr\\("
---

<objective>
Create the ensemble Huey task and wire it to API submission endpoints with mode-based dispatch.

Purpose: This is the core integration that connects the v2.0 computational pipeline (phases 12-16) to user-facing endpoints. Without this, ensemble calculations cannot be triggered.

Output: Working `run_ensemble_nmr_task` that generates conformers, runs DFT+NMR, computes Boltzmann averages, and saves results. API endpoints dispatch to the correct task based on conformer_mode. Job status updates with X/N progress during conformer processing.
</objective>

<execution_context>
@/home/chris/.claude/get-shit-done/workflows/execute-plan.md
@/home/chris/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-api-integration/17-CONTEXT.md
@.planning/phases/17-api-integration/17-RESEARCH.md
@.planning/phases/15-multi-conformer-nwchem-integration/15-03-SUMMARY.md
@.planning/phases/16-crest-integration/16-03-SUMMARY.md

# Key source files
@src/qm_nmr_calc/tasks.py
@src/qm_nmr_calc/api/routers/jobs.py
@src/qm_nmr_calc/storage.py
@src/qm_nmr_calc/nwchem/runner.py
@src/qm_nmr_calc/conformers/pipeline.py
@src/qm_nmr_calc/conformers/boltzmann.py
@src/qm_nmr_calc/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create run_ensemble_nmr_task and update storage/runner</name>
  <files>
    src/qm_nmr_calc/tasks.py
    src/qm_nmr_calc/storage.py
    src/qm_nmr_calc/nwchem/runner.py
  </files>
  <action>
Create `run_ensemble_nmr_task` in tasks.py following the pattern from 17-RESEARCH.md:

1. **Update storage.py** - Extend `create_job_directory()` to accept and store:
   - `conformer_mode: str = "single"` (default for backward compatibility)
   - `conformer_method: Optional[str] = None`
   - `max_conformers: Optional[int] = None`
   - Store these in JobInput and persist to status.json
   - Also add `conformer_method_warning: Optional[str] = None` to JobStatus for CREST fallback warning

2. **Update runner.py** - Add progress_callback to `run_ensemble_dft_and_nmr`:
   ```python
   def run_ensemble_dft_and_nmr(
       ensemble,
       job_id: str,
       preset: dict,
       solvent: str,
       processes: int = 4,
       progress_callback: callable = None,  # NEW: Called with (step, current, total)
   ) -> tuple:
   ```

   Inside `run_conformer_dft_optimization`, after each conformer completes (success or fail):
   ```python
   if progress_callback:
       progress_callback("optimizing_conformers", len(successful) + len(failed), len(ensemble.conformers))
   ```

   Inside `run_conformer_nmr_calculations`, after each conformer completes:
   ```python
   if progress_callback:
       progress_callback("calculating_nmr", len(nmr_results) + len(failed), len(optimized_conformers))
   ```

   Pass callback through to both helper functions.

3. **Create run_ensemble_nmr_task in tasks.py:**

```python
@huey.task()
def run_ensemble_nmr_task(job_id: str) -> dict:
    """Execute ensemble NMR calculation (conformer generation + DFT + NMR + Boltzmann)."""
    job_status = load_job_status(job_id)
    if job_status is None:
        raise ValueError(f"Job {job_id} not found")

    if job_status.status not in ('queued', 'running'):
        raise ValueError(f"Job {job_id} is not ready to run")

    preset = PRESETS[PresetName(job_status.input.preset)]
    solvent = job_status.input.solvent
    job_dir = get_job_dir(job_id)

    # Determine conformer method (default to rdkit_kdg)
    conformer_method = job_status.input.conformer_method or "rdkit_kdg"

    # Step 1: Generate conformer ensemble
    start_step(job_id, "generating_conformers", "Generating conformers")
    try:
        ensemble = generate_conformer_ensemble(
            smiles=job_status.input.smiles,
            job_id=job_id,
            conformer_method=conformer_method,
            solvent=solvent,
            max_conformers=job_status.input.max_conformers,
        )
    except ValueError as e:
        # CREST unavailable or unsupported solvent - fall back to RDKit with warning
        if "CREST" in str(e) and conformer_method == "crest":
            warning_msg = str(e) + " Falling back to RDKit KDG method."
            update_job_status(job_id, conformer_method_warning=warning_msg)
            ensemble = generate_conformer_ensemble(
                smiles=job_status.input.smiles,
                job_id=job_id,
                conformer_method="rdkit_kdg",
                solvent=solvent,
                max_conformers=job_status.input.max_conformers,
            )
        else:
            raise

    update_job_status(job_id, conformer_ensemble=ensemble)

    # Progress callback to update job status with X/N counts
    def on_progress(step: str, current: int, total: int):
        """Update job status with progress during conformer processing."""
        start_step(job_id, step, f"{step.replace('_', ' ').title()} ({current}/{total})")

    # Step 2-4: DFT optimization + Post-DFT filter + NMR calculations
    start_step(job_id, "optimizing_conformers", f"Optimizing conformers (0/{len(ensemble.conformers)})")
    ensemble, nmr_results = run_ensemble_dft_and_nmr(
        ensemble=ensemble,
        job_id=job_id,
        preset=preset,
        solvent=solvent,
        processes=preset['processes'],
        progress_callback=on_progress,
    )

    # Step 5: Boltzmann averaging
    # CRITICAL: Filter to only nmr_complete conformers before averaging
    start_step(job_id, "averaging_shifts", "Computing Boltzmann average")
    nmr_complete_conformers = [c for c in ensemble.conformers if c.status == "nmr_complete"]

    if not nmr_complete_conformers:
        raise RuntimeError("No conformers completed NMR calculation successfully")

    # Create filtered ensemble for averaging (same count as nmr_results)
    filtered_ensemble = ensemble.model_copy(update={"conformers": nmr_complete_conformers})
    avg_nmr = average_ensemble_nmr(filtered_ensemble, nmr_results)

    # Step 6: Post-processing (visualizations)
    start_step(job_id, "post_processing", "Generating results")
    output_dir = job_dir / 'output'

    # Generate spectrum plots using averaged shifts
    generate_spectrum_plot(
        shifts=[s.shift for s in avg_nmr.h1_shifts],
        nucleus="1H",
        output_dir=output_dir,
    )
    generate_spectrum_plot(
        shifts=[s.shift for s in avg_nmr.c13_shifts],
        nucleus="13C",
        output_dir=output_dir,
    )

    # Generate annotated structure using averaged shifts
    generate_annotated_structure(
        smiles=job_status.input.smiles,
        h1_shifts=[{"index": s.index, "shift": s.shift} for s in avg_nmr.h1_shifts],
        c13_shifts=[{"index": s.index, "shift": s.shift} for s in avg_nmr.c13_shifts],
        output_dir=output_dir,
    )

    complete_current_step(job_id)

    # Update job status with averaged NMR results and full ensemble data
    update_job_status(
        job_id,
        nmr_results=avg_nmr,
        conformer_ensemble=ensemble,  # Full ensemble with all conformers and their statuses
    )

    return {
        'success': True,
        'job_id': job_id,
    }
```

4. **Add imports** at top of tasks.py:
   - `from .conformers.pipeline import generate_conformer_ensemble`
   - `from .conformers.boltzmann import average_ensemble_nmr`
   - `from .nwchem.runner import run_ensemble_dft_and_nmr`

**CRITICAL:** The `average_ensemble_nmr()` function requires len(conformers) == len(nmr_results). The filtered_ensemble.conformers MUST only contain nmr_complete conformers.
  </action>
  <verify>
```bash
cd /home/chris/develop/qm-nmr-calc
python -c "from qm_nmr_calc.tasks import run_ensemble_nmr_task; print('Import OK')"
python -c "from qm_nmr_calc.storage import create_job_directory; import inspect; sig = inspect.signature(create_job_directory); print('conformer_mode' in str(sig))"
python -c "from qm_nmr_calc.nwchem.runner import run_ensemble_dft_and_nmr; import inspect; sig = inspect.signature(run_ensemble_dft_and_nmr); print('progress_callback' in str(sig))"
```
  </verify>
  <done>run_ensemble_nmr_task function exists and imports correctly. create_job_directory accepts conformer_mode, conformer_method, max_conformers parameters. run_ensemble_dft_and_nmr accepts progress_callback parameter.</done>
</task>

<task type="auto">
  <name>Task 2: Wire API endpoints for mode-aware dispatch</name>
  <files>
    src/qm_nmr_calc/api/routers/jobs.py
    src/qm_nmr_calc/api/routers/web.py
  </files>
  <action>
1. **Update jobs.py submit_smiles endpoint:**
   - Import `run_ensemble_nmr_task` from tasks
   - Pass conformer params to create_job_directory:
     ```python
     job_status = create_job_directory(
         smiles=request.smiles,
         solvent=normalized_solvent,
         nwchem_version=nwchem_version,
         name=request.name,
         preset=request.preset,
         notification_email=request.notification_email,
         conformer_mode=request.conformer_mode,
         conformer_method=request.conformer_method,
         max_conformers=request.max_conformers,
     )
     ```
   - Dispatch based on mode:
     ```python
     if job_status.input.conformer_mode == "ensemble":
         run_ensemble_nmr_task(job_status.job_id)
     else:
         run_nmr_task(job_status.job_id)
     ```

2. **Update jobs.py submit_file endpoint** with same pattern (mode-aware dispatch)

3. **Update web.py submit_job endpoint:**
   - Accept new form parameters: `conformer_mode`, `conformer_method`
   - Default conformer_mode to "ensemble" per CONTEXT.md decision
   - Pass to create_job_directory
   - Dispatch based on mode

Note: Do NOT change JobSubmitRequest schema in this task - that already has the fields from Phase 12.
  </action>
  <verify>
```bash
cd /home/chris/develop/qm-nmr-calc
grep -n "run_ensemble_nmr_task" src/qm_nmr_calc/api/routers/jobs.py
grep -n "conformer_mode" src/qm_nmr_calc/api/routers/jobs.py
grep -n "conformer_mode" src/qm_nmr_calc/api/routers/web.py
```
  </verify>
  <done>Both API and web endpoints pass conformer params to create_job_directory and dispatch to correct task based on conformer_mode.</done>
</task>

<task type="auto">
  <name>Task 3: Add tests for ensemble task dispatch</name>
  <files>
    tests/test_tasks.py
  </files>
  <action>
Add tests for the new ensemble task and dispatch logic. Create new test file or extend existing:

```python
import pytest
from unittest.mock import patch, MagicMock

class TestEnsembleTaskDispatch:
    """Tests for ensemble task and mode-based dispatch."""

    def test_run_ensemble_nmr_task_imports(self):
        """Verify run_ensemble_nmr_task can be imported."""
        from qm_nmr_calc.tasks import run_ensemble_nmr_task
        assert callable(run_ensemble_nmr_task)

    @patch('qm_nmr_calc.tasks.generate_conformer_ensemble')
    @patch('qm_nmr_calc.tasks.run_ensemble_dft_and_nmr')
    @patch('qm_nmr_calc.tasks.average_ensemble_nmr')
    @patch('qm_nmr_calc.tasks.load_job_status')
    @patch('qm_nmr_calc.tasks.update_job_status')
    @patch('qm_nmr_calc.tasks.start_step')
    @patch('qm_nmr_calc.tasks.complete_current_step')
    @patch('qm_nmr_calc.tasks.get_job_dir')
    @patch('qm_nmr_calc.tasks.generate_spectrum_plot')
    @patch('qm_nmr_calc.tasks.generate_annotated_structure')
    def test_ensemble_task_filters_nmr_complete_conformers(
        self, mock_annotate, mock_spectrum, mock_get_job_dir, mock_complete, mock_start, mock_update,
        mock_load, mock_avg, mock_dft, mock_gen
    ):
        """Verify ensemble task filters to nmr_complete conformers before averaging."""
        from qm_nmr_calc.tasks import run_ensemble_nmr_task
        from qm_nmr_calc.models import ConformerEnsemble, ConformerData, NMRResults, AtomShift

        # Setup mock job status
        mock_job = MagicMock()
        mock_job.status = 'queued'
        mock_job.input.smiles = 'CCO'
        mock_job.input.solvent = 'chcl3'
        mock_job.input.preset = 'production'
        mock_job.input.conformer_method = 'rdkit_kdg'
        mock_job.input.max_conformers = None
        mock_load.return_value = mock_job
        mock_get_job_dir.return_value = MagicMock()

        # Setup ensemble with mixed statuses
        conformers = [
            ConformerData(conformer_id="conf_001", status="nmr_complete", energy=-100.0, energy_unit="hartree"),
            ConformerData(conformer_id="conf_002", status="failed"),
            ConformerData(conformer_id="conf_003", status="nmr_complete", energy=-99.5, energy_unit="hartree"),
        ]
        ensemble = ConformerEnsemble(method="rdkit_kdg", conformers=conformers)
        mock_gen.return_value = ensemble

        # NMR results only for nmr_complete (2 results)
        nmr1 = NMRResults(h1_shifts=[], c13_shifts=[], functional="b3lyp", basis_set="6-311+g(2d,p)", solvent="chcl3")
        nmr2 = NMRResults(h1_shifts=[], c13_shifts=[], functional="b3lyp", basis_set="6-311+g(2d,p)", solvent="chcl3")
        mock_dft.return_value = (ensemble, [nmr1, nmr2])

        # Mock avg_nmr return
        mock_avg.return_value = NMRResults(h1_shifts=[], c13_shifts=[], functional="b3lyp", basis_set="6-311+g(2d,p)", solvent="chcl3")

        # Run task
        run_ensemble_nmr_task("test_job_id")

        # Verify average_ensemble_nmr was called with filtered ensemble (2 conformers, not 3)
        mock_avg.assert_called_once()
        filtered_ensemble = mock_avg.call_args[0][0]
        assert len(filtered_ensemble.conformers) == 2
        assert all(c.status == "nmr_complete" for c in filtered_ensemble.conformers)

    def test_progress_callback_passed_to_runner(self):
        """Test that progress_callback is passed to run_ensemble_dft_and_nmr."""
        from qm_nmr_calc.nwchem.runner import run_ensemble_dft_and_nmr
        import inspect
        sig = inspect.signature(run_ensemble_dft_and_nmr)
        assert 'progress_callback' in sig.parameters

    def test_crest_fallback_warning(self):
        """Test CREST unavailable falls back to RDKit with warning."""
        # This is an integration test - may need NWChem mocking
        pass  # TODO: Implement with full mocking
```

Run tests to verify:
```bash
pytest tests/test_tasks.py -v -k "ensemble"
```
  </action>
  <verify>
```bash
cd /home/chris/develop/qm-nmr-calc
pytest tests/test_tasks.py -v -k "ensemble" --tb=short
```
  </verify>
  <done>Tests pass confirming ensemble task filters to nmr_complete conformers, progress_callback is accepted, and dispatches correctly.</done>
</task>

</tasks>

<verification>
1. Import check: `python -c "from qm_nmr_calc.tasks import run_ensemble_nmr_task"`
2. API dispatch: `grep -n "run_ensemble_nmr_task" src/qm_nmr_calc/api/routers/jobs.py` shows import and dispatch
3. Storage params: `grep -n "conformer_mode" src/qm_nmr_calc/storage.py` shows parameter handling
4. Progress callback: `grep -n "progress_callback" src/qm_nmr_calc/nwchem/runner.py` shows parameter in signature
5. Tests pass: `pytest tests/test_tasks.py -v -k "ensemble"`
6. Existing tests still pass: `pytest tests/ -v --ignore=tests/test_nwchem_integration.py`
</verification>

<success_criteria>
- [ ] run_ensemble_nmr_task exists and can be imported
- [ ] run_ensemble_nmr_task generates conformers using pipeline
- [ ] run_ensemble_nmr_task runs DFT+NMR using run_ensemble_dft_and_nmr
- [ ] run_ensemble_nmr_task filters to nmr_complete before Boltzmann averaging
- [ ] run_ensemble_nmr_task handles CREST fallback with warning
- [ ] run_ensemble_nmr_task reports progress via callback (X/N counts)
- [ ] run_ensemble_dft_and_nmr accepts progress_callback parameter
- [ ] API submit_smiles dispatches to correct task based on conformer_mode
- [ ] Web submit_job dispatches to correct task based on conformer_mode
- [ ] create_job_directory accepts and stores conformer parameters
- [ ] Visualizations generated using generate_spectrum_plot and generate_annotated_structure
- [ ] New tests pass
- [ ] Existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/17-api-integration/17-01-SUMMARY.md`
</output>
