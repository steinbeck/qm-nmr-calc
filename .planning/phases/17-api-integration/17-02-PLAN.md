---
phase: 17-api-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/qm_nmr_calc/api/schemas.py
  - src/qm_nmr_calc/api/routers/jobs.py
  - tests/test_api.py
autonomous: true

must_haves:
  truths:
    - "JobStatusResponse includes ensemble metadata when conformer_mode=ensemble"
    - "JobStatusResponse includes per-conformer status array for progress tracking"
    - "NMRResultsResponse includes ensemble metadata (conformer count, energy range, populations)"
    - "API response includes conformer_method_warning when CREST fallback occurred"
  artifacts:
    - path: "src/qm_nmr_calc/api/schemas.py"
      provides: "Extended JobStatusResponse with ensemble fields"
      contains: "conformer_count"
    - path: "src/qm_nmr_calc/api/schemas.py"
      provides: "EnsembleMetadataResponse model"
      contains: "class EnsembleMetadataResponse"
    - path: "src/qm_nmr_calc/api/routers/jobs.py"
      provides: "job_status_to_response builds ensemble metadata"
      contains: "conformer_progress"
  key_links:
    - from: "src/qm_nmr_calc/api/routers/jobs.py"
      to: "src/qm_nmr_calc/api/schemas.py"
      via: "EnsembleMetadataResponse usage"
      pattern: "EnsembleMetadataResponse"
---

<objective>
Extend API schemas to include ensemble metadata and per-conformer progress tracking in responses.

Purpose: Users need to see ensemble-specific information (conformer count, method, progress, populations) in API responses for progress tracking and result interpretation.

Output: Extended JobStatusResponse with ensemble fields and new EnsembleMetadataResponse for result metadata.
</objective>

<execution_context>
@/home/chris/.claude/get-shit-done/workflows/execute-plan.md
@/home/chris/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-api-integration/17-CONTEXT.md
@.planning/phases/17-api-integration/17-RESEARCH.md

# Key source files
@src/qm_nmr_calc/api/schemas.py
@src/qm_nmr_calc/api/routers/jobs.py
@src/qm_nmr_calc/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend schemas for ensemble metadata</name>
  <files>
    src/qm_nmr_calc/api/schemas.py
  </files>
  <action>
Add new models and extend existing ones for ensemble support:

1. **Add ConformerProgressResponse model:**
```python
class ConformerProgressResponse(BaseModel):
    """Progress status for a single conformer."""
    conformer_id: str = Field(..., description="Conformer identifier (e.g., conf_001)")
    status: str = Field(..., description="Status: pending, optimizing, optimized, nmr_running, nmr_complete, failed")
    energy_kcal: Optional[float] = Field(None, description="Relative energy in kcal/mol (after DFT)")
    population: Optional[float] = Field(None, description="Boltzmann population (0-1, after averaging)")
```

2. **Add EnsembleMetadataResponse model:**
```python
class EnsembleMetadataResponse(BaseModel):
    """Ensemble metadata included in completed job results."""
    conformer_count: int = Field(..., description="Number of conformers used in averaging")
    total_generated: int = Field(..., description="Total conformers generated before filtering")
    method: str = Field(..., description="Conformer generation method: rdkit_kdg or crest")
    temperature_k: float = Field(default=298.15, description="Temperature for Boltzmann weighting")
    energy_range_kcal: float = Field(..., description="Energy range of used conformers in kcal/mol")
    top_populations: list[dict] = Field(
        ...,
        description="Top 3 conformers by population: [{id, population, energy_kcal}]"
    )
    conformer_method_warning: Optional[str] = Field(
        None,
        description="Warning message if CREST fell back to RDKit"
    )
```

3. **Extend JobStatusResponse with ensemble fields:**
```python
class JobStatusResponse(BaseModel):
    # ... existing fields ...
    conformer_mode: str = Field(
        default="single",
        description="Conformational sampling mode: 'single' or 'ensemble'",
    )
    # Ensemble-specific fields (only populated when mode="ensemble")
    conformer_method: Optional[str] = Field(
        None,
        description="Conformer generation method: 'rdkit_kdg' or 'crest'"
    )
    conformer_count: Optional[int] = Field(
        None,
        description="Number of conformers (only for ensemble mode)"
    )
    conformer_progress: Optional[list[ConformerProgressResponse]] = Field(
        None,
        description="Per-conformer status array for progress tracking"
    )
    eta_seconds: Optional[int] = Field(
        None,
        description="Estimated time remaining in seconds"
    )
    conformer_method_warning: Optional[str] = Field(
        None,
        description="Warning if CREST fell back to RDKit"
    )
    ensemble_metadata: Optional[EnsembleMetadataResponse] = Field(
        None,
        description="Ensemble metadata (only for completed ensemble jobs)"
    )
```

4. **Extend NMRResultsResponse with ensemble_metadata field:**
```python
class NMRResultsResponse(BaseModel):
    # ... existing fields ...
    ensemble_metadata: Optional[EnsembleMetadataResponse] = Field(
        None,
        description="Ensemble metadata (only for ensemble mode results)"
    )
```
  </action>
  <verify>
```bash
cd /home/chris/develop/qm-nmr-calc
python -c "from qm_nmr_calc.api.schemas import JobStatusResponse, EnsembleMetadataResponse, ConformerProgressResponse; print('Schema imports OK')"
python -c "from qm_nmr_calc.api.schemas import JobStatusResponse; print([f for f in JobStatusResponse.model_fields if 'conformer' in f])"
```
  </verify>
  <done>New schema models exist and JobStatusResponse has ensemble-specific fields.</done>
</task>

<task type="auto">
  <name>Task 2: Update job_status_to_response for ensemble data</name>
  <files>
    src/qm_nmr_calc/api/routers/jobs.py
  </files>
  <action>
Update `job_status_to_response()` function to populate ensemble fields:

```python
def job_status_to_response(job_status: JobStatus) -> dict:
    """Convert JobStatus model to JobStatusResponse dict."""
    # ... existing code for nmr_results and steps_completed ...

    # Build ensemble-specific fields
    conformer_method = None
    conformer_count = None
    conformer_progress = None
    ensemble_metadata = None
    conformer_method_warning = getattr(job_status, 'conformer_method_warning', None)

    if job_status.conformer_mode == "ensemble" and job_status.conformer_ensemble:
        ensemble = job_status.conformer_ensemble
        conformer_method = ensemble.method
        conformer_count = len(ensemble.conformers)

        # Build per-conformer progress array
        # Convert energies to kcal/mol relative for display
        from ..conformers.boltzmann import HARTREE_TO_KCAL
        min_energy = None
        for c in ensemble.conformers:
            if c.energy is not None and c.status in ("optimized", "nmr_complete"):
                if min_energy is None or c.energy < min_energy:
                    min_energy = c.energy

        conformer_progress = []
        for c in ensemble.conformers:
            energy_kcal = None
            if c.energy is not None and min_energy is not None:
                if c.energy_unit == "hartree":
                    energy_kcal = (c.energy - min_energy) * HARTREE_TO_KCAL
                else:
                    energy_kcal = c.energy - min_energy  # Already in kcal/mol

            conformer_progress.append({
                "conformer_id": c.conformer_id,
                "status": c.status,
                "energy_kcal": round(energy_kcal, 2) if energy_kcal is not None else None,
                "population": round(c.weight, 4) if c.weight is not None else None,
            })

        # Build ensemble metadata for completed jobs
        if job_status.status == "complete":
            nmr_complete = [c for c in ensemble.conformers if c.status == "nmr_complete"]
            if nmr_complete:
                # Calculate energy range
                energies_kcal = []
                for c in nmr_complete:
                    if c.energy is not None and min_energy is not None:
                        if c.energy_unit == "hartree":
                            energies_kcal.append((c.energy - min_energy) * HARTREE_TO_KCAL)
                        else:
                            energies_kcal.append(c.energy - min_energy)

                energy_range = max(energies_kcal) - min(energies_kcal) if energies_kcal else 0.0

                # Get top 3 by population
                sorted_by_pop = sorted(
                    [c for c in nmr_complete if c.weight is not None],
                    key=lambda x: x.weight,
                    reverse=True
                )[:3]

                top_populations = []
                for c in sorted_by_pop:
                    e_kcal = None
                    if c.energy is not None and min_energy is not None:
                        if c.energy_unit == "hartree":
                            e_kcal = (c.energy - min_energy) * HARTREE_TO_KCAL
                        else:
                            e_kcal = c.energy - min_energy
                    top_populations.append({
                        "id": c.conformer_id,
                        "population": round(c.weight, 4),
                        "energy_kcal": round(e_kcal, 2) if e_kcal is not None else None,
                    })

                ensemble_metadata = {
                    "conformer_count": len(nmr_complete),
                    "total_generated": ensemble.total_generated,
                    "method": ensemble.method,
                    "temperature_k": ensemble.temperature_k,
                    "energy_range_kcal": round(energy_range, 2),
                    "top_populations": top_populations,
                    "conformer_method_warning": conformer_method_warning,
                }

    return {
        # ... existing fields ...
        "conformer_mode": job_status.conformer_mode,
        "conformer_method": conformer_method,
        "conformer_count": conformer_count,
        "conformer_progress": conformer_progress,
        "conformer_method_warning": conformer_method_warning,
        "ensemble_metadata": ensemble_metadata,
        # TODO: eta_seconds - implement in Plan 03
        "eta_seconds": None,
    }
```

Also update `get_nmr_results()` endpoint to include ensemble_metadata in NMRResultsResponse when mode=ensemble.
  </action>
  <verify>
```bash
cd /home/chris/develop/qm-nmr-calc
grep -n "conformer_progress" src/qm_nmr_calc/api/routers/jobs.py
grep -n "ensemble_metadata" src/qm_nmr_calc/api/routers/jobs.py
```
  </verify>
  <done>job_status_to_response populates conformer_progress, ensemble_metadata, and conformer_method_warning fields.</done>
</task>

<task type="auto">
  <name>Task 3: Add schema tests</name>
  <files>
    tests/test_api.py
  </files>
  <action>
Add tests verifying the new schema fields:

```python
class TestEnsembleSchemas:
    """Tests for ensemble API schema extensions."""

    def test_ensemble_metadata_response_model(self):
        """Verify EnsembleMetadataResponse model can be instantiated."""
        from qm_nmr_calc.api.schemas import EnsembleMetadataResponse

        metadata = EnsembleMetadataResponse(
            conformer_count=5,
            total_generated=20,
            method="rdkit_kdg",
            temperature_k=298.15,
            energy_range_kcal=2.5,
            top_populations=[
                {"id": "conf_001", "population": 0.45, "energy_kcal": 0.0},
                {"id": "conf_002", "population": 0.30, "energy_kcal": 0.5},
            ],
        )
        assert metadata.conformer_count == 5
        assert metadata.method == "rdkit_kdg"

    def test_conformer_progress_response_model(self):
        """Verify ConformerProgressResponse model can be instantiated."""
        from qm_nmr_calc.api.schemas import ConformerProgressResponse

        progress = ConformerProgressResponse(
            conformer_id="conf_001",
            status="nmr_complete",
            energy_kcal=0.0,
            population=0.45,
        )
        assert progress.conformer_id == "conf_001"
        assert progress.status == "nmr_complete"

    def test_job_status_response_ensemble_fields(self):
        """Verify JobStatusResponse has ensemble fields."""
        from qm_nmr_calc.api.schemas import JobStatusResponse

        fields = JobStatusResponse.model_fields
        assert "conformer_mode" in fields
        assert "conformer_method" in fields
        assert "conformer_count" in fields
        assert "conformer_progress" in fields
        assert "ensemble_metadata" in fields
        assert "conformer_method_warning" in fields

    def test_nmr_results_response_ensemble_metadata(self):
        """Verify NMRResultsResponse has ensemble_metadata field."""
        from qm_nmr_calc.api.schemas import NMRResultsResponse

        fields = NMRResultsResponse.model_fields
        assert "ensemble_metadata" in fields
```

Run tests:
```bash
pytest tests/test_api.py -v -k "Ensemble" --tb=short
```
  </action>
  <verify>
```bash
cd /home/chris/develop/qm-nmr-calc
pytest tests/test_api.py -v -k "Ensemble" --tb=short
```
  </verify>
  <done>Schema tests pass verifying new ensemble fields exist and can be instantiated.</done>
</task>

</tasks>

<verification>
1. Schema imports: `python -c "from qm_nmr_calc.api.schemas import EnsembleMetadataResponse, ConformerProgressResponse"`
2. Response builder: `grep -n "ensemble_metadata" src/qm_nmr_calc/api/routers/jobs.py`
3. Tests pass: `pytest tests/test_api.py -v -k "Ensemble"`
4. Existing tests: `pytest tests/test_api.py -v --tb=short`
</verification>

<success_criteria>
- [ ] EnsembleMetadataResponse model exists with all required fields
- [ ] ConformerProgressResponse model exists
- [ ] JobStatusResponse includes conformer_mode, conformer_method, conformer_count, conformer_progress, ensemble_metadata
- [ ] NMRResultsResponse includes ensemble_metadata field
- [ ] job_status_to_response builds conformer_progress from ensemble conformers
- [ ] job_status_to_response builds ensemble_metadata for completed ensemble jobs
- [ ] Energy conversion to relative kcal/mol is correct
- [ ] Top 3 populations are sorted correctly
- [ ] Schema tests pass
- [ ] Existing API tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/17-api-integration/17-02-SUMMARY.md`
</output>
