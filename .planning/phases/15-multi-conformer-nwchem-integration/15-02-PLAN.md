---
phase: 15-multi-conformer-nwchem-integration
plan: 02
type: tdd
wave: 2
depends_on: ["15-01"]
files_modified:
  - src/qm_nmr_calc/nwchem/runner.py
  - src/qm_nmr_calc/nwchem/__init__.py
  - tests/test_conformer_nwchem.py
autonomous: true

must_haves:
  truths:
    - "run_calculation() accepts optional scratch_dir_override for per-conformer isolation"
    - "run_conformer_dft_optimization() runs DFT optimization on each conformer sequentially"
    - "run_conformer_dft_optimization() updates ConformerData.status through optimizing -> optimized lifecycle"
    - "run_conformer_dft_optimization() stores DFT energy (Hartree) and energy_unit in ConformerData"
    - "run_conformer_dft_optimization() catches per-conformer failures and continues processing"
    - "run_conformer_dft_optimization() raises RuntimeError when <50% of conformers succeed"
    - "apply_post_dft_filter() filters conformers by DFT energy window using existing filter_by_energy_window"
  artifacts:
    - path: "src/qm_nmr_calc/nwchem/runner.py"
      provides: "run_conformer_dft_optimization and apply_post_dft_filter functions"
      contains: "def run_conformer_dft_optimization"
    - path: "tests/test_conformer_nwchem.py"
      provides: "Unit tests for conformer DFT optimization loop"
      contains: "test_conformer_dft"
  key_links:
    - from: "src/qm_nmr_calc/nwchem/runner.py"
      to: "src/qm_nmr_calc/nwchem/output_parser.py"
      via: "extract_dft_energy for DFT energy extraction"
      pattern: "extract_dft_energy"
    - from: "src/qm_nmr_calc/nwchem/runner.py"
      to: "src/qm_nmr_calc/storage.py"
      via: "get_conformer_scratch_dir for per-conformer isolation"
      pattern: "get_conformer_scratch_dir"
    - from: "src/qm_nmr_calc/nwchem/runner.py"
      to: "src/qm_nmr_calc/conformers/filters.py"
      via: "filter_by_energy_window for post-DFT filtering"
      pattern: "filter_by_energy_window"
---

<objective>
Implement per-conformer DFT optimization loop with partial failure handling and post-DFT energy filtering.

Purpose: The core computational loop of v2.0 -- runs DFT geometry optimization on each conformer from the RDKit ensemble, extracts DFT energies for Boltzmann weighting, handles individual conformer failures gracefully, and applies post-DFT energy window filtering to avoid wasting compute on NMR calculations for high-energy conformers.

Output: `run_conformer_dft_optimization()` and `apply_post_dft_filter()` in runner.py, with comprehensive unit tests using mocks (NWChem not called in tests).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-multi-conformer-nwchem-integration/15-01-SUMMARY.md

@src/qm_nmr_calc/nwchem/runner.py
@src/qm_nmr_calc/nwchem/output_parser.py
@src/qm_nmr_calc/models.py
@src/qm_nmr_calc/storage.py
@src/qm_nmr_calc/conformers/filters.py
@src/qm_nmr_calc/conformers/boltzmann.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write failing tests for conformer DFT optimization loop</name>
  <files>tests/test_conformer_nwchem.py</files>
  <action>
Create new test file `tests/test_conformer_nwchem.py` with these test cases. All tests use `unittest.mock.patch` to mock `run_nwchem` and filesystem operations -- NO actual NWChem calls.

**Fixtures needed (create as helper functions at top of file):**

- `make_ensemble(n=3)`: Creates ConformerEnsemble with `n` conformers, each having conformer_id="conf_001"..., energy (MMFF kcal/mol), energy_unit="kcal_mol", geometry_file="output/conformers/conf_XXX/geometry.xyz", status="pending"
- `make_preset()`: Returns dict `{"functional": "b3lyp", "basis_set": "6-31G*", "nmr_basis_set": "6-311+G(2d,p)", "max_iter": 150}`

**Tests for run_calculation scratch_dir_override:**

1. `test_run_calculation_uses_scratch_dir_override()` - Mock run_nwchem and filesystem. Call run_calculation with scratch_dir_override=some_path. Assert scratch directory used is the override path, NOT the default job_dir/scratch. Verify input files written to override path.

**Tests for run_conformer_dft_optimization:**

2. `test_conformer_dft_optimization_all_succeed()` - Create ensemble with 3 conformers. Mock run_calculation to return success result with optimization output containing "Total DFT energy: -40.5186". After call:
   - Assert returns (successful=[3 items], failed=[])
   - Assert each conformer.status == "optimized"
   - Assert each conformer.energy is float (Hartree)
   - Assert each conformer.energy_unit == "hartree"

3. `test_conformer_dft_optimization_partial_failure()` - Create ensemble with 4 conformers. Mock run_calculation to raise RuntimeError for conformer 2 (0-indexed=1). After call:
   - Assert returns (successful=[3 items], failed=[1 item])
   - Assert failed[0].status == "failed"
   - Assert failed[0].error_message contains description of failure
   - Assert successful conformers have status="optimized"

4. `test_conformer_dft_optimization_too_many_failures()` - Create ensemble with 4 conformers. Mock run_calculation to fail for 3 of 4 (>50% failure). Assert RuntimeError raised with message about insufficient success rate.

5. `test_conformer_dft_optimization_status_tracking()` - Verify status transitions. Mock run_calculation. After processing, all successful conformers should have gone through pending -> optimizing -> optimized. Track by inspecting final states.

6. `test_conformer_dft_optimization_stores_optimized_geometry_path()` - Mock run_calculation to return geometry_file path. After call, assert conformer.optimized_geometry_file is set as relative path from job_dir.

**Tests for apply_post_dft_filter:**

7. `test_apply_post_dft_filter_within_window()` - Create 3 ConformerData with DFT energies in Hartree that are all within 3 kcal/mol window (e.g., -40.5186, -40.5180, -40.5170 -- differences in milliHartree). Assert all 3 returned.

8. `test_apply_post_dft_filter_removes_high_energy()` - Create 4 ConformerData, one with energy 0.01 Hartree above minimum (= 6.28 kcal/mol, outside 3 kcal/mol window). Assert 3 returned, high-energy one excluded.

9. `test_apply_post_dft_filter_custom_window()` - Test with wider window (5 kcal/mol). Conformer that was excluded at 3 kcal/mol should now be included.

10. `test_apply_post_dft_filter_single_conformer()` - Single conformer always survives filter.

Run tests -- all MUST fail (functions don't exist yet).
  </action>
  <verify>Run `cd /home/chris/develop/qm-nmr-calc && python -m pytest tests/test_conformer_nwchem.py -v --tb=short` -- all tests FAIL.</verify>
  <done>10 failing test cases exist covering: scratch_dir override, all-succeed, partial-failure, too-many-failures, status tracking, geometry path storage, post-DFT filter within/outside/custom window, single conformer.</done>
</task>

<task type="auto">
  <name>Task 2: Implement run_calculation scratch_dir_override, run_conformer_dft_optimization, and apply_post_dft_filter</name>
  <files>src/qm_nmr_calc/nwchem/runner.py, src/qm_nmr_calc/nwchem/__init__.py</files>
  <action>
**Modify `run_calculation()` in runner.py:**

Add `scratch_dir_override: Path | None = None` parameter. When provided, use it instead of `job_dir / "scratch"` for scratch directory. This enables per-conformer NWChem isolation using already-created directories from Phase 12.

Also add support for geometry_file input without smiles. When `smiles is None` and `geometry_file` is provided and `skip_optimization is False`, load the geometry from geometry_file and proceed with DFT optimization (instead of generating from SMILES). This is the path used for conformer optimization -- we have XYZ geometry from RDKit, want DFT optimization.

Implementation:
```python
def run_calculation(
    smiles: str | None,  # Changed from str to str | None
    job_dir: Path,
    preset: dict,
    solvent: str,
    processes: int = 4,
    skip_optimization: bool = False,
    geometry_file: Path | None = None,
    on_optimization_complete: callable = None,
    scratch_dir_override: Path | None = None,  # NEW
) -> dict:
```

At the start of the function, set scratch_dir:
```python
scratch_dir = scratch_dir_override if scratch_dir_override else job_dir / "scratch"
scratch_dir.mkdir(exist_ok=True)
```

For the `smiles is None` with `geometry_file` provided case (not skip_optimization): load geometry via `load_geometry_file(geometry_file)`, then proceed with optimization steps (generate opt input, run NWChem, extract geometry).

**Add `run_conformer_dft_optimization()` to runner.py:**

```python
def run_conformer_dft_optimization(
    ensemble: ConformerEnsemble,
    job_id: str,
    preset: dict,
    solvent: str,
    processes: int = 4,
) -> tuple[list[ConformerData], list[ConformerData]]:
```

Implementation:
1. Get job_dir from storage.get_job_dir(job_id)
2. Iterate over ensemble.conformers sequentially
3. For each conformer:
   a. Set conformer.status = "optimizing"
   b. Get scratch_dir via storage.get_conformer_scratch_dir(job_id, conformer.conformer_id)
   c. Resolve geometry_file: job_dir / conformer.geometry_file
   d. Call run_calculation(smiles=None, job_dir=job_dir, preset=preset, solvent=solvent, skip_optimization=False, geometry_file=geom_path, scratch_dir_override=scratch_dir)
   e. Extract DFT energy: extract_dft_energy(result["optimization_output"].read_text())
   f. Update conformer: energy=dft_energy, energy_unit="hartree", status="optimized", optimized_geometry_file=str(result["geometry_file"].relative_to(job_dir))
   g. Append to successful list
4. On exception per-conformer: set status="failed", error_message=str(e)[:200], append to failed list, continue
5. After loop: check success_rate = len(successful) / len(ensemble.conformers). If < 0.5, raise RuntimeError.
6. Return (successful, failed)

Imports needed: ConformerEnsemble, ConformerData from models; get_job_dir, get_conformer_scratch_dir from storage; extract_dft_energy from output_parser.

**Add `apply_post_dft_filter()` to runner.py:**

```python
def apply_post_dft_filter(
    optimized_conformers: list[ConformerData],
    window_kcal: float = 3.0,
) -> list[ConformerData]:
```

Implementation:
1. Import HARTREE_TO_KCAL from conformers.boltzmann
2. Import filter_by_energy_window from conformers.filters
3. Convert DFT energies from Hartree to kcal/mol
4. Call filter_by_energy_window with indices and kcal energies
5. Return filtered subset of conformers

**Update `__init__.py`:**
- Import and export run_conformer_dft_optimization and apply_post_dft_filter

Run all tests -- new and existing MUST pass.
  </action>
  <verify>Run `cd /home/chris/develop/qm-nmr-calc && python -m pytest tests/test_conformer_nwchem.py -v --tb=short` -- all 10 tests pass. Then `cd /home/chris/develop/qm-nmr-calc && python -m pytest tests/ -v --tb=short` -- full suite green.</verify>
  <done>run_calculation accepts scratch_dir_override. run_conformer_dft_optimization runs sequential DFT loop with error aggregation and >50% threshold. apply_post_dft_filter filters by DFT energy window (default 3 kcal/mol). All exported from nwchem package. 10+ tests pass, no regressions.</done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_conformer_nwchem.py -v` -- all conformer DFT tests pass
2. `python -m pytest tests/test_nwchem_output.py -v` -- energy extraction tests pass (from 15-01)
3. `python -m pytest tests/ -v` -- full suite green
4. `python -c "from qm_nmr_calc.nwchem import run_conformer_dft_optimization, apply_post_dft_filter"` -- functions importable
</verification>

<success_criteria>
- run_calculation accepts scratch_dir_override parameter for per-conformer isolation
- run_calculation accepts smiles=None with geometry_file for conformer DFT optimization
- run_conformer_dft_optimization runs sequential DFT loop on all ensemble conformers
- ConformerData.status updated through pending -> optimizing -> optimized (or failed)
- DFT energy stored as float in Hartree with energy_unit="hartree"
- Per-conformer exceptions caught, processing continues
- RuntimeError raised when <50% succeed
- apply_post_dft_filter uses existing filter_by_energy_window with Hartree->kcal/mol conversion
- 10+ unit tests using mocks (no actual NWChem calls)
</success_criteria>

<output>
After completion, create `.planning/phases/15-multi-conformer-nwchem-integration/15-02-SUMMARY.md`
</output>
