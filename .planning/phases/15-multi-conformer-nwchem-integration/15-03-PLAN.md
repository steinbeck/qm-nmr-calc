---
phase: 15-multi-conformer-nwchem-integration
plan: 03
type: tdd
wave: 3
depends_on: ["15-02"]
files_modified:
  - src/qm_nmr_calc/nwchem/runner.py
  - src/qm_nmr_calc/nwchem/__init__.py
  - tests/test_conformer_nwchem.py
autonomous: true

must_haves:
  truths:
    - "run_conformer_nmr_calculations() runs NMR shielding on each post-DFT-filtered conformer"
    - "run_conformer_nmr_calculations() converts shielding to shifts using scaling factors and returns NMRResults per conformer"
    - "run_conformer_nmr_calculations() handles partial NMR failures gracefully (continues with remaining conformers) -- NO minimum success threshold for NMR since the DFT step's >50% threshold already caught systematic failures; any successful NMR results are usable"
    - "run_ensemble_dft_and_nmr() orchestrates the full DFT opt -> post-DFT filter -> NMR -> Boltzmann pipeline"
    - "run_ensemble_dft_and_nmr() updates ConformerEnsemble.total_after_post_filter"
    - "ConformerData.status transitions through nmr_running -> nmr_complete lifecycle"
  artifacts:
    - path: "src/qm_nmr_calc/nwchem/runner.py"
      provides: "run_conformer_nmr_calculations and run_ensemble_dft_and_nmr functions"
      contains: "def run_ensemble_dft_and_nmr"
    - path: "tests/test_conformer_nwchem.py"
      provides: "Tests for NMR loop and full orchestrator"
      contains: "test_conformer_nmr"
  key_links:
    - from: "src/qm_nmr_calc/nwchem/runner.py"
      to: "src/qm_nmr_calc/shifts.py"
      via: "shielding_to_shift for NMR shielding -> chemical shift conversion"
      pattern: "shielding_to_shift"
    - from: "src/qm_nmr_calc/nwchem/runner.py"
      to: "src/qm_nmr_calc/conformers/boltzmann.py"
      via: "average_ensemble_nmr for Boltzmann-weighted averaging"
      pattern: "average_ensemble_nmr"
    - from: "src/qm_nmr_calc/nwchem/runner.py"
      to: "src/qm_nmr_calc/models.py"
      via: "NMRResults and AtomShift for structured NMR data"
      pattern: "NMRResults"
---

<objective>
Implement per-conformer NMR calculation loop and the full DFT-to-Boltzmann orchestrator.

Purpose: Completes the Phase 15 computational pipeline. After DFT optimization and post-DFT filtering (Plan 02), each surviving conformer needs NMR shielding calculations. The orchestrator ties together: DFT optimization loop -> post-DFT filter -> NMR loop -> Boltzmann averaging (Phase 14). This is the function that the Huey task worker will call for ensemble mode jobs.

Output: `run_conformer_nmr_calculations()` and `run_ensemble_dft_and_nmr()` in runner.py, with comprehensive unit tests using mocks.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-multi-conformer-nwchem-integration/15-02-SUMMARY.md

@src/qm_nmr_calc/nwchem/runner.py
@src/qm_nmr_calc/models.py
@src/qm_nmr_calc/shifts.py
@src/qm_nmr_calc/conformers/boltzmann.py
@src/qm_nmr_calc/conformers/filters.py
@src/qm_nmr_calc/storage.py
@tests/test_conformer_nwchem.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write failing tests for NMR loop and orchestrator</name>
  <files>tests/test_conformer_nwchem.py</files>
  <action>
Add test cases to the existing `tests/test_conformer_nwchem.py` file. All tests mock NWChem and external calls.

**Helper fixtures needed (add to existing helpers):**

- `make_optimized_conformer(conf_id, energy_hartree)`: Creates ConformerData with status="optimized", energy=energy_hartree, energy_unit="hartree", optimized_geometry_file set.
- `make_shielding_data()`: Returns dict matching parse_shielding_output format: `{"index": [1, 2, 3], "atom": ["C", "H", "H"], "shielding": [183.45, 29.1, 29.2]}`

**IMPORTANT: Mocked run_calculation return value structure for NMR step:**

When mocking `run_calculation` for the NMR (skip_optimization=True) path, the mock must return a dict with this exact structure:
```python
{
    "shielding_data": {
        "index": [1, 2, 3],        # 1-based atom indices (list[int])
        "atom": ["C", "H", "H"],   # Element symbols (list[str])
        "shielding": [183.45, 29.1, 29.2],  # Isotropic shielding in ppm (list[float])
    },
    "geometry_file": Path("<tmp>/optimized.xyz"),
    "optimization_output": None,  # None because skip_optimization=True
    "shielding_output": Path("<tmp>/shielding.out"),
}
```
The `shielding_data` dict has keys `"index"`, `"atom"`, `"shielding"` -- this matches the output format of `parse_shielding_output()` in output_parser.py, which run_calculation calls internally and returns in the result dict.

**Tests for run_conformer_nmr_calculations:**

1. `test_conformer_nmr_all_succeed()` - Create 3 optimized ConformerData. Mock run_calculation(skip_optimization=True) to return the shielding_data dict structure above. Mock shielding_to_shift to return expected shifts. After call:
   - Assert returns (nmr_results=[3 NMRResults], failed=[])
   - Assert each conformer.status == "nmr_complete"
   - Each NMRResults has h1_shifts and c13_shifts lists

2. `test_conformer_nmr_partial_failure()` - Create 3 optimized conformers. Mock run_calculation to fail for one. After call:
   - Assert returns (nmr_results=[2 items], failed=[1 item])
   - Assert failed conformer status == "failed" with error_message

3. `test_conformer_nmr_status_transitions()` - Verify conformers go optimized -> nmr_running -> nmr_complete. Mock run_calculation. Capture status during execution if possible, or verify final state.

4. `test_conformer_nmr_uses_skip_optimization()` - Mock run_calculation. Verify it's called with skip_optimization=True and geometry_file set to the optimized geometry path. This ensures NMR step skips re-optimization.

5. `test_conformer_nmr_uses_nmr_basis_set()` - Verify run_calculation is called with the nmr_basis_set from preset, not the optimization basis_set. Mock and assert call args.

**Tests for run_ensemble_dft_and_nmr:**

6. `test_ensemble_full_pipeline()` - Create ensemble with 3 conformers. Mock run_conformer_dft_optimization to return 3 optimized conformers (with DFT energies close together). Mock apply_post_dft_filter to return all 3. Mock run_conformer_nmr_calculations to return 3 NMRResults. After call:
   - Assert returns (updated_ensemble, nmr_results_list)
   - Assert ensemble.total_after_post_filter == 3
   - Assert nmr_results_list has 3 items

7. `test_ensemble_pipeline_with_post_dft_filtering()` - Create ensemble with 4 conformers. Mock DFT optimization returns 4 optimized. Mock apply_post_dft_filter to return only 3 (one filtered by energy window). Mock NMR to return 3 results. Assert:
   - ensemble.total_after_post_filter == 3
   - NMR called only on 3 conformers

8. `test_ensemble_pipeline_with_dft_failures()` - Create ensemble with 4 conformers. Mock DFT optimization to fail 1. After call, ensemble has mix of optimized/nmr_complete and failed conformers.

9. `test_ensemble_pipeline_updates_ensemble_conformers()` - After full pipeline, ensemble.conformers should reflect final state: successful ones with status="nmr_complete", filtered-out ones excluded from NMR, failed ones with status="failed".

Run tests -- all new tests MUST fail.
  </action>
  <verify>Run `cd /home/chris/develop/qm-nmr-calc && python -m pytest tests/test_conformer_nwchem.py -v --tb=short -k "nmr or ensemble"` -- all new tests FAIL.</verify>
  <done>9 new failing test cases for NMR loop and orchestrator, covering: all-succeed, partial-failure, status transitions, skip_optimization, basis_set, full pipeline, post-DFT filtering, DFT failures, ensemble state updates.</done>
</task>

<task type="auto">
  <name>Task 2: Implement run_conformer_nmr_calculations and run_ensemble_dft_and_nmr</name>
  <files>src/qm_nmr_calc/nwchem/runner.py, src/qm_nmr_calc/nwchem/__init__.py</files>
  <action>
**Add `run_conformer_nmr_calculations()` to runner.py:**

```python
def run_conformer_nmr_calculations(
    optimized_conformers: list[ConformerData],
    job_id: str,
    preset: dict,
    solvent: str,
    processes: int = 4,
) -> tuple[list[NMRResults], list[ConformerData]]:
```

Implementation:
1. Import shielding_to_shift from shifts module; NMRResults, AtomShift from models
2. Iterate over optimized_conformers sequentially
3. For each conformer:
   a. Set conformer.status = "nmr_running"
   b. Get scratch_dir via get_conformer_scratch_dir(job_id, conformer.conformer_id)
   c. Resolve optimized geometry: job_dir / conformer.optimized_geometry_file
   d. Build NMR preset with nmr_basis_set: `nmr_preset = {**preset, "basis_set": preset["nmr_basis_set"]}`
   e. Call run_calculation(smiles=None, job_dir=job_dir, preset=preset, solvent=solvent, skip_optimization=True, geometry_file=opt_geom_path, scratch_dir_override=scratch_dir)
   f. Parse shielding output: result["shielding_data"]
   g. Convert to shifts: shielding_to_shift(shielding_data, functional=preset["functional"], basis_set=preset["nmr_basis_set"], solvent=solvent)
   h. Build NMRResults from shift data (convert dict to AtomShift list)
   i. Set conformer.status = "nmr_complete"
   j. Append NMRResults to results list
4. On exception: set status="failed", error_message, append to failed list
5. Return (nmr_results, failed)

Note: The shielding_to_shift function returns {"1H": [...], "13C": [...]} where each entry is a dict with index/atom/shielding/shift. Convert to AtomShift objects for NMRResults:
```python
h1_shifts = [AtomShift(**s) for s in shift_data["1H"]]
c13_shifts = [AtomShift(**s) for s in shift_data["13C"]]
nmr_result = NMRResults(
    h1_shifts=h1_shifts,
    c13_shifts=c13_shifts,
    functional=preset["functional"],
    basis_set=preset["nmr_basis_set"],
    solvent=solvent,
)
```

**Add `run_ensemble_dft_and_nmr()` to runner.py:**

```python
def run_ensemble_dft_and_nmr(
    ensemble: ConformerEnsemble,
    job_id: str,
    preset: dict,
    solvent: str,
    processes: int = 4,
) -> tuple[ConformerEnsemble, list[NMRResults]]:
```

Implementation:
1. **Step 1: DFT optimization** - Call run_conformer_dft_optimization(ensemble, job_id, preset, solvent, processes)
   - Returns (optimized, failed_opt)
2. **Step 2: Post-DFT energy filter** - Call apply_post_dft_filter(optimized, window_kcal=ensemble.post_dft_energy_window_kcal)
   - Update ensemble.total_after_post_filter = len(filtered)
3. **Step 3: NMR calculations** - Call run_conformer_nmr_calculations(filtered, job_id, preset, solvent, processes)
   - Returns (nmr_results, failed_nmr)
   - Note: NMR has NO minimum success threshold (unlike DFT's >50%). Any successful NMR results are usable since DFT already caught systematic failures.
4. **Step 4: Ensemble state** - The ensemble is mutated in place during the loops. Each ConformerData is a Pydantic model whose fields (status, energy, etc.) are updated by reference in the DFT and NMR loops. The `ensemble.conformers` list already contains references to the same objects that were updated. No reconstruction of the conformers list is needed. The final states are:
   - Conformers that completed NMR: status="nmr_complete" (updated by NMR loop)
   - Conformers filtered by post-DFT energy window: status="optimized" (unchanged -- they were excluded from NMR, not failed)
   - Conformers that failed DFT or NMR: status="failed" (set by the respective loop's exception handler)
5. Return (ensemble, nmr_results)

The nmr_results list is parallel to the conformers that have status="nmr_complete" -- same order. These get passed to average_ensemble_nmr() from Phase 14 by the caller (Huey task).

**Update `__init__.py`:**
- Import and export run_conformer_nmr_calculations and run_ensemble_dft_and_nmr

Run all tests -- new and existing MUST pass.
  </action>
  <verify>Run `cd /home/chris/develop/qm-nmr-calc && python -m pytest tests/test_conformer_nwchem.py -v --tb=short` -- all tests pass (both Plan 02 and Plan 03 tests). Then `cd /home/chris/develop/qm-nmr-calc && python -m pytest tests/ -v --tb=short` -- full suite green.</verify>
  <done>run_conformer_nmr_calculations runs NMR shielding on optimized conformers with skip_optimization=True. run_ensemble_dft_and_nmr orchestrates full pipeline: DFT opt -> post-DFT filter -> NMR -> returns ensemble + results for Boltzmann averaging. All 19+ tests pass, no regressions.</done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_conformer_nwchem.py -v` -- all conformer NWChem tests pass (Plans 02 + 03)
2. `python -m pytest tests/ -v` -- full suite green
3. `python -c "from qm_nmr_calc.nwchem import run_ensemble_dft_and_nmr, run_conformer_nmr_calculations"` -- functions importable
4. Verify ConformerData status lifecycle covers: pending -> optimizing -> optimized -> nmr_running -> nmr_complete (or failed at any point)
</verification>

<success_criteria>
- run_conformer_nmr_calculations runs NMR shielding on each conformer with skip_optimization=True
- Shielding converted to shifts via existing shielding_to_shift with scaling factors
- NMRResults returned per conformer with AtomShift objects
- Per-conformer NMR failures handled gracefully (continues processing)
- run_ensemble_dft_and_nmr orchestrates: DFT opt -> post-DFT filter -> NMR -> ensemble update
- ConformerEnsemble.total_after_post_filter updated after filtering
- Ensemble conformers reflect final states (nmr_complete / optimized / failed)
- 9+ new tests using mocks for NMR loop and orchestrator
- Full test suite passes with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/15-multi-conformer-nwchem-integration/15-03-SUMMARY.md`
</output>
