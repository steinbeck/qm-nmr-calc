---
phase: 16-crest-integration
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/qm_nmr_calc/conformers/crest_generator.py
  - tests/test_crest_generator.py
autonomous: true

must_haves:
  truths:
    - "detect_crest_available() returns True only when both crest and xtb are on PATH"
    - "detect_crest_available() returns False when only one binary is present"
    - "get_alpb_solvent() maps CHCl3 -> 'chcl3' and DMSO -> 'dmso' (case-insensitive input)"
    - "get_alpb_solvent() returns None for vacuum and unsupported solvents"
    - "parse_crest_ensemble() correctly splits multi-structure XYZ into individual conformers"
    - "parse_crest_ensemble() extracts Hartree energies from comment lines"
    - "CRESTConformer stores conformer_id, energy_hartree, and xyz_block"
  artifacts:
    - path: "src/qm_nmr_calc/conformers/crest_generator.py"
      provides: "CREST detection, solvent mapping, XYZ parsing"
      exports: ["detect_crest_available", "get_alpb_solvent", "parse_crest_ensemble", "CRESTConformer", "ALPB_SOLVENT_MAP"]
    - path: "tests/test_crest_generator.py"
      provides: "TDD tests for CREST generator utilities"
      min_lines: 80
  key_links:
    - from: "src/qm_nmr_calc/conformers/crest_generator.py"
      to: "shutil.which"
      via: "stdlib binary detection"
      pattern: "shutil\\.which"
---

<objective>
Implement and test the foundational CREST utilities: binary detection, ALPB solvent mapping, and multi-structure XYZ file parsing.

Purpose: These three pure functions are prerequisites for the CREST runner (Plan 02) and pipeline dispatch (Plan 03). They contain testable logic with clear inputs/outputs, ideal for TDD.

Output: `crest_generator.py` module with detection, mapping, and parsing functions, fully tested.
</objective>

<execution_context>
@/home/chris/.claude/get-shit-done/workflows/execute-plan.md
@/home/chris/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/qm_nmr_calc/conformers/generator.py
@src/qm_nmr_calc/conformers/pipeline.py
@src/qm_nmr_calc/models.py
</context>

<feature>
  <name>CREST Binary Detection, ALPB Solvent Mapping, and Multi-XYZ Parsing</name>
  <files>src/qm_nmr_calc/conformers/crest_generator.py, tests/test_crest_generator.py</files>
  <behavior>
    Three independent utility functions:

    1. `detect_crest_available() -> bool`:
       - Uses `shutil.which("crest")` and `shutil.which("xtb")` to detect both binaries
       - Cached with `@lru_cache(maxsize=1)` -- result never changes during process lifetime
       - Both present -> True; either missing -> False
       - Test cases:
         - Both found -> True
         - Only crest -> False
         - Only xtb -> False
         - Neither -> False

    2. `get_alpb_solvent(job_solvent: str) -> str | None`:
       - Hardcoded mapping: {"chcl3": "chcl3", "dmso": "dmso"}
       - Input normalized to lowercase for case-insensitive matching
       - Returns None for "vacuum" and any unsupported solvent
       - Test cases:
         - "CHCl3" -> "chcl3"
         - "chcl3" -> "chcl3"
         - "DMSO" -> "dmso"
         - "dmso" -> "dmso"
         - "vacuum" -> None
         - "water" -> None (unsupported)

    3. `parse_crest_ensemble(ensemble_file: Path) -> list[CRESTConformer]`:
       - Parses concatenated multi-structure XYZ format:
         ```
         <num_atoms>
         <energy_in_hartree>  (first token on comment line)
         <atom> <x> <y> <z>
         ...
         <num_atoms>
         <energy_in_hartree>
         <atom> <x> <y> <z>
         ...
         ```
       - Returns list of CRESTConformer(conformer_id, energy_hartree, xyz_block)
       - conformer_id uses sequential 1-based naming: "conf_001", "conf_002", ...
       - xyz_block contains the full XYZ content for that conformer (atom count + comment + coords)
       - Test cases:
         - Single conformer file -> list of 1
         - Multi-conformer file (3 structures) -> list of 3 with correct energies
         - Energies parsed as float from first token on comment line
         - xyz_block reconstructed correctly (atom count line + comment + atom lines)

    4. `CRESTConformer` -- NamedTuple with fields: conformer_id (str), energy_hartree (float), xyz_block (str)

    5. `ALPB_SOLVENT_MAP` -- dict constant: {"chcl3": "chcl3", "dmso": "dmso"}
  </behavior>
  <implementation>
    Create `src/qm_nmr_calc/conformers/crest_generator.py` with:
    - Import shutil, functools.lru_cache, pathlib.Path, typing.NamedTuple
    - CRESTConformer NamedTuple
    - ALPB_SOLVENT_MAP constant
    - detect_crest_available() with lru_cache
    - get_alpb_solvent() function
    - parse_crest_ensemble() function

    Tests use unittest.mock.patch on shutil.which for detection tests.
    Tests use tmp_path fixture with written XYZ content for parsing tests.
    Follow existing test naming pattern: test_crest_* prefix.
  </implementation>
</feature>

<verification>
```bash
cd /home/chris/develop/qm-nmr-calc && python -m pytest tests/test_crest_generator.py -v
```
All tests pass. No existing tests broken:
```bash
cd /home/chris/develop/qm-nmr-calc && python -m pytest --tb=short -q
```
</verification>

<success_criteria>
- detect_crest_available() correctly handles all 4 combinations of binary presence
- get_alpb_solvent() maps CHCl3 and DMSO correctly, returns None for vacuum/unsupported
- parse_crest_ensemble() parses multi-structure XYZ with correct energies and xyz_blocks
- All 229+ existing tests still pass
- New test file has minimum 8 test functions covering all behaviors
</success_criteria>

<output>
After completion, create `.planning/phases/16-crest-integration/16-01-SUMMARY.md`
</output>
