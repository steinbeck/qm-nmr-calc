---
phase: 49-config-foundation-and-pricing-query
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - gcp/query_pricing.py
  - gcp/lib/pricing.sh
  - tests/test_gcp_pricing.py
autonomous: true

must_haves:
  truths:
    - "System returns spot pricing data sorted by price for a given machine spec"
    - "Pricing data cached in JSON file with 24-hour TTL, reused on subsequent calls"
    - "When pricing API fails, hardcoded regional fallback ranking returned instead"
    - "Bash pricing library provides region selection from Python pricing output"
    - "Cache older than 24 hours triggers fresh API query"
  artifacts:
    - path: "gcp/query_pricing.py"
      provides: "Pricing query with CloudPrice.net API, caching, and hardcoded fallback"
      contains: "FALLBACK_REGIONS"
    - path: "gcp/lib/pricing.sh"
      provides: "Bash functions for pricing queries"
      contains: "get_cheapest_region"
    - path: "tests/test_gcp_pricing.py"
      provides: "Unit tests for pricing module"
      min_lines: 80
  key_links:
    - from: "gcp/query_pricing.py"
      to: "CloudPrice.net API"
      via: "httpx.get()"
      pattern: "httpx\\.get"
    - from: "gcp/query_pricing.py"
      to: "gcp/.cache/spot-pricing.json"
      via: "json.dump/load"
      pattern: "spot-pricing\\.json"
    - from: "gcp/lib/pricing.sh"
      to: "gcp/query_pricing.py"
      via: "python3 query_pricing.py"
      pattern: "query_pricing"
---

<objective>
Implement spot pricing query with CloudPrice.net API, TTL caching, and hardcoded regional fallback.

Purpose: Enable automated region selection by finding the cheapest spot instance across all GCP regions. The hardcoded fallback ensures deployment works even when the pricing API is unavailable (LOW confidence in API reliability per research).

Output: Python pricing module with API integration + fallback, bash pricing library, comprehensive tests.
</objective>

<execution_context>
@/Users/steinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/steinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/49-config-foundation-and-pricing-query/49-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write failing tests for pricing module</name>
  <files>tests/test_gcp_pricing.py</files>
  <action>
Create test file `tests/test_gcp_pricing.py` with tests for the pricing module. Import from `gcp.query_pricing`.

Test cases to write (all should FAIL since implementation doesn't exist yet):

**Hardcoded Fallback Tests:**
1. **test_fallback_regions_exist** - `FALLBACK_REGIONS` is a list of dicts with keys: region, zone, rank (lower is better/cheaper)
2. **test_fallback_regions_have_required_keys** - Each entry has "region", "zone", "rank" keys
3. **test_fallback_regions_sorted_by_rank** - List is sorted by rank ascending
4. **test_fallback_covers_us_regions** - At least 3 US regions in fallback (us-central1, us-east1, us-west1, etc.)
5. **test_fallback_covers_europe** - At least 2 European regions in fallback
6. **test_get_ranked_regions_returns_fallback** - `get_ranked_regions(cpu_cores=8, ram_gb=32)` returns list when API unavailable. Use monkeypatch to make httpx.get raise `httpx.ConnectError`.

**Cache Tests:**
7. **test_save_and_load_cache** - `save_cache(data, cache_file)` writes JSON, `load_cache(cache_file)` reads it back
8. **test_cache_fresh** - Cache written with current timestamp is considered fresh (< 24 hours)
9. **test_cache_stale** - Cache written with timestamp 25 hours ago is considered stale (returns None)
10. **test_cache_missing** - `load_cache(nonexistent_path)` returns None
11. **test_cache_ttl_default** - Default TTL is 86400 seconds (24 hours)

**API Integration Tests (mocked):**
12. **test_query_api_success** - Mock httpx.get to return pricing data. `query_cloudprice_api(cpu_cores=8, ram_gb=32)` returns list of region/price dicts sorted by price ascending.
13. **test_query_api_timeout** - Mock httpx.get to raise `httpx.TimeoutException`. Function returns None (caller should use fallback).
14. **test_query_api_http_error** - Mock httpx.get to return 500 status. Function returns None.
15. **test_query_api_auth_error** - Mock httpx.get to return 401 status. Function returns None (no API key configured).

**Integration Tests:**
16. **test_get_ranked_regions_uses_cache** - Write fresh cache, monkeypatch httpx.get to raise, verify `get_ranked_regions()` returns cached data (not fallback)
17. **test_get_ranked_regions_refreshes_stale_cache** - Write stale cache (25h old), mock httpx.get to return new data, verify `get_ranked_regions()` returns new data (not stale cache)
18. **test_get_ranked_regions_fallback_on_total_failure** - No cache, API raises error, verify fallback regions returned
19. **test_format_pricing_output** - `format_pricing_output(regions)` returns JSON string parseable by jq (valid JSON, array of objects with region, zone, price_per_hour keys)

Use `tmp_path` fixture for cache file paths. Use `monkeypatch` for mocking httpx. Import httpx for exception types.

Run tests: `cd /Users/steinbeck/Dropbox/develop/qm-nmr-calc && python -m pytest tests/test_gcp_pricing.py -v`
Tests MUST fail (ImportError since gcp/query_pricing.py doesn't exist yet).
  </action>
  <verify>
Run `python -m pytest tests/test_gcp_pricing.py -v 2>&1 | head -50` and confirm all tests fail with ImportError (RED phase).
  </verify>
  <done>19 test cases exist in tests/test_gcp_pricing.py, all failing because implementation doesn't exist yet.</done>
</task>

<task type="auto">
  <name>Task 2: Implement pricing module and make tests pass</name>
  <files>gcp/query_pricing.py, gcp/lib/pricing.sh</files>
  <action>
**Step 1: Create `gcp/query_pricing.py`**

Create as a Python module that is BOTH importable and runnable as a script.

**Constants:**

`FALLBACK_REGIONS` - Hardcoded list of GCP regions ranked by typical spot pricing (cheapest first). Based on GCP spot pricing patterns, these regions are consistently cheap for compute:

```python
FALLBACK_REGIONS = [
    {"region": "us-central1", "zone": "us-central1-a", "rank": 1},
    {"region": "us-east4", "zone": "us-east4-a", "rank": 2},
    {"region": "us-west1", "zone": "us-west1-a", "rank": 3},
    {"region": "us-east1", "zone": "us-east1-b", "rank": 4},
    {"region": "us-west4", "zone": "us-west4-a", "rank": 5},
    {"region": "europe-west1", "zone": "europe-west1-b", "rank": 6},
    {"region": "europe-west4", "zone": "europe-west4-a", "rank": 7},
    {"region": "asia-east1", "zone": "asia-east1-a", "rank": 8},
    {"region": "asia-southeast1", "zone": "asia-southeast1-a", "rank": 9},
    {"region": "southamerica-east1", "zone": "southamerica-east1-a", "rank": 10},
]
```

`CACHE_TTL = 86400` (24 hours in seconds)
`DEFAULT_CACHE_DIR = Path("gcp/.cache")`

**Cache Functions:**

- `load_cache(cache_file: Path) -> list | None`: Read JSON file, check `cached_at` timestamp against CACHE_TTL, return `regions` list if fresh, None if stale/missing/corrupt. Wrap in try/except for JSON decode errors.
- `save_cache(regions: list, cache_file: Path) -> None`: Write JSON with `cached_at` (time.time()) and `regions` keys. Create parent directory with `mkdir(parents=True, exist_ok=True)`.

**API Functions:**

- `query_cloudprice_api(cpu_cores: int, ram_gb: int) -> list | None`: Query CloudPrice.net API for spot pricing. Return list of `{"region": str, "zone": str, "price_per_hour": float}` sorted by price ascending. Return None on any error (timeout, HTTP error, auth error, connection error). Use httpx with 10-second timeout. Catch `httpx.HTTPError` (base class for all httpx exceptions) and `httpx.HTTPStatusError`. Log errors to stderr.

  **CloudPrice.net API approach:** Since exact API endpoints have LOW confidence from research, implement a best-effort query:
  - Try `https://api.cloudprice.net/v1/gcp/compute` with params for filtering
  - If that fails, try scraping/parsing `https://cloudprice.net/gcp/regions` as fallback
  - If both fail, return None (hardcoded fallback will be used)
  - API key from environment variable `CLOUDPRICE_API_KEY` (optional)

**Orchestrator Function:**

- `get_ranked_regions(cpu_cores: int = 8, ram_gb: int = 32, cache_dir: Path | None = None) -> list`:
  1. Check cache (load_cache). If fresh, return cached data.
  2. Try API query (query_cloudprice_api). If success, save to cache, return data.
  3. Fall back to FALLBACK_REGIONS (always succeeds). Print warning to stderr: "WARNING: Using hardcoded regional fallback (pricing API unavailable)"
  4. Never fails -- always returns a list.

- `format_pricing_output(regions: list) -> str`: Return JSON string of the regions list. Valid JSON that can be parsed by jq.

**Script mode (`if __name__ == '__main__'`):**
- Accept `--cpu-cores N` and `--ram-gb N` arguments (defaults: 8, 32)
- Accept `--cache-dir PATH` argument (default: gcp/.cache)
- Accept `--refresh` flag to bypass cache
- Output JSON to stdout (parseable by jq)
- Exit 0 always (fallback guarantees results)

**Step 2: Create `gcp/lib/pricing.sh`**

Bash library that calls Python pricing module and provides shell functions.

```bash
#!/bin/bash
# Pricing query library for v2.7 automated deployment
# Queries spot pricing and provides region selection functions

get_cheapest_region() {
    local cpu_cores="${1:-8}"
    local ram_gb="${2:-32}"
    local script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

    local pricing_json
    pricing_json=$(python3 "$script_dir/query_pricing.py" \
        --cpu-cores "$cpu_cores" \
        --ram-gb "$ram_gb" 2>/dev/null) || {
        echo "ERROR: Pricing query failed" >&2
        return 1
    }

    # Return first (cheapest) region
    echo "$pricing_json" | jq -r '.[0].region'
}

get_cheapest_zone() {
    local cpu_cores="${1:-8}"
    local ram_gb="${2:-32}"
    local script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

    local pricing_json
    pricing_json=$(python3 "$script_dir/query_pricing.py" \
        --cpu-cores "$cpu_cores" \
        --ram-gb "$ram_gb" 2>/dev/null) || {
        echo "ERROR: Pricing query failed" >&2
        return 1
    }

    # Return first (cheapest) zone
    echo "$pricing_json" | jq -r '.[0].zone'
}

get_pricing_table() {
    local cpu_cores="${1:-8}"
    local ram_gb="${2:-32}"
    local script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

    # Return full JSON for display/processing
    python3 "$script_dir/query_pricing.py" \
        --cpu-cores "$cpu_cores" \
        --ram-gb "$ram_gb"
}
```

**Step 3: Run tests and iterate**

Run `python -m pytest tests/test_gcp_pricing.py -v` and fix until all 19 tests pass (GREEN phase).

Also run existing tests to confirm no regressions: `python -m pytest --tb=short -q`
  </action>
  <verify>
1. `python -m pytest tests/test_gcp_pricing.py -v` -- all 19 tests pass
2. `python -m pytest --tb=short -q` -- all existing tests still pass
3. `python3 gcp/query_pricing.py --cpu-cores 8 --ram-gb 32` -- outputs valid JSON array
4. `python3 gcp/query_pricing.py --cpu-cores 8 --ram-gb 32 | jq '.[0].region'` -- outputs a region string
5. `python3 gcp/query_pricing.py --cpu-cores 8 --ram-gb 32 | jq 'length'` -- outputs number > 0
  </verify>
  <done>
Pricing module queries CloudPrice.net API with httpx, caches results in JSON with 24-hour TTL, falls back to hardcoded regional rankings when API unavailable. Bash library wraps Python output for shell scripting. All 19 tests pass, no regressions. get_ranked_regions() always returns results (never fails).
  </done>
</task>

</tasks>

<verification>
1. Pricing API query attempted with httpx, errors handled gracefully
2. Cache file written/read with 24-hour TTL
3. Hardcoded fallback always available when API fails
4. JSON output parseable by jq
5. Bash library provides get_cheapest_region() and get_cheapest_zone()
6. All tests pass (19 new + existing)
</verification>

<success_criteria>
- 19 pricing tests pass
- No test regressions
- Pricing script always produces output (never fails)
- Cache file persists between invocations
- Hardcoded fallback covers 10+ regions across 4+ continents
</success_criteria>

<output>
After completion, create `.planning/phases/49-config-foundation-and-pricing-query/49-02-SUMMARY.md`
</output>
