---
phase: 49-config-foundation-and-pricing-query
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - gcp/config.toml.example
  - gcp/validate_config.py
  - gcp/lib/config.sh
  - tests/test_gcp_config.py
  - .gitignore
autonomous: true

must_haves:
  truths:
    - "User creates gcp/config.toml from example template and validation script accepts it"
    - "Missing project_id produces clear error message mentioning the field"
    - "Invalid CPU/RAM ratio (e.g. 64 cores + 16GB) rejected with actionable message"
    - "Validation script outputs bash-compatible export statements on success"
    - "Bash config loader sources validated exports and sets shell variables"
  artifacts:
    - path: "gcp/config.toml.example"
      provides: "Commented TOML template with [gcp] section"
      contains: "[gcp]"
    - path: "gcp/validate_config.py"
      provides: "Python validation script with Pydantic model"
      contains: "class GCPConfig"
    - path: "gcp/lib/config.sh"
      provides: "Bash functions to load validated config"
      contains: "load_config"
    - path: "tests/test_gcp_config.py"
      provides: "Unit tests for config validation"
      min_lines: 80
  key_links:
    - from: "gcp/validate_config.py"
      to: "gcp/config.toml"
      via: "tomllib.load()"
      pattern: "tomllib\\.load"
    - from: "gcp/lib/config.sh"
      to: "gcp/validate_config.py"
      via: "eval $(python3 validate_config.py)"
      pattern: "validate_config"
    - from: "gcp/validate_config.py"
      to: "stdout"
      via: "print(f\"export ...\")"
      pattern: "export.*="
---

<objective>
Create TOML-based config file with Pydantic validation for GCP deployment parameters.

Purpose: Replace v2.6's bash config.sh with a validated TOML config that catches errors (missing project ID, impossible CPU/RAM combinations) before any GCP operations run. This is the foundation for all v2.7 automated deployment.

Output: config.toml.example template, Python validation script, bash config loader, comprehensive tests.
</objective>

<execution_context>
@/Users/steinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/steinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/49-config-foundation-and-pricing-query/49-RESEARCH.md

Key existing files:
@gcp/config.sh.example (current v2.6 bash config template)
@gcp/config.sh (current user config, gitignored)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write failing tests for config validation</name>
  <files>tests/test_gcp_config.py</files>
  <action>
Create test file `tests/test_gcp_config.py` with tests for the GCPConfig Pydantic model. Import from `gcp.validate_config` module (the validate_config.py script will be importable).

Test cases to write (all should FAIL since implementation doesn't exist yet):

1. **test_valid_config** - Valid config dict with project_id="my-test-project", cpu_cores=8, ram_gb=32, disk_size_gb=100, resource_prefix="qm-nmr-calc" parses successfully
2. **test_valid_config_minimal** - Only required fields (project_id, cpu_cores, ram_gb) work, defaults applied for resource_prefix ("qm-nmr-calc") and disk_size_gb (100)
3. **test_missing_project_id** - Config without project_id raises ValidationError
4. **test_project_id_too_short** - project_id "ab" (less than 6 chars) raises ValidationError
5. **test_project_id_too_long** - project_id with 31+ chars raises ValidationError
6. **test_project_id_uppercase** - project_id "My-Project" raises ValidationError with message about lowercase
7. **test_project_id_starts_with_hyphen** - project_id "-my-project" raises ValidationError
8. **test_project_id_ends_with_hyphen** - project_id "my-project-" raises ValidationError
9. **test_ram_cpu_ratio_too_low** - cpu_cores=64, ram_gb=16 (ratio 0.25, below 0.5) raises ValidationError
10. **test_ram_cpu_ratio_too_high** - cpu_cores=4, ram_gb=64 (ratio 16, above 8) raises ValidationError
11. **test_ram_cpu_ratio_boundary_low** - cpu_cores=8, ram_gb=4 (ratio 0.5, boundary) passes
12. **test_ram_cpu_ratio_boundary_high** - cpu_cores=4, ram_gb=32 (ratio 8, boundary) passes
13. **test_cpu_cores_too_low** - cpu_cores=2 (below min 4) raises ValidationError
14. **test_disk_size_too_small** - disk_size_gb=5 (below min 10) raises ValidationError
15. **test_load_toml_file** - Test `load_config(path)` function: write a valid TOML string to a temp file (using `tmp_path` fixture), load it, verify GCPConfig returned with correct values. TOML content should have `[gcp]` section header.
16. **test_load_toml_missing_section** - TOML file without `[gcp]` section raises ValueError with message about missing section
17. **test_load_toml_invalid_syntax** - TOML file with broken syntax raises ValueError
18. **test_load_toml_file_not_found** - Non-existent path raises FileNotFoundError
19. **test_format_exports** - Test `format_exports(config)` function returns string containing bash export statements: `export GCP_PROJECT_ID=`, `export CPU_CORES=`, `export RAM_GB=`, `export DISK_SIZE_GB=`, `export RESOURCE_PREFIX=`

Use pytest with `from pydantic import ValidationError` for error assertions. Use `pytest.raises(ValidationError)` for validation errors and `pytest.raises(ValueError)` for load errors.

Run tests: `cd /Users/steinbeck/Dropbox/develop/qm-nmr-calc && python -m pytest tests/test_gcp_config.py -v`
Tests MUST fail (ImportError since gcp/validate_config.py doesn't exist yet).
  </action>
  <verify>
Run `python -m pytest tests/test_gcp_config.py -v 2>&1 | head -50` and confirm all tests fail with ImportError or similar (RED phase).
  </verify>
  <done>19 test cases exist in tests/test_gcp_config.py, all failing because implementation doesn't exist yet.</done>
</task>

<task type="auto">
  <name>Task 2: Implement config validation and make tests pass</name>
  <files>gcp/validate_config.py, gcp/config.toml.example, gcp/lib/config.sh, .gitignore</files>
  <action>
**Step 1: Create `gcp/validate_config.py`**

Create as a Python module that is BOTH importable and runnable as a script.

Classes and functions to implement:

```python
class GCPConfig(BaseModel):
    project_id: str  # 6-30 chars, lowercase + digits + hyphens, no leading/trailing hyphens
    resource_prefix: str = "qm-nmr-calc"
    cpu_cores: int  # ge=4, le=224
    ram_gb: int  # ge=8, le=896
    disk_size_gb: int = 100  # ge=10, le=65536
```

Field validators:
- `validate_project_id`: Check 6-30 chars, lowercase letters/digits/hyphens only, no leading/trailing hyphens. Use `@field_validator('project_id')`.
- `validate_ram_ratio`: Check RAM/CPU ratio is 0.5-8.0 GB/core. Use `@field_validator('ram_gb')` with `ValidationInfo` to access `cpu_cores`.

Functions:
- `load_config(path: Path) -> GCPConfig`: Open TOML with 'rb' mode (required by tomllib), check for `[gcp]` section (raise ValueError if missing with message "Config file missing [gcp] section"), catch `tomllib.TOMLDecodeError` and re-raise as ValueError, validate with Pydantic.
- `format_exports(config: GCPConfig) -> str`: Return bash-compatible export statements. Use single quotes around string values to prevent shell injection. One export per line.

Script mode (`if __name__ == '__main__'`):
- Default config path: `gcp/config.toml` (relative to script's parent directory)
- Accept optional `--config PATH` argument via argparse
- On success: print exports to stdout, exit 0
- On error: print "ERROR: ..." to stderr, exit 1
- Errors formatted as user-friendly messages, not raw Pydantic output

Important: Add `gcp/__init__.py` (empty file) so tests can import `from gcp.validate_config import GCPConfig, load_config, format_exports`.

**Step 2: Create `gcp/config.toml.example`**

```toml
# GCP Deployment Configuration
# Copy to config.toml and customize:
#   cp config.toml.example config.toml

[gcp]
# Required: Your GCP project ID
# Find at: GCP Console -> Project selector -> copy project ID
project_id = "your-project-id"

# Prefix for all resource names (IP, firewall rules, disk, VM)
resource_prefix = "qm-nmr-calc"

# Compute requirements
cpu_cores = 8       # Min: 4, Max: 224
ram_gb = 32         # Min: 8, Max: 896 (ratio: 0.5-8 GB per core)

# Persistent disk size in GB (stores job data)
disk_size_gb = 100  # Min: 10
```

**Step 3: Create `gcp/lib/config.sh`**

Bash library that validates config via Python, then sources the exports.

```bash
#!/bin/bash
# Config loading library for v2.7 automated deployment
# Sources validated TOML config as bash environment variables

load_config() {
    local config_path="${1:-gcp/config.toml}"
    local script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

    if [[ ! -f "$config_path" ]]; then
        echo "ERROR: Config file not found: $config_path" >&2
        echo "Create from template: cp gcp/config.toml.example gcp/config.toml" >&2
        return 1
    fi

    local exports
    exports=$(python3 "$script_dir/validate_config.py" --config "$config_path" 2>&1) || {
        echo "$exports" >&2
        return 1
    }

    eval "$exports"
}
```

Create the `gcp/lib/` directory first (mkdir -p).

**Step 4: Update `.gitignore`**

Add `gcp/config.toml` to .gitignore (after existing `gcp/config.sh` line). Also add `gcp/.cache/` for the pricing cache that Plan 02 will create.

**Step 5: Create `gcp/__init__.py`**

Create empty `gcp/__init__.py` file so the gcp directory is importable as a Python package for testing.

**Step 6: Run tests and iterate**

Run `python -m pytest tests/test_gcp_config.py -v` and fix until all 19 tests pass (GREEN phase).

Also run existing tests to confirm no regressions: `python -m pytest --tb=short -q`
  </action>
  <verify>
1. `python -m pytest tests/test_gcp_config.py -v` -- all 19 tests pass
2. `python -m pytest --tb=short -q` -- all existing tests still pass (356+ tests)
3. `python3 gcp/validate_config.py --config gcp/config.toml.example 2>&1` -- should fail with validation error about "your-project-id"
4. Create a temp valid config and verify exports: `echo -e '[gcp]\nproject_id = "test-project-123"\ncpu_cores = 8\nram_gb = 32' > /tmp/test-config.toml && python3 gcp/validate_config.py --config /tmp/test-config.toml` -- should output export statements
5. `grep 'config.toml' .gitignore` -- config.toml is gitignored
  </verify>
  <done>
GCPConfig Pydantic model validates all config fields with clear error messages. load_config() parses TOML and returns validated model. format_exports() outputs bash-compatible exports. Bash config loader in gcp/lib/config.sh bridges Python validation to bash scripts. All 19 tests pass, no regressions. config.toml.example template exists with commented guidance.
  </done>
</task>

</tasks>

<verification>
1. Config validation rejects invalid project IDs, impossible CPU/RAM ratios, out-of-range values
2. Valid config produces bash export statements that can be eval'd in bash
3. gcp/config.toml.example has all required fields with comments
4. gcp/lib/config.sh loads and validates config via Python
5. gcp/config.toml is gitignored
6. All tests pass (19 new + 356 existing)
</verification>

<success_criteria>
- 19 config validation tests pass
- No test regressions
- Python validation script runnable from CLI
- Bash config loader sources validated exports
- config.toml.example is a valid, documented template
</success_criteria>

<output>
After completion, create `.planning/phases/49-config-foundation-and-pricing-query/49-01-SUMMARY.md`
</output>
