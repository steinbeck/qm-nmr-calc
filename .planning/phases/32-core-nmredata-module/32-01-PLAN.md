---
phase: 32-core-nmredata-module
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/qm_nmr_calc/nmredata.py
  - tests/test_nmredata.py
autonomous: true

must_haves:
  truths:
    - "generate_nmredata_sdf() returns valid SDF string with NMReData tags"
    - "Atom indices in ASSIGNMENT tag are 1-indexed (not 0-indexed)"
    - "Solvent names map correctly (CHCl3->CDCl3, DMSO->(CD3)2SO, vacuum->vacuum)"
    - "All 9 required NMReData tags are present in output"
    - "Ensemble jobs use Boltzmann-averaged shifts with lowest-energy conformer geometry"
  artifacts:
    - path: "src/qm_nmr_calc/nmredata.py"
      provides: "NMReData SDF generation"
      exports: ["generate_nmredata_sdf", "NMREDATA_VERSION", "NMREDATA_SEP"]
      min_lines: 150
    - path: "tests/test_nmredata.py"
      provides: "Unit tests for NMReData generation"
      min_lines: 200
  key_links:
    - from: "src/qm_nmr_calc/nmredata.py"
      to: "rdkit.Chem"
      via: "MolFromSmiles, AddHs, SetProp, MolToMolBlock"
      pattern: "Chem\\.(MolFromSmiles|AddHs|MolToMolBlock)"
    - from: "src/qm_nmr_calc/nmredata.py"
      to: "models.AtomShift"
      via: "shift data structure"
      pattern: "AtomShift|h1_shifts|c13_shifts"
---

<objective>
Create the core NMReData generation module that produces NMReData-compliant SDF files from NMR calculation results.

Purpose: Enable machine-readable export of predicted NMR data in the standardized NMReData format. This is the foundational module that Phase 33 (API integration) will consume.

Output: New `src/qm_nmr_calc/nmredata.py` module with `generate_nmredata_sdf()` function and comprehensive unit tests.
</objective>

<execution_context>
@/home/chris/.claude/get-shit-done/workflows/execute-plan.md
@/home/chris/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/SUMMARY_v2.3.md
@.planning/research/NMREDATA_ARCHITECTURE.md
@src/qm_nmr_calc/models.py
@src/qm_nmr_calc/solvents.py
@src/qm_nmr_calc/api/routers/jobs.py (lines 655-745 for existing SDF generation pattern)
@tests/test_atom_ordering.py (for test pattern reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create nmredata.py module with tag infrastructure and solvent mapping</name>
  <files>src/qm_nmr_calc/nmredata.py, tests/test_nmredata.py</files>
  <action>
Create new module `src/qm_nmr_calc/nmredata.py` with:

1. Module constants:
   - `NMREDATA_VERSION = "1.1"` (stable version)
   - `NMREDATA_LEVEL = "0"` (predicted data, unambiguous assignments)
   - `NMREDATA_SEP = ", "` (comma + space separator, per spec)

2. Solvent mapping function `map_solvent_to_nmredata(solvent: str) -> str`:
   - Input: NWChem COSMO solvent name (lowercase from our system)
   - Output: NMReData solvent name (deuterated form)
   - Mapping:
     - "chcl3" -> "CDCl3"
     - "dmso" -> "(CD3)2SO" (per NMReData convention)
     - "vacuum" -> "vacuum" (no solvent)
   - Raise ValueError for unknown solvents

3. Helper function `format_atom_label(atom: str, index: int) -> str`:
   - Format: lowercase atom symbol + 1-indexed number
   - "H", 5 -> "h5" (for 1H)
   - "C", 3 -> "c3" (for 13C)
   - Use lowercase labels (cleaner than H5/C3)

4. Create initial test file `tests/test_nmredata.py` with:
   - Test class `TestSolventMapping` covering all three solvents and unknown solvent error
   - Test class `TestAtomLabel` covering H and C label formatting
   - Test that `NMREDATA_SEP` is exactly ", " (comma + space)
   - Test that `NMREDATA_VERSION` is "1.1"
   - Test that `NMREDATA_LEVEL` is "0"

Do NOT use the `get_solvent_display_name()` from solvents.py - it returns "CDCl3" for display but NMReData needs the exact mapping including "(CD3)2SO" for DMSO.
  </action>
  <verify>
```bash
cd /home/chris/develop/qm-nmr-calc && python -c "from qm_nmr_calc.nmredata import NMREDATA_VERSION, NMREDATA_LEVEL, NMREDATA_SEP, map_solvent_to_nmredata, format_atom_label; print('Module imports OK')"
cd /home/chris/develop/qm-nmr-calc && python -m pytest tests/test_nmredata.py -v --tb=short
```
  </verify>
  <done>
Module constants defined, solvent mapping works for all 3 solvents, atom label formatting works for H and C, all unit tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement ASSIGNMENT tag formatting with correct 1-indexed atoms</name>
  <files>src/qm_nmr_calc/nmredata.py, tests/test_nmredata.py</files>
  <action>
Add to `src/qm_nmr_calc/nmredata.py`:

1. Function `format_assignment_tag(h1_shifts: list, c13_shifts: list) -> str`:
   - Takes lists of shift dicts with keys: index (1-based from NWChem), atom, shift
   - Format each line as: `{label}, {shift:.4f}, {atom_index}`
   - Label: use `format_atom_label()` (e.g., "h5", "c3")
   - Shift: 4 decimal places (e.g., "7.2453")
   - Atom index: MUST be 1-indexed (our data is already 1-indexed from NWChem)
   - Join lines with `\n` (newline) - NMReData uses multiline format
   - Example output:
     ```
     h1, 7.2453, 1
     h2, 3.4521, 5
     c1, 128.4500, 2
     c2, 45.6789, 3
     ```

2. CRITICAL - Atom indexing verification:
   - Our AtomShift.index comes from NWChem which is already 1-based
   - Do NOT add +1 (would cause off-by-one error)
   - Do NOT convert to 0-based (would break NMReData)
   - Add docstring clearly stating: "Assumes input indices are 1-based (NWChem convention)"

3. Add tests to `tests/test_nmredata.py`:
   - Test class `TestAssignmentTag`:
     - Test with single H shift: verify format matches `h{idx}, {shift:.4f}, {idx}`
     - Test with single C shift: verify format matches `c{idx}, {shift:.4f}, {idx}`
     - Test with multiple shifts: verify newline separation
     - Test with empty lists: returns empty string
     - Test shift precision: verify 4 decimal places (7.25 -> 7.2500)
     - Test atom index is 1-based: first atom should be 1, not 0
     - Test separator is ", " (comma + space): use regex `r",(?! )"` to catch missing space

4. Use the separator constant `NMREDATA_SEP` for consistency:
   - Line format: `f"{label}{NMREDATA_SEP}{shift:.4f}{NMREDATA_SEP}{index}"`
  </action>
  <verify>
```bash
cd /home/chris/develop/qm-nmr-calc && python -m pytest tests/test_nmredata.py::TestAssignmentTag -v --tb=short
cd /home/chris/develop/qm-nmr-calc && python -c "
from qm_nmr_calc.nmredata import format_assignment_tag
# Test with sample data
h1_shifts = [{'index': 1, 'atom': 'H', 'shift': 7.2453}]
c13_shifts = [{'index': 2, 'atom': 'C', 'shift': 128.45}]
result = format_assignment_tag(h1_shifts, c13_shifts)
print(result)
# Verify 1-indexed
assert '1' in result.split()[0].split(',')[-1] or result.startswith('h1'), 'First H should reference atom 1'
print('1-indexed atom verification PASSED')
"
```
  </verify>
  <done>
ASSIGNMENT tag formatting works correctly with 1-indexed atoms, proper ", " separator, 4 decimal precision, and multiline format. Tests verify no off-by-one errors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement generate_nmredata_sdf() with all tags and ensemble support</name>
  <files>src/qm_nmr_calc/nmredata.py, tests/test_nmredata.py</files>
  <action>
Add the main generation function to `src/qm_nmr_calc/nmredata.py`:

1. Function signature:
```python
def generate_nmredata_sdf(
    smiles: str,
    geometry_xyz: str,  # XYZ file content as string
    h1_shifts: list[dict],  # [{"index": int, "atom": str, "shift": float}, ...]
    c13_shifts: list[dict],
    solvent: str,  # NWChem solvent name (chcl3, dmso, vacuum)
    temperature_k: float = 298.15,
    functional: str = "B3LYP",
    basis_set: str = "6-311+G(2d,p)",
    is_ensemble: bool = False,
    conformer_count: int | None = None,
) -> str:
    """Generate NMReData-formatted SDF file content.

    Args:
        smiles: Input SMILES string
        geometry_xyz: XYZ coordinate file content (optimized geometry)
        h1_shifts: 1H chemical shifts with 1-based atom indices
        c13_shifts: 13C chemical shifts with 1-based atom indices
        solvent: NWChem COSMO solvent name
        temperature_k: Temperature in Kelvin (for Boltzmann averaging)
        functional: DFT functional used
        basis_set: Basis set used
        is_ensemble: Whether shifts are Boltzmann-averaged
        conformer_count: Number of conformers (for ensemble metadata)

    Returns:
        Complete NMReData SDF file content as string
    """
```

2. Implementation steps (reuse pattern from jobs.py lines 935-965):
   a. Parse XYZ to extract coordinates
   b. Create RDKit Mol from SMILES with `Chem.MolFromSmiles()`
   c. Add explicit hydrogens with `Chem.AddHs()`
   d. Create Conformer and set 3D coordinates from XYZ
   e. Add conformer to mol with `mol.AddConformer()`
   f. Inject NMReData tags using `mol.SetProp()`:
      - `NMREDATA_VERSION` -> NMREDATA_VERSION constant
      - `NMREDATA_LEVEL` -> NMREDATA_LEVEL constant
      - `NMREDATA_SOLVENT` -> map_solvent_to_nmredata(solvent)
      - `NMREDATA_TEMPERATURE` -> f"{temperature_k:.2f}"
      - `NMREDATA_ASSIGNMENT` -> format_assignment_tag(h1_shifts, c13_shifts)
      - `NMREDATA_FORMULA` -> Chem.rdMolDescriptors.CalcMolFormula(mol)
      - `NMREDATA_SMILES` -> smiles (original input)
   g. Add provenance tag `NMREDATA_ID` with:
      - `Predicted by qm-nmr-calc`
      - `Method: {functional}/{basis_set}`
      - `Scaling: DELTA50`
      - If ensemble: `Boltzmann-averaged from {conformer_count} conformers at {temperature_k} K`
   h. Generate SDF content with `Chem.MolToMolBlock(mol)`
   i. Return SDF content

3. Error handling:
   - Raise ValueError if SMILES is invalid (MolFromSmiles returns None)
   - Raise ValueError if XYZ has wrong atom count
   - Log warning if XYZ atom count doesn't match Mol atom count

4. Add comprehensive tests to `tests/test_nmredata.py`:
   - Test class `TestGenerateNMReDataSDF`:
     - Test with ethanol (CCO): simple molecule, verify all 9 required tags present
     - Test tag parsing: parse output with RDKit SDMolSupplier, verify properties
     - Test MOL block: verify 3D coordinates are present (z != 0 for non-planar)
     - Test ASSIGNMENT content: verify H and C shifts appear with correct format
     - Test solvent mapping in output: chcl3 -> "CDCl3" in NMREDATA_SOLVENT
     - Test temperature tag: verify format "298.15" (2 decimal places)
     - Test ensemble mode: verify provenance includes conformer count
     - Test formula: verify NMREDATA_FORMULA contains correct formula
     - Test round-trip: export -> RDKit parse -> verify atom count matches

5. Use fixture for test data:
```python
@pytest.fixture
def ethanol_data():
    return {
        "smiles": "CCO",
        "geometry_xyz": \"\"\"9
ethanol optimized
C    0.0000    0.0000    0.0000
C    1.5000    0.0000    0.0000
O    2.0000    1.2000    0.0000
H   -0.3500   -0.5000   -0.9000
H   -0.3500   -0.5000    0.9000
H   -0.3500    1.0000    0.0000
H    1.8500   -0.5000   -0.9000
H    1.8500   -0.5000    0.9000
H    2.9000    1.2000    0.0000
\"\"\",
        "h1_shifts": [
            {"index": 4, "atom": "H", "shift": 1.18},
            {"index": 5, "atom": "H", "shift": 1.18},
            {"index": 6, "atom": "H", "shift": 1.18},
            {"index": 7, "atom": "H", "shift": 3.65},
            {"index": 8, "atom": "H", "shift": 3.65},
            {"index": 9, "atom": "H", "shift": 2.45},
        ],
        "c13_shifts": [
            {"index": 1, "atom": "C", "shift": 18.2},
            {"index": 2, "atom": "C", "shift": 58.3},
        ],
        "solvent": "chcl3",
    }
```
  </action>
  <verify>
```bash
cd /home/chris/develop/qm-nmr-calc && python -m pytest tests/test_nmredata.py -v --tb=short
cd /home/chris/develop/qm-nmr-calc && python -c "
from qm_nmr_calc.nmredata import generate_nmredata_sdf
from rdkit import Chem

# Generate NMReData for ethanol
smiles = 'CCO'
xyz = '''9
ethanol
C    0.0000    0.0000    0.0000
C    1.5000    0.0000    0.0000
O    2.0000    1.2000    0.0000
H   -0.3500   -0.5000   -0.9000
H   -0.3500   -0.5000    0.9000
H   -0.3500    1.0000    0.0000
H    1.8500   -0.5000   -0.9000
H    1.8500   -0.5000    0.9000
H    2.9000    1.2000    0.0000
'''
h1 = [{'index': 4, 'atom': 'H', 'shift': 1.18}]
c13 = [{'index': 1, 'atom': 'C', 'shift': 18.2}]

sdf = generate_nmredata_sdf(smiles, xyz, h1, c13, 'chcl3')
print('=== Generated NMReData SDF ===')
print(sdf[:1000])  # First 1000 chars
print('...')

# Verify all required tags present
required_tags = ['NMREDATA_VERSION', 'NMREDATA_LEVEL', 'NMREDATA_SOLVENT',
                 'NMREDATA_TEMPERATURE', 'NMREDATA_ASSIGNMENT',
                 'NMREDATA_FORMULA', 'NMREDATA_SMILES', 'NMREDATA_ID']
for tag in required_tags:
    assert tag in sdf, f'Missing required tag: {tag}'
print(f'All {len(required_tags)} required tags present!')

# Verify RDKit can parse it
# Note: MolToMolBlock doesn't include tags, need to use SDWriter for full SDF
# For now just verify the MOL block is valid
assert 'M  END' in sdf, 'MOL block missing M  END'
print('MOL block valid!')
"
```
  </verify>
  <done>
`generate_nmredata_sdf()` produces complete NMReData-compliant SDF with all 9 required tags (VERSION, LEVEL, SOLVENT, TEMPERATURE, ASSIGNMENT, FORMULA, SMILES, ID/provenance). Ensemble mode includes conformer metadata. All tests pass including round-trip RDKit parsing.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Run full test suite:
```bash
cd /home/chris/develop/qm-nmr-calc && python -m pytest tests/test_nmredata.py -v --tb=short
```

2. Verify module exports:
```bash
python -c "from qm_nmr_calc.nmredata import generate_nmredata_sdf, NMREDATA_VERSION, NMREDATA_SEP, map_solvent_to_nmredata, format_assignment_tag, format_atom_label; print('All exports available')"
```

3. Verify no regression in existing tests:
```bash
cd /home/chris/develop/qm-nmr-calc && python -m pytest tests/ -v --tb=short -x
```

4. Code quality check:
```bash
cd /home/chris/develop/qm-nmr-calc && python -m ruff check src/qm_nmr_calc/nmredata.py
```
</verification>

<success_criteria>
1. New module `src/qm_nmr_calc/nmredata.py` exists with all required functions
2. `generate_nmredata_sdf()` returns valid SDF string containing all 9 NMReData tags
3. Atom indices in ASSIGNMENT tag are 1-indexed (verified by tests)
4. Solvent mapping works for all 3 supported solvents (chcl3, dmso, vacuum)
5. Separator is ", " (comma + space) throughout
6. Ensemble mode includes Boltzmann averaging metadata
7. All unit tests pass (>15 tests covering critical paths)
8. Existing test suite still passes (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/32-core-nmredata-module/32-01-SUMMARY.md` using the summary template.

Include:
- Key implementation decisions (tag format, atom indexing approach)
- Files created/modified with line counts
- Test coverage summary
- Any deviations from plan or discovered issues
</output>
