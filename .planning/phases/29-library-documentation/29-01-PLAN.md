---
phase: 29-library-documentation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - docs/libraries.md
autonomous: true

must_haves:
  truths:
    - "Developer can understand how RDKit is used for SMILES validation"
    - "Developer can understand how RDKit generates conformers using KDG"
    - "Developer can understand how NWChem input files are generated"
    - "Developer can understand how NWChem output is parsed for shielding values"
    - "Developer can understand how Huey task queue is configured and used"
  artifacts:
    - path: "docs/libraries.md"
      provides: "Python library integration documentation"
      contains: "## RDKit"
      min_lines: 200
  key_links:
    - from: "docs/libraries.md"
      to: "src/qm_nmr_calc/validation.py"
      via: "code example reference"
      pattern: "validation.py"
    - from: "docs/libraries.md"
      to: "src/qm_nmr_calc/nwchem/"
      via: "code example reference"
      pattern: "nwchem/"
---

<objective>
Document Python library integrations (RDKit, NWChem, Huey) in docs/libraries.md with code examples extracted from the codebase.

Purpose: Enable developers and contributors to understand how core Python libraries are integrated into the QM NMR Calculator.

Output: First half of docs/libraries.md covering RDKit, NWChem, and Huey with actual code patterns from the codebase.
</objective>

<execution_context>
@/home/chris/.claude/get-shit-done/workflows/execute-plan.md
@/home/chris/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/29-library-documentation/29-RESEARCH.md

# Source files for code examples
@src/qm_nmr_calc/validation.py
@src/qm_nmr_calc/conformers/generator.py
@src/qm_nmr_calc/visualization.py
@src/qm_nmr_calc/nwchem/input_gen.py
@src/qm_nmr_calc/nwchem/output_parser.py
@src/qm_nmr_calc/queue.py
@src/qm_nmr_calc/tasks.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: RDKit Integration Documentation</name>
  <files>docs/libraries.md</files>
  <action>
Replace the placeholder content in docs/libraries.md with comprehensive library documentation.

**Introduction** (~15 lines)
- Overview: This guide documents how third-party libraries are integrated into QM NMR Calculator
- Target audience: developers and contributors
- Approach: Code examples are from the actual codebase (not generic library usage)
- Link to official library docs for comprehensive API reference

**RDKit Section** (~80 lines) - LIB-01

1. **Overview**
   - Purpose: SMILES parsing, conformer generation, 2D visualization
   - Integration points table:
     | Module | Functions | Purpose |
     |--------|-----------|---------|
     | `validation.py` | `validate_smiles()`, `validate_mol_file()` | Input validation |
     | `conformers/generator.py` | `generate_conformers_kdg()`, `optimize_conformers_mmff()` | 3D structure |
     | `visualization.py` | `generate_annotated_structure()` | 2D depiction |
     | `nwchem/geometry.py` | `smiles_to_xyz()`, `mol_to_xyz_block()` | XYZ conversion |

2. **SMILES Validation**
   - Explain the validate_smiles() pattern from validation.py
   - Show code example (from RESEARCH.md lines 223-234)
   - Note: RDLogger suppression to capture meaningful errors

3. **Conformer Generation (KDG)**
   - Explain why KDG instead of ETKDG (avoid crystal packing bias for solution-phase NMR)
   - Show code example (from RESEARCH.md lines 240-261)
   - Document key parameters: randomSeed, numThreads, pruneRmsThresh
   - Note: useRandomCoords fallback for difficult molecules

4. **2D Structure Drawing**
   - Explain annotated structure generation with shift labels
   - Show code example (from RESEARCH.md lines 266-288)
   - CRITICAL: atomNote must be set BEFORE PrepareMolForDrawing

Include source file paths for all code examples.
  </action>
  <verify>
```bash
# Verify RDKit section exists
grep -E "^## RDKit" docs/libraries.md

# Verify integration points table
grep -E "validation.py.*validate_smiles" docs/libraries.md

# Verify code examples present
grep -c "```python" docs/libraries.md
# Should have at least 3 code blocks

# Verify KDG explanation
grep -E "KDG|ETKDG|crystal" docs/libraries.md
```
  </verify>
  <done>
RDKit section added with:
- Integration points table
- SMILES validation code example
- KDG conformer generation code example with rationale
- 2D structure drawing code example
- Source file references throughout
  </done>
</task>

<task type="auto">
  <name>Task 2: NWChem Integration Documentation</name>
  <files>docs/libraries.md</files>
  <action>
Append NWChem integration section to docs/libraries.md:

**NWChem Section** (~80 lines) - LIB-02

1. **Overview**
   - Purpose: DFT geometry optimization and NMR shielding calculations
   - Integration points table:
     | Module | Functions | Purpose |
     |--------|-----------|---------|
     | `nwchem/input_gen.py` | `generate_optimization_input()`, `generate_nmr_input()` | Input file creation |
     | `nwchem/output_parser.py` | `parse_shielding_output()`, `parse_energy()` | Result extraction |
     | `nwchem/runner.py` | `run_nwchem()` | Subprocess execution |
     | `nwchem/geometry.py` | `extract_optimized_geometry()` | Geometry extraction |

2. **Input File Generation**
   - Explain the template-based approach
   - Show optimization input code example (from RESEARCH.md lines 293-324)
   - Key sections: memory, geometry, basis, dft, driver, cosmo
   - Note: COSMO block only for non-vacuum solvents

3. **Output Parsing**
   - Explain regex-based parsing approach
   - Show shielding output parser code example (from RESEARCH.md lines 330-349)
   - Pattern explanation: Atom block -> isotropic value extraction
   - Note: 1-based atom indices from NWChem

4. **Why Direct Integration**
   - Originally used ISiCLE wrapper (v1.0)
   - Changed to direct NWChem calls (v2.0) for:
     - Better error handling and recovery
     - Fine-grained control over input parameters
     - Clearer debugging (raw .out files available)
   - Link to scratch directory explanation in architecture.md

Include source file paths for all code examples.
  </action>
  <verify>
```bash
# Verify NWChem section exists
grep -E "^## NWChem" docs/libraries.md

# Verify input generation code example
grep -E "generate_optimization_input|geometry units angstrom" docs/libraries.md

# Verify output parsing code example
grep -E "parse_shielding_output|isotropic" docs/libraries.md

# Verify integration points table
grep -E "nwchem/input_gen.py" docs/libraries.md
```
  </verify>
  <done>
NWChem section added with:
- Integration points table
- Input file generation code example
- Output parsing code example
- ISiCLE to direct integration rationale
- Source file references throughout
  </done>
</task>

<task type="auto">
  <name>Task 3: Huey Integration Documentation</name>
  <files>docs/libraries.md</files>
  <action>
Append Huey task queue section to docs/libraries.md:

**Huey Task Queue Section** (~60 lines) - LIB-03

1. **Overview**
   - Purpose: Async job processing with SQLite persistence
   - Integration points table:
     | Module | Components | Purpose |
     |--------|------------|---------|
     | `queue.py` | `huey` instance, signal handlers | Queue configuration |
     | `tasks.py` | `run_nmr_task()` | Task definition |
   - Why Huey over Celery: Simpler deployment, SQLite backend (no Redis), single-process consumer works fine for computational tasks

2. **Queue Configuration**
   - Show queue setup code example (from RESEARCH.md lines 355-379)
   - Explain SqliteHuey with fsync for durability
   - Document signal handlers:
     - SIGNAL_EXECUTING: Mark job as running
     - SIGNAL_COMPLETE: Mark job as complete, trigger notifications
     - SIGNAL_ERROR: Mark job as failed with error message

3. **Task Definition**
   - Show task decorator pattern (from RESEARCH.md lines 385-406)
   - Explain step tracking via callbacks
   - Pattern: Update job status.json at each pipeline stage
   - Note: job_id is first argument (used by signal handlers)

4. **Consumer Operations**
   - How to start: `huey_consumer qm_nmr_calc.queue.huey`
   - Useful flags: `-w N` for workers, `-k thread` for threading
   - Note: Single worker recommended for NWChem (MPI processes)

Include source file paths for all code examples.

After completing Huey section, commit the Python libraries documentation.
  </action>
  <verify>
```bash
# Verify Huey section exists
grep -E "^## Huey" docs/libraries.md

# Verify queue configuration code example
grep -E "SqliteHuey|SIGNAL_EXECUTING" docs/libraries.md

# Verify task definition code example
grep -E "@huey.task|run_nmr_task" docs/libraries.md

# Verify consumer section
grep -E "huey_consumer" docs/libraries.md

# Line count check
wc -l docs/libraries.md
# Should be around 200+ lines at this point
```
  </verify>
  <done>
Huey section added with:
- Integration points table
- Queue configuration code example
- Signal handler documentation
- Task definition code example
- Consumer operation instructions
- Source file references throughout

Python library documentation (RDKit, NWChem, Huey) complete.
  </done>
</task>

</tasks>

<verification>
- [ ] Introduction section explains documentation approach
- [ ] RDKit section covers SMILES validation, conformer generation, 2D drawing (LIB-01)
- [ ] NWChem section covers input generation and output parsing (LIB-02)
- [ ] Huey section covers queue config and task definition (LIB-03)
- [ ] All code examples from actual codebase with source file references
- [ ] Integration points tables for each library
- [ ] At least 6 Python code blocks
- [ ] docs/libraries.md is 200+ lines
</verification>

<success_criteria>
- LIB-01: RDKit usage documented with SMILES, conformer, and visualization examples
- LIB-02: NWChem integration documented with input generation and output parsing
- LIB-03: Huey task queue documented with configuration and signal handlers
- All code examples reference actual source files
</success_criteria>

<output>
After completion, create `.planning/phases/29-library-documentation/29-01-SUMMARY.md`
</output>
