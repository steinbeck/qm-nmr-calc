---
phase: 47-lifecycle-management-scripts
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - gcp/stop-vm.sh
  - gcp/start-vm.sh
  - gcp/delete-vm.sh
  - gcp/status-vm.sh
  - gcp/ssh-vm.sh
  - gcp/logs-vm.sh
autonomous: true

must_haves:
  truths:
    - "User can stop a running VM with one command"
    - "User can start a stopped VM with one command"
    - "User can delete a VM while preserving persistent disk"
    - "User can see VM state and IP address"
    - "User can SSH into VM without remembering gcloud syntax"
    - "User can stream container logs without remembering docker commands"
    - "Scripts remember VM name and zone between commands"
  artifacts:
    - path: "gcp/stop-vm.sh"
      provides: "Stop VM command"
      contains: "gcloud compute instances stop"
      min_lines: 40
    - path: "gcp/start-vm.sh"
      provides: "Start VM command"
      contains: "gcloud compute instances start"
      min_lines: 40
    - path: "gcp/delete-vm.sh"
      provides: "Delete VM command with confirmation"
      contains: "gcloud compute instances delete"
      min_lines: 50
    - path: "gcp/status-vm.sh"
      provides: "VM status display"
      contains: "gcloud compute instances describe"
      min_lines: 50
    - path: "gcp/ssh-vm.sh"
      provides: "SSH wrapper"
      contains: "gcloud compute ssh"
      min_lines: 40
    - path: "gcp/logs-vm.sh"
      provides: "Container logs streaming"
      contains: "docker compose.*logs"
      min_lines: 45
  key_links:
    - from: "gcp/*.sh"
      to: "gcp/config.sh"
      via: "source ./config.sh"
      pattern: "source.*config\\.sh"
    - from: "gcp/*.sh"
      to: "RESOURCE_PREFIX variable"
      via: "VM name derivation"
      pattern: "\\$\\{RESOURCE_PREFIX\\}-vm"
---

<objective>
Create lifecycle management scripts for GCP Spot VM so users can stop, start, delete, check status, SSH, and view logs without memorizing gcloud commands.

Purpose: Satisfy LIFE-01 through LIFE-07 requirements by providing simple wrapper scripts that source config.sh and use consistent patterns from Phase 46.

Output: Six executable bash scripts in gcp/ directory following established patterns from deploy-vm.sh and setup-infrastructure.sh.
</objective>

<execution_context>
@/Users/steinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/steinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/46-vm-deployment-script/46-01-SUMMARY.md

# Existing patterns to follow
@gcp/deploy-vm.sh (source config.sh, color output, gcloud auth check, RESOURCE_PREFIX)
@gcp/config.sh.example (GCP_PROJECT_ID, GCP_REGION, GCP_ZONE, RESOURCE_PREFIX)
@gcp/setup-infrastructure.sh (idempotent checks, echo_info/echo_warn/echo_error)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create core lifecycle scripts (stop, start, delete, status)</name>
  <files>
    gcp/stop-vm.sh
    gcp/start-vm.sh
    gcp/delete-vm.sh
    gcp/status-vm.sh
  </files>
  <action>
Create four lifecycle scripts following patterns from deploy-vm.sh:

**gcp/stop-vm.sh** (LIFE-01):
- Shebang, set -euo pipefail
- Source config.sh (with error if missing)
- Color functions: echo_info, echo_warn, echo_error
- Check gcloud authentication
- Derive VM_NAME from RESOURCE_PREFIX
- Check if VM exists (gcloud compute instances describe)
- Check current status - skip if already TERMINATED
- Run: gcloud compute instances stop "$VM_NAME" --zone="$GCP_ZONE" --quiet
- Display success message with billing note

**gcp/start-vm.sh** (LIFE-02):
- Same boilerplate as stop-vm.sh
- Check if VM exists
- Check current status - skip if already RUNNING
- Run: gcloud compute instances start "$VM_NAME" --zone="$GCP_ZONE" --quiet
- Wait for startup (echo message about 2-3 min startup time)
- Display IP address after start

**gcp/delete-vm.sh** (LIFE-03):
- Same boilerplate
- Check if VM exists (exit gracefully if not)
- Require explicit "yes" confirmation (like teardown-infrastructure.sh)
- Explain that persistent disk is preserved
- Run: gcloud compute instances delete "$VM_NAME" --zone="$GCP_ZONE" --quiet
- Do NOT delete persistent disk (that stays for data preservation)
- Display success message noting disk preservation

**gcp/status-vm.sh** (LIFE-04):
- Same boilerplate
- Check if VM exists (show "VM not found" if missing)
- Get VM status: gcloud compute instances describe --format="value(status)"
- Get external IP: gcloud compute instances describe --format="value(networkInterfaces[0].accessConfigs[0].natIP)"
- Display formatted status table:
  - VM Name
  - Zone
  - Status (RUNNING/TERMINATED/STAGING/etc)
  - External IP (or "N/A" if stopped)
  - Machine Type
- If RUNNING, show how to access (https://DOMAIN or SSH command)

All scripts must:
- Be executable (chmod +x)
- Use consistent color output
- Handle missing VM gracefully
- Use GCP_ZONE from config.sh (not SELECTED_ZONE which is deploy-time only)
  </action>
  <verify>
```bash
cd /Users/steinbeck/Dropbox/develop/qm-nmr-calc/gcp

# Files exist
ls -la stop-vm.sh start-vm.sh delete-vm.sh status-vm.sh

# Executable
test -x stop-vm.sh && test -x start-vm.sh && test -x delete-vm.sh && test -x status-vm.sh && echo "All executable"

# Syntax check
bash -n stop-vm.sh && bash -n start-vm.sh && bash -n delete-vm.sh && bash -n status-vm.sh && echo "Syntax OK"

# Key patterns present
grep -l "source.*config.sh" stop-vm.sh start-vm.sh delete-vm.sh status-vm.sh | wc -l  # Should be 4
grep -l "RESOURCE_PREFIX" stop-vm.sh start-vm.sh delete-vm.sh status-vm.sh | wc -l  # Should be 4
grep "gcloud compute instances stop" stop-vm.sh
grep "gcloud compute instances start" start-vm.sh
grep "gcloud compute instances delete" delete-vm.sh
grep "gcloud compute instances describe" status-vm.sh
```
  </verify>
  <done>
Four scripts exist, are executable, pass bash syntax check, source config.sh, use RESOURCE_PREFIX for VM name, and contain correct gcloud commands.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create access scripts (ssh, logs)</name>
  <files>
    gcp/ssh-vm.sh
    gcp/logs-vm.sh
  </files>
  <action>
Create two access scripts following same patterns:

**gcp/ssh-vm.sh** (LIFE-05):
- Same boilerplate (config.sh, colors, auth check)
- Check if VM exists
- Check if VM is RUNNING (can't SSH to stopped VM)
- Support optional command argument: `./ssh-vm.sh "ls -la"`
- If no args: gcloud compute ssh "$VM_NAME" --zone="$GCP_ZONE"
- If args: gcloud compute ssh "$VM_NAME" --zone="$GCP_ZONE" --command="$*"
- Handle SSH key prompts gracefully (gcloud handles this)

**gcp/logs-vm.sh** (LIFE-06):
- Same boilerplate
- Check if VM exists
- Check if VM is RUNNING
- Support optional service filter: `./logs-vm.sh worker` or `./logs-vm.sh api`
- Default: stream all logs with follow
- Command: gcloud compute ssh "$VM_NAME" --zone="$GCP_ZONE" --command="docker compose -f /opt/qm-nmr-calc/docker-compose.yml -f /opt/qm-nmr-calc/docker-compose.gcp.yml logs -f $SERVICE"
- If service specified: append service name to logs command
- Show usage hint in script header

Both scripts must:
- Be executable
- Check VM is running before attempting connection
- Use the two compose files (main + gcp override) that are deployed to VM
  </action>
  <verify>
```bash
cd /Users/steinbeck/Dropbox/develop/qm-nmr-calc/gcp

# Files exist and executable
ls -la ssh-vm.sh logs-vm.sh
test -x ssh-vm.sh && test -x logs-vm.sh && echo "Executable"

# Syntax check
bash -n ssh-vm.sh && bash -n logs-vm.sh && echo "Syntax OK"

# Key patterns
grep "gcloud compute ssh" ssh-vm.sh
grep "docker compose.*logs" logs-vm.sh
grep "source.*config.sh" ssh-vm.sh logs-vm.sh | wc -l  # Should be 2
```
  </verify>
  <done>
SSH and logs scripts exist, are executable, pass syntax check, source config.sh, and contain correct gcloud/docker commands.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify complete lifecycle management</name>
  <files>None (verification only)</files>
  <action>
Run comprehensive verification of all six scripts:

1. Verify all scripts exist with correct permissions
2. Verify all scripts pass bash syntax check
3. Verify all scripts source config.sh
4. Verify each script contains its key gcloud/docker command
5. Verify consistent patterns across all scripts:
   - Color functions (echo_info, echo_warn, echo_error)
   - Auth check pattern
   - VM existence check pattern
   - VM_NAME derivation from RESOURCE_PREFIX
6. Count total lines to ensure scripts are substantial (not stubs)

Note: This is local validation only - no actual GCP operations are performed.
  </action>
  <verify>
```bash
cd /Users/steinbeck/Dropbox/develop/qm-nmr-calc/gcp

echo "=== File existence and permissions ==="
ls -la stop-vm.sh start-vm.sh delete-vm.sh status-vm.sh ssh-vm.sh logs-vm.sh

echo ""
echo "=== Syntax validation ==="
for f in stop-vm.sh start-vm.sh delete-vm.sh status-vm.sh ssh-vm.sh logs-vm.sh; do
  bash -n "$f" && echo "$f: OK" || echo "$f: FAIL"
done

echo ""
echo "=== Config sourcing (all 6 should source config.sh) ==="
grep -l "source.*config.sh" stop-vm.sh start-vm.sh delete-vm.sh status-vm.sh ssh-vm.sh logs-vm.sh | wc -l

echo ""
echo "=== Color functions present ==="
grep -l "echo_info" stop-vm.sh start-vm.sh delete-vm.sh status-vm.sh ssh-vm.sh logs-vm.sh | wc -l

echo ""
echo "=== Key commands ==="
grep "gcloud compute instances stop" stop-vm.sh
grep "gcloud compute instances start" start-vm.sh
grep "gcloud compute instances delete" delete-vm.sh
grep "gcloud compute instances describe" status-vm.sh
grep "gcloud compute ssh" ssh-vm.sh
grep "docker compose.*logs" logs-vm.sh

echo ""
echo "=== Line counts (each should be 40+ lines) ==="
wc -l stop-vm.sh start-vm.sh delete-vm.sh status-vm.sh ssh-vm.sh logs-vm.sh
```
  </verify>
  <done>
All six lifecycle scripts validated: exist, executable, syntax OK, source config.sh, contain required commands, use consistent patterns, and are substantial implementations (not stubs).
  </done>
</task>

</tasks>

<verification>
**Local Verification (no GCP required):**
1. All 6 scripts exist in gcp/ directory
2. All 6 scripts are executable (chmod +x)
3. All 6 scripts pass `bash -n` syntax check
4. All 6 scripts source config.sh
5. All 6 scripts use RESOURCE_PREFIX for VM name
6. Each script contains its specific gcloud command
7. Scripts are substantial (40+ lines each, not stubs)

**Functional Verification (requires deployed VM):**
- `./status-vm.sh` shows VM state and IP
- `./stop-vm.sh` stops VM, status changes to TERMINATED
- `./start-vm.sh` starts VM, status changes to RUNNING
- `./ssh-vm.sh` opens SSH connection
- `./logs-vm.sh` streams container logs
- `./delete-vm.sh` removes VM, disk preserved
</verification>

<success_criteria>
- LIFE-01: stop-vm.sh exists with `gcloud compute instances stop`
- LIFE-02: start-vm.sh exists with `gcloud compute instances start`
- LIFE-03: delete-vm.sh exists with `gcloud compute instances delete` and confirmation prompt
- LIFE-04: status-vm.sh exists with `gcloud compute instances describe` showing status and IP
- LIFE-05: ssh-vm.sh exists with `gcloud compute ssh`
- LIFE-06: logs-vm.sh exists with `docker compose logs`
- LIFE-07: All scripts source config.sh which provides VM name and zone persistence
</success_criteria>

<output>
After completion, create `.planning/phases/47-lifecycle-management-scripts/47-01-SUMMARY.md`
</output>
