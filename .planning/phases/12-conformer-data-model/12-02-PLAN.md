---
phase: 12-conformer-data-model
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/qm_nmr_calc/atom_ordering.py
  - tests/test_atom_ordering.py
autonomous: true

must_haves:
  truths:
    - "Given a SMILES string, the system produces a canonical atom index mapping"
    - "The canonical ordering is deterministic -- same SMILES always produces same mapping"
    - "The mapping correctly handles implicit-to-explicit hydrogen addition"
    - "Atom indices in the mapping match what NWChem will see in XYZ input"
    - "The ordering is stable across RDKit conformer generation (different 3D coords, same atom order)"
  artifacts:
    - path: "src/qm_nmr_calc/atom_ordering.py"
      provides: "Canonical atom ordering functions"
      exports: ["canonical_atom_order", "map_nwchem_to_canonical"]
    - path: "tests/test_atom_ordering.py"
      provides: "TDD tests for atom ordering"
      contains: "test_canonical_order_deterministic"
  key_links:
    - from: "src/qm_nmr_calc/atom_ordering.py"
      to: "rdkit"
      via: "RDKit Chem.MolFromSmiles, Chem.AddHs, CanonicalRankAtoms"
      pattern: "Chem\\.MolFromSmiles|CanonicalRankAtoms"
---

<objective>
Implement canonical atom ordering using TDD to ensure atom indices remain consistent across the conformer lifecycle (generation -> optimization -> NMR parsing).

Purpose: Atom ordering is a critical correctness concern (Pitfall 4 from research). When RDKit generates conformers and NWChem optimizes them, atom indices must map back to the original SMILES atoms for correct shift assignment. Getting this wrong silently produces incorrect NMR predictions.

Output: Tested atom_ordering.py module with canonical_atom_order() and map_nwchem_to_canonical() functions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md

@src/qm_nmr_calc/nwchem/geometry.py
@src/qm_nmr_calc/tasks.py
</context>

<feature>
  <name>Canonical Atom Ordering</name>
  <files>src/qm_nmr_calc/atom_ordering.py, tests/test_atom_ordering.py</files>
  <behavior>
The atom ordering module provides two key functions:

1. `canonical_atom_order(smiles: str) -> list[int]`
   - Takes a SMILES string
   - Creates RDKit mol, adds explicit hydrogens
   - Returns a list where position i contains the canonical rank of atom i
   - Uses RDKit's `Chem.CanonicalRankAtoms(mol)` for deterministic ordering
   - This ordering is the "ground truth" -- all conformer data references these indices

2. `map_nwchem_to_canonical(smiles: str) -> dict[int, int]`
   - Returns mapping from 1-based NWChem atom index to canonical atom index
   - NWChem uses the atom order from the XYZ file (which comes from RDKit)
   - Key insight: RDKit's atom ordering after AddHs is deterministic for a given SMILES
   - So the mapping is: nwchem_1based_index -> canonical_rank

3. `get_atom_count(smiles: str) -> tuple[int, int, int]`
   - Returns (total_atoms, num_h, num_heavy) for a given SMILES
   - Useful for validation that atom counts match across conformer lifecycle

Test cases (input -> expected behavior):
- "C" (methane): 5 atoms (1C + 4H), deterministic ordering
- "CCO" (ethanol): 9 atoms (2C + 1O + 6H), canonical ordering stable
- "c1ccccc1" (benzene): 12 atoms (6C + 6H), symmetric molecule handled
- Same SMILES called twice produces identical output (determinism)
- Different valid SMILES for same molecule produce same canonical ordering
  (e.g., "CCO" and "OCC" should produce equivalent mappings)
  </behavior>
  <implementation>
Use RDKit's built-in canonical ranking:
- `Chem.MolFromSmiles(smiles)` to parse
- `Chem.AddHs(mol)` to make hydrogens explicit
- `Chem.CanonicalRankAtoms(mol)` for canonical ordering
- The 1-based NWChem index is simply (rdkit_0based_index + 1)

Important: Do NOT use `Chem.RenumberAtoms()` to physically reorder -- that changes the mol object and breaks downstream RDKit operations. Instead, keep the mapping as metadata that translates between RDKit/NWChem indices and canonical indices.

The module should be pure functions with no side effects, no file I/O.
  </implementation>
</feature>

<verification>
1. `python -m pytest tests/test_atom_ordering.py -v` -- all tests pass
2. `python -c "from qm_nmr_calc.atom_ordering import canonical_atom_order, map_nwchem_to_canonical; print(canonical_atom_order('CCO')); print(map_nwchem_to_canonical('CCO'))"` -- outputs valid mappings
3. Determinism check: running canonical_atom_order('CCO') 100 times produces identical results
</verification>

<success_criteria>
- canonical_atom_order() returns deterministic canonical rankings for any valid SMILES
- map_nwchem_to_canonical() correctly maps 1-based NWChem indices to canonical ranks
- Same molecule with different SMILES representations produces equivalent canonical ordering
- Symmetric molecules (benzene) handled correctly
- All tests written before implementation (TDD red-green-refactor)
</success_criteria>

<output>
After completion, create `.planning/phases/12-conformer-data-model/12-02-SUMMARY.md`
</output>
