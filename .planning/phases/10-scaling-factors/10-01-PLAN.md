---
phase: 10-scaling-factors
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/qm_nmr_calc/benchmark/analysis.py
  - src/qm_nmr_calc/benchmark/models.py
  - src/qm_nmr_calc/benchmark/__init__.py
autonomous: true

must_haves:
  truths:
    - "OLS regression derives slope and intercept from shielding-shift pairs"
    - "Outliers are identified and excluded based on residual threshold"
    - "Statistics include R-squared, MAE, RMSD, and confidence intervals"
    - "ScalingFactor model captures all required metadata"
  artifacts:
    - path: "src/qm_nmr_calc/benchmark/analysis.py"
      provides: "Data aggregation and regression functions"
      min_lines: 150
    - path: "src/qm_nmr_calc/benchmark/models.py"
      provides: "ScalingFactor Pydantic model"
      contains: "class ScalingFactor"
  key_links:
    - from: "analysis.py"
      to: "data_loader.py"
      via: "load_experimental_shifts()"
      pattern: "load_experimental_shifts"
    - from: "analysis.py"
      to: "statsmodels"
      via: "sm.OLS"
      pattern: "sm\\.OLS"
---

<objective>
Create the analysis module for deriving NMR scaling factors from DELTA50 benchmark data.

Purpose: Enable linear regression of calculated shielding values against experimental chemical shifts to derive empirical scaling factors that improve prediction accuracy over simple TMS referencing.

Output:
- analysis.py with data aggregation and OLS regression functions
- ScalingFactor Pydantic model for storing factor metadata
- Core infrastructure for Phase 10 Plan 2 to generate reports
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-scaling-factors/10-CONTEXT.md
@.planning/phases/10-scaling-factors/10-RESEARCH.md
@src/qm_nmr_calc/benchmark/models.py
@src/qm_nmr_calc/benchmark/data_loader.py
@src/qm_nmr_calc/benchmark/runner.py
@data/benchmark/delta50/experimental_shifts.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ScalingFactor model to benchmark/models.py</name>
  <files>src/qm_nmr_calc/benchmark/models.py</files>
  <action>
Add a ScalingFactor Pydantic model to store derived scaling factor metadata.

Fields required (from RESEARCH.md):
- slope: float
- intercept: float
- r_squared: float
- mae: float (mean absolute error)
- rmsd: float (root mean square deviation)
- n_points: int (number of data points used)
- ci_slope: tuple[float, float] (95% confidence interval for slope)
- ci_intercept: tuple[float, float] (95% confidence interval for intercept)
- mae_ci: tuple[float, float] | None (bootstrap CI for MAE)
- rmsd_ci: tuple[float, float] | None (bootstrap CI for RMSD)
- outliers_removed: int = 0

Also add a RegressionData model to hold aggregated data:
- compound: str
- atom_idx: int
- nucleus: str (1H or 13C)
- shielding: float
- exp_shift: float

Export both models in __init__.py.
  </action>
  <verify>
python -c "from qm_nmr_calc.benchmark.models import ScalingFactor, RegressionData; print('Models imported successfully')"
  </verify>
  <done>
ScalingFactor and RegressionData models exist with all required fields, importable from benchmark.models.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create analysis.py with data aggregation and regression</name>
  <files>src/qm_nmr_calc/benchmark/analysis.py, src/qm_nmr_calc/benchmark/__init__.py</files>
  <action>
Create analysis.py in the benchmark module with these functions:

1. **aggregate_regression_data(functional: str, solvent: str) -> pd.DataFrame**
   - Load experimental_shifts.json via data_loader.load_experimental_shifts()
   - For each molecule with assignments (h1_assignments, c13_assignments):
     - Load shifts.json from results/{mol_id}/{functional}_{solvent}/
     - Pair calculated shielding with experimental shift using atom index mapping
   - Return DataFrame with columns: compound, atom_idx, nucleus, shielding, exp_shift
   - CRITICAL: Use atom index from h1_assignments/c13_assignments keys to find matching shielding value in shielding_data["index"]
   - Skip molecules without assignments or without shifts.json

2. **fit_scaling_factors(df: pd.DataFrame, nucleus: str, threshold: float = 3.0) -> ScalingFactor**
   - Filter DataFrame to specified nucleus (1H or 13C)
   - Use statsmodels OLS: y=exp_shift, X=sm.add_constant(shielding)
   - Initial fit, calculate residuals, identify outliers (|residual| > threshold * std)
   - Refit without outliers
   - Extract: slope, intercept, R^2, confidence intervals via results.conf_int()
   - Calculate MAE and RMSD from residuals
   - Return populated ScalingFactor model

3. **derive_all_factors() -> dict[str, ScalingFactor]**
   - Iterate over: functionals=["B3LYP"], solvents=["CHCl3", "DMSO"], nuclei=["1H", "13C"]
   - Generate key: f"{functional}/6-311+G(2d,p)/{nucleus}/{solvent}"
   - Call aggregate_regression_data and fit_scaling_factors for each combination
   - Return dict mapping key to ScalingFactor

4. **get_factor_key(functional: str, basis_set: str, nucleus: str, solvent: str) -> str**
   - Return f"{functional}/{basis_set}/{nucleus}/{solvent}"

Implementation notes:
- Import: statsmodels.api as sm, numpy as np, pandas as pd, orjson
- Use get_results_dir() from runner.py for results path
- Handle missing shifts.json gracefully (skip molecule, log warning)
- The experimental data uses string keys for atom indices in assignments
- Shielding data index array contains integers

Update __init__.py to export: derive_all_factors, fit_scaling_factors, aggregate_regression_data, get_factor_key
  </action>
  <verify>
python -c "
from qm_nmr_calc.benchmark.analysis import aggregate_regression_data
import pandas as pd
df = aggregate_regression_data('B3LYP', 'CHCl3')
print(f'Aggregated {len(df)} data points')
print(f'1H: {len(df[df.nucleus==\"1H\"])} points')
print(f'13C: {len(df[df.nucleus==\"13C\"])} points')
print(df.head())
"
  </verify>
  <done>
analysis.py exists with all four functions. aggregate_regression_data returns DataFrame with shielding-shift pairs. Functions are exported from benchmark.__init__.py.
  </done>
</task>

<task type="auto">
  <name>Task 3: Test factor derivation end-to-end</name>
  <files>src/qm_nmr_calc/benchmark/analysis.py</files>
  <action>
Run derive_all_factors() and verify output:
- Should produce 4 ScalingFactor objects (B3LYP with 1H-CHCl3, 1H-DMSO, 13C-CHCl3, 13C-DMSO)
- Print key statistics for each factor
- Verify R^2 > 0.99 (expected for well-behaved NMR regression)
- Verify slope is negative (shielding decreases as shift increases)
- Verify MAE is reasonable (~0.1-0.2 ppm for 1H, ~1-3 ppm for 13C)

If any factor has R^2 < 0.95 or unexpected values, debug by printing the data distribution and checking for mismatched atom indices.

No code changes needed if working correctly - this task verifies the implementation.
  </action>
  <verify>
python -c "
from qm_nmr_calc.benchmark.analysis import derive_all_factors

factors = derive_all_factors()
print(f'Derived {len(factors)} scaling factor sets')
print()
for key, factor in factors.items():
    print(f'{key}:')
    print(f'  slope={factor.slope:.4f}, intercept={factor.intercept:.2f}')
    print(f'  R^2={factor.r_squared:.4f}, MAE={factor.mae:.3f} ppm, RMSD={factor.rmsd:.3f} ppm')
    print(f'  n_points={factor.n_points}, outliers_removed={factor.outliers_removed}')
    print()
"
  </verify>
  <done>
derive_all_factors() returns 4 ScalingFactor objects with R^2 > 0.99, negative slopes, and reasonable MAE values.
  </done>
</task>

</tasks>

<verification>
1. ScalingFactor and RegressionData models importable: `from qm_nmr_calc.benchmark.models import ScalingFactor, RegressionData`
2. Analysis functions importable: `from qm_nmr_calc.benchmark import derive_all_factors, aggregate_regression_data`
3. derive_all_factors() returns 4 factor sets with expected statistics
4. No import errors, no runtime exceptions
</verification>

<success_criteria>
- analysis.py exists with 4 functions
- ScalingFactor model has all required fields
- derive_all_factors() produces 4 factor sets
- All factors have R^2 > 0.95 (ideally > 0.99)
- All slopes are negative
- 1H MAE < 0.5 ppm, 13C MAE < 5 ppm
</success_criteria>

<output>
After completion, create `.planning/phases/10-scaling-factors/10-01-SUMMARY.md`
</output>
