---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/qm_nmr_calc/isicle_wrapper.py
  - src/qm_nmr_calc/queue.py
  - src/qm_nmr_calc/tasks.py
autonomous: true

must_haves:
  truths:
    - "ISiCLE can run geometry optimization on a simple molecule (methane)"
    - "NWChem binary is validated at wrapper import time"
    - "Huey task can be enqueued and executes when consumer runs"
    - "Signal handlers update job status on task start/complete/error"
  artifacts:
    - path: "src/qm_nmr_calc/isicle_wrapper.py"
      provides: "Thin wrapper around ISiCLE for geometry optimization"
      exports: ["run_geometry_optimization", "validate_nwchem", "get_versions"]
    - path: "src/qm_nmr_calc/queue.py"
      provides: "Huey instance and signal handlers"
      exports: ["huey"]
    - path: "src/qm_nmr_calc/tasks.py"
      provides: "Calculation task definitions"
      exports: ["run_optimization_task"]
  key_links:
    - from: "src/qm_nmr_calc/tasks.py"
      to: "src/qm_nmr_calc/isicle_wrapper.py"
      via: "calls run_geometry_optimization"
      pattern: "run_geometry_optimization"
    - from: "src/qm_nmr_calc/tasks.py"
      to: "src/qm_nmr_calc/storage.py"
      via: "updates job status"
      pattern: "update_job_status"
    - from: "src/qm_nmr_calc/queue.py"
      to: "src/qm_nmr_calc/storage.py"
      via: "signal handlers call storage functions"
      pattern: "update_job_status"
---

<objective>
Implement the ISiCLE wrapper and Huey task queue for geometry optimization calculations.

Purpose: This is the core calculation engine - the ability to run NWChem via ISiCLE and track job status through Huey's signal system.

Output: Working task queue that can execute ISiCLE geometry optimizations with automatic status tracking.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ISiCLE wrapper with NWChem validation</name>
  <files>src/qm_nmr_calc/isicle_wrapper.py</files>
  <action>
Create `src/qm_nmr_calc/isicle_wrapper.py` with thin ISiCLE wrapper:

```python
"""Thin wrapper around ISiCLE for geometry optimization."""
import subprocess
import sys
from pathlib import Path
from typing import NamedTuple

import isicle


class Versions(NamedTuple):
    """Software versions for reproducibility."""
    isicle: str
    nwchem: str


def validate_nwchem() -> None:
    """
    Validate NWChem is available and callable.
    Call at startup - exits if validation fails.
    """
    try:
        result = subprocess.run(
            ['which', 'nwchem'],
            capture_output=True,
            text=True,
            timeout=5
        )
        if result.returncode != 0:
            sys.exit("FATAL: nwchem not found in PATH. Ensure NWChem is installed.")
    except subprocess.TimeoutExpired:
        sys.exit("FATAL: 'which nwchem' timed out")
    except Exception as e:
        sys.exit(f"FATAL: Cannot verify nwchem: {e}")


def get_nwchem_version() -> str:
    """
    Get NWChem version string.
    Note: NWChem doesn't have a --version flag, so we hardcode the known version.
    In production, could parse from package manager or NWChem output header.
    """
    # TODO: Parse dynamically if needed
    return "7.0.2"


def get_versions() -> Versions:
    """Get software versions for reproducibility."""
    return Versions(
        isicle=isicle.__version__,
        nwchem=get_nwchem_version()
    )


def run_geometry_optimization(
    smiles: str,
    job_dir: Path,
    processes: int = 4,
    functional: str = 'b3lyp',
    basis_set: str = '6-31G*',
) -> Path:
    """
    Run geometry optimization via ISiCLE/NWChem.

    Args:
        smiles: SMILES string of molecule
        job_dir: Job directory for outputs and scratch
        processes: Number of MPI processes for NWChem
        functional: DFT functional (default: b3lyp)
        basis_set: Basis set (default: 6-31G*)

    Returns:
        Path to optimized geometry file (XYZ format)

    Raises:
        Exception: If calculation fails (propagate to Huey for error handling)
    """
    # 1. Load molecule from SMILES
    geom = isicle.load(smiles)

    # 2. Initial 3D embedding and force-field optimization
    geom = geom.initial_optimize(embed=True, forcefield='UFF', ff_iter=200)

    # 3. Set up scratch directory inside job directory
    scratch_dir = job_dir / 'scratch'
    scratch_dir.mkdir(exist_ok=True)

    # 4. DFT geometry optimization via NWChem
    wrapper = isicle.qm.dft(
        geom,
        backend='NWChem',
        tasks=['optimize'],
        functional=functional,
        basis_set=basis_set,
        scratch_dir=str(scratch_dir),
        processes=processes,
    )

    # 5. Parse results
    result = wrapper.parse()

    # 6. Save optimized geometry
    output_file = job_dir / 'output' / 'optimized.xyz'
    isicle.save(str(output_file), result['geometry'])

    return output_file
```

Key points:
- validate_nwchem() exits process if NWChem not found (fail-fast)
- Explicit scratch_dir prevents temp directory accumulation
- Let exceptions propagate for Huey error handling
- Returns path to output file for downstream use
  </action>
  <verify>
```bash
# Test NWChem validation
uv run python -c "from qm_nmr_calc.isicle_wrapper import validate_nwchem; validate_nwchem(); print('NWChem validated')"

# Test version retrieval
uv run python -c "from qm_nmr_calc.isicle_wrapper import get_versions; v = get_versions(); print(f'ISiCLE: {v.isicle}, NWChem: {v.nwchem}')"

# Test ISiCLE loads (without running full calculation)
uv run python -c "
import isicle
geom = isicle.load('C')  # Methane
geom = geom.initial_optimize(embed=True, forcefield='UFF')
print(f'Initial optimization works, {len(geom.xyz)} atoms')
"
```
All commands should succeed without errors.
  </verify>
  <done>
- validate_nwchem() confirms NWChem is available
- get_versions() returns ISiCLE and NWChem versions
- run_geometry_optimization() implements the ISiCLE workflow
- Scratch directory managed inside job directory
  </done>
</task>

<task type="auto">
  <name>Task 2: Set up Huey queue with signal handlers</name>
  <files>src/qm_nmr_calc/queue.py</files>
  <action>
Create `src/qm_nmr_calc/queue.py` with Huey instance and signal handlers:

```python
"""Huey task queue configuration and signal handlers."""
from datetime import datetime
import traceback
from pathlib import Path

from huey import SqliteHuey, signals

from .storage import update_job_status


# Huey instance with SQLite storage
# fsync=True ensures durability across crashes
huey = SqliteHuey(
    'qm-nmr-calc',
    filename='./data/huey.db',
    fsync=True
)


@huey.signal(signals.SIGNAL_EXECUTING)
def on_task_start(signal, task):
    """Update job status when task starts executing."""
    # Task args: (job_id,)
    if not task.args:
        return
    job_id = task.args[0]
    try:
        update_job_status(
            job_id,
            status='running',
            started_at=datetime.utcnow()
        )
    except Exception:
        # Don't let status update failure stop the task
        pass


@huey.signal(signals.SIGNAL_COMPLETE)
def on_task_complete(signal, task):
    """Update job status when task completes successfully."""
    if not task.args:
        return
    job_id = task.args[0]
    try:
        update_job_status(
            job_id,
            status='complete',
            completed_at=datetime.utcnow()
        )
    except Exception:
        pass


@huey.signal(signals.SIGNAL_ERROR)
def on_task_error(signal, task, exc=None):
    """Update job status when task fails with exception."""
    if not task.args:
        return
    job_id = task.args[0]
    try:
        update_job_status(
            job_id,
            status='failed',
            completed_at=datetime.utcnow(),
            error_message=str(exc) if exc else 'Unknown error',
            error_traceback=traceback.format_exc()
        )
    except Exception:
        pass


@huey.signal(signals.SIGNAL_INTERRUPTED)
def on_task_interrupted(signal, task):
    """Update job status when task is interrupted (graceful shutdown)."""
    if not task.args:
        return
    job_id = task.args[0]
    try:
        update_job_status(
            job_id,
            status='failed',
            completed_at=datetime.utcnow(),
            error_message='Task interrupted - process shutdown'
        )
    except Exception:
        pass
```

Key points:
- SqliteHuey with fsync=True for durability
- Signal handlers are fast (just status.json update)
- All handlers have try/except to not block task execution
- Job ID is first argument to all tasks (convention)
  </action>
  <verify>
```bash
# Test Huey instance creation
uv run python -c "from qm_nmr_calc.queue import huey; print(f'Huey instance: {huey.name}')"

# Test signal handlers are registered
uv run python -c "
from qm_nmr_calc.queue import huey
print(f'Signals registered: {len(huey._signal_callbacks)} signal types')
"
```
Should show Huey instance name and registered signals.
  </verify>
  <done>
- Huey instance configured with SQLite storage at ./data/huey.db
- SIGNAL_EXECUTING updates status to 'running'
- SIGNAL_COMPLETE updates status to 'complete'
- SIGNAL_ERROR updates status to 'failed' with error details
- SIGNAL_INTERRUPTED updates status to 'failed' with interruption message
  </done>
</task>

<task type="auto">
  <name>Task 3: Create geometry optimization task</name>
  <files>src/qm_nmr_calc/tasks.py</files>
  <action>
Create `src/qm_nmr_calc/tasks.py` with the calculation task:

```python
"""Huey task definitions for calculations."""
from pathlib import Path

from .queue import huey
from .storage import load_job_status, get_job_dir
from .isicle_wrapper import run_geometry_optimization


@huey.task()
def run_optimization_task(job_id: str) -> dict:
    """
    Execute geometry optimization for a queued job.

    Args:
        job_id: ID of the job to process

    Returns:
        dict with success status and output path

    Note: Status updates happen via signal handlers in queue.py,
    not in this function. Let exceptions propagate for SIGNAL_ERROR.
    """
    # Load job info
    job_status = load_job_status(job_id)
    if job_status is None:
        raise ValueError(f"Job {job_id} not found")

    if job_status.status != 'queued':
        raise ValueError(f"Job {job_id} is not queued (status: {job_status.status})")

    smiles = job_status.input.smiles
    job_dir = get_job_dir(job_id)

    # Run the calculation
    # Exceptions propagate to Huey -> SIGNAL_ERROR -> status update
    output_file = run_geometry_optimization(
        smiles=smiles,
        job_dir=job_dir,
        processes=4,  # Single worker, so can use multiple MPI processes
    )

    return {
        'success': True,
        'job_id': job_id,
        'output_file': str(output_file)
    }
```

Also update `src/qm_nmr_calc/__init__.py` to expose key functions:

```python
"""QM NMR Calculation Service."""
__version__ = "0.1.0"

from .models import JobStatus, JobInput
from .storage import create_job_directory, load_job_status, update_job_status
from .isicle_wrapper import validate_nwchem, get_versions
from .queue import huey
from .tasks import run_optimization_task

__all__ = [
    'JobStatus',
    'JobInput',
    'create_job_directory',
    'load_job_status',
    'update_job_status',
    'validate_nwchem',
    'get_versions',
    'huey',
    'run_optimization_task',
]
```

Key points:
- Task takes job_id as first argument (signal handler convention)
- Validates job exists and is queued before processing
- No try/except - let errors propagate to signal handler
- Returns dict for task result (stored by Huey)
  </action>
  <verify>
```bash
# Test task is registered
uv run python -c "
from qm_nmr_calc.tasks import run_optimization_task
print(f'Task name: {run_optimization_task.name}')
print(f'Is Huey task: {hasattr(run_optimization_task, \"schedule\")}')
"

# Test package exports
uv run python -c "
from qm_nmr_calc import (
    JobStatus, create_job_directory, load_job_status,
    validate_nwchem, get_versions, huey, run_optimization_task
)
print('All exports available')
"
```
Should show task name and confirm all exports work.
  </verify>
  <done>
- run_optimization_task registered with Huey
- Task validates job status before processing
- Task uses ISiCLE wrapper for calculation
- Package __init__.py exports all key components
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. ISiCLE wrapper validates NWChem and provides geometry optimization function
2. Huey instance configured with signal handlers
3. Task can be registered and (theoretically) enqueued
4. All imports work from package root

Do NOT run a full calculation in verification - that's for Plan 03 integration test.
</verification>

<success_criteria>
- validate_nwchem() passes without error
- get_versions() returns valid version strings
- Huey instance created with SQLite storage
- Signal handlers registered for EXECUTING, COMPLETE, ERROR, INTERRUPTED
- run_optimization_task is a valid Huey task
- All components importable from qm_nmr_calc package root
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
