---
phase: 24-conformer-preselection
plan: 02
type: execute
wave: 2
depends_on: ["24-01"]
files_modified:
  - src/qm_nmr_calc/conformers/xtb_ranking.py
  - tests/test_xtb_ranking.py
autonomous: true

must_haves:
  truths:
    - "xTB binary detection returns true when xtb is in PATH"
    - "GFN2-xTB single-point energy calculation works for valid XYZ input"
    - "Solvent support via ALPB model (chloroform, DMSO, etc.)"
    - "Graceful fallback when xTB not available (returns None or raises clear error)"
    - "Energy returned in kcal/mol relative to minimum conformer"
  artifacts:
    - path: "src/qm_nmr_calc/conformers/xtb_ranking.py"
      provides: "xTB energy ranking functions"
      contains: "rank_conformers_by_xtb"
  key_links:
    - from: "xtb_ranking.py"
      to: "subprocess"
      via: "subprocess.run calling xtb binary"
      pattern: 'subprocess.run.*"xtb"'
---

<objective>
Implement xTB-based conformer energy ranking for better pre-DFT selection.

Purpose: MMFF energy ranking has poor correlation with DFT energies (negative in some cases). xTB/GFN2 provides 100-1000x faster energy calculations than DFT while maintaining reasonable correlation (0.4-0.5 Spearman) for conformer ranking.

Output: New xtb_ranking.py module with xTB detection, single-point energy calculation, and batch conformer ranking functions.
</objective>

<context>
Research findings (.planning/research/CONFORMER_PRESELECTION.md):
- GFN2-xTB is 100-1000x faster than DFT
- Spearman correlation 0.39-0.47 with DFT energies (vs -0.1 to -0.45 for MMFF)
- Supports ALPB implicit solvation model
- xTB binary available via conda: `conda install -c conda-forge xtb`

xTB output format:
```
          | TOTAL ENERGY              -XX.XXXXXX Eh   |
```
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create xtb_ranking.py module</name>
  <files>src/qm_nmr_calc/conformers/xtb_ranking.py</files>
  <action>
Create new module src/qm_nmr_calc/conformers/xtb_ranking.py:

```python
"""xTB-based conformer energy ranking for pre-DFT selection.

GFN2-xTB provides fast semi-empirical energies (100-1000x faster than DFT)
with better ranking correlation than MMFF force fields.

Requires xTB binary in PATH. Install via: conda install -c conda-forge xtb
"""

import shutil
import subprocess
import tempfile
from pathlib import Path
from typing import Optional

from rdkit import Chem
from rdkit.Chem import rdmolfiles


# Conversion factor
HARTREE_TO_KCAL = 627.509474


def detect_xtb_available() -> bool:
    """Check if xTB binary is available in PATH.

    Returns:
        True if xTB is found and executable, False otherwise.
    """
    return shutil.which("xtb") is not None


def get_xtb_version() -> Optional[str]:
    """Get xTB version string if available.

    Returns:
        Version string (e.g., "6.6.1") or None if xTB not available.
    """
    if not detect_xtb_available():
        return None

    try:
        result = subprocess.run(
            ["xtb", "--version"],
            capture_output=True,
            text=True,
            timeout=10,
        )
        # Parse version from output
        for line in result.stdout.split("\n"):
            if "version" in line.lower():
                parts = line.split()
                for i, part in enumerate(parts):
                    if part.lower() == "version" and i + 1 < len(parts):
                        return parts[i + 1]
        return "unknown"
    except Exception:
        return None


def calculate_xtb_energy(
    xyz_content: str,
    charge: int = 0,
    multiplicity: int = 1,
    solvent: Optional[str] = None,
    timeout_seconds: int = 60,
) -> float:
    """Calculate GFN2-xTB single-point energy for a conformer.

    Args:
        xyz_content: XYZ file content as string
        charge: Molecular charge (default 0)
        multiplicity: Spin multiplicity (default 1 for singlet)
        solvent: ALPB solvent name (e.g., "chcl3", "dmso") or None for gas phase
        timeout_seconds: Maximum time for calculation (default 60s)

    Returns:
        Total energy in Hartree

    Raises:
        RuntimeError: If xTB not available or calculation fails
        TimeoutError: If calculation exceeds timeout
    """
    if not detect_xtb_available():
        raise RuntimeError("xTB binary not found in PATH. Install via: conda install -c conda-forge xtb")

    with tempfile.TemporaryDirectory() as tmpdir:
        xyz_path = Path(tmpdir) / "input.xyz"
        xyz_path.write_text(xyz_content)

        # Build command
        cmd = [
            "xtb",
            str(xyz_path),
            "--gfn2",           # Use GFN2-xTB method
            "--sp",             # Single point (no optimization)
            "--chrg", str(charge),
            "--uhf", str(multiplicity - 1),  # xTB uses number of unpaired electrons
        ]

        # Add solvation if specified
        if solvent:
            alpb_solvent = _map_solvent_to_alpb(solvent)
            if alpb_solvent:
                cmd.extend(["--alpb", alpb_solvent])

        try:
            result = subprocess.run(
                cmd,
                cwd=tmpdir,
                capture_output=True,
                text=True,
                timeout=timeout_seconds,
            )
        except subprocess.TimeoutExpired:
            raise TimeoutError(f"xTB calculation timed out after {timeout_seconds}s")

        if result.returncode != 0:
            raise RuntimeError(f"xTB failed with code {result.returncode}: {result.stderr[:500]}")

        # Parse energy from output
        return _parse_xtb_energy(result.stdout)


def _map_solvent_to_alpb(solvent: str) -> Optional[str]:
    """Map common solvent names to xTB ALPB solvent names.

    Args:
        solvent: Solvent name (various formats accepted)

    Returns:
        ALPB solvent name or None if not supported
    """
    solvent_map = {
        # Chloroform variants
        "chcl3": "chcl3",
        "chloroform": "chcl3",
        "cdcl3": "chcl3",
        # DMSO variants
        "dmso": "dmso",
        "dmso-d6": "dmso",
        # Water
        "water": "water",
        "h2o": "water",
        "d2o": "water",
        # Methanol
        "methanol": "methanol",
        "meoh": "methanol",
        "cd3od": "methanol",
        # Acetone
        "acetone": "acetone",
        # Acetonitrile
        "acetonitrile": "acetonitrile",
        "mecn": "acetonitrile",
        # THF
        "thf": "thf",
        # Benzene
        "benzene": "benzene",
        "c6d6": "benzene",
        # Toluene
        "toluene": "toluene",
        # DCM
        "dcm": "ch2cl2",
        "ch2cl2": "ch2cl2",
        "dichloromethane": "ch2cl2",
    }
    return solvent_map.get(solvent.lower())


def _parse_xtb_energy(output: str) -> float:
    """Parse total energy from xTB output.

    Args:
        output: xTB stdout content

    Returns:
        Energy in Hartree

    Raises:
        RuntimeError: If energy cannot be parsed
    """
    # Look for "TOTAL ENERGY" line
    # Format: "          | TOTAL ENERGY              -XX.XXXXXX Eh   |"
    for line in output.split("\n"):
        if "TOTAL ENERGY" in line and "Eh" in line:
            parts = line.split()
            for i, part in enumerate(parts):
                if part == "ENERGY" and i + 1 < len(parts):
                    try:
                        return float(parts[i + 1])
                    except ValueError:
                        continue

    raise RuntimeError("Could not parse energy from xTB output")


def rank_conformers_by_xtb(
    mol: Chem.Mol,
    conf_ids: list[int],
    charge: int = 0,
    solvent: Optional[str] = None,
    timeout_per_conf: int = 60,
) -> dict[int, float]:
    """Calculate xTB energies for multiple conformers.

    Args:
        mol: RDKit Mol with conformers
        conf_ids: List of conformer IDs to rank
        charge: Molecular charge
        solvent: Solvent name or None for gas phase
        timeout_per_conf: Timeout in seconds per conformer

    Returns:
        Dict mapping conformer ID to relative energy in kcal/mol.
        Energies are relative to the minimum (lowest = 0.0).

    Raises:
        RuntimeError: If all conformers fail or xTB not available
    """
    if not detect_xtb_available():
        raise RuntimeError("xTB not available")

    energies_hartree = {}
    failures = []

    for conf_id in conf_ids:
        # Generate XYZ content for this conformer
        xyz_content = rdmolfiles.MolToXYZBlock(mol, confId=conf_id)

        try:
            energy = calculate_xtb_energy(
                xyz_content,
                charge=charge,
                solvent=solvent,
                timeout_seconds=timeout_per_conf,
            )
            energies_hartree[conf_id] = energy
        except Exception as e:
            # Log warning but continue with other conformers
            failures.append((conf_id, str(e)))
            continue

    if not energies_hartree:
        failure_msgs = "; ".join(f"{cid}: {msg}" for cid, msg in failures[:3])
        raise RuntimeError(f"All xTB calculations failed. First failures: {failure_msgs}")

    # Convert to kcal/mol relative to minimum
    min_energy = min(energies_hartree.values())

    return {
        conf_id: (energy - min_energy) * HARTREE_TO_KCAL
        for conf_id, energy in energies_hartree.items()
    }
```
  </action>
  <verify>
File exists and has correct structure:
```bash
grep -c "def detect_xtb_available" src/qm_nmr_calc/conformers/xtb_ranking.py
# Should return 1

grep -c "def rank_conformers_by_xtb" src/qm_nmr_calc/conformers/xtb_ranking.py
# Should return 1

grep -c "subprocess.run" src/qm_nmr_calc/conformers/xtb_ranking.py
# Should return >= 2
```
  </verify>
  <done>xtb_ranking.py created with xTB detection, energy calculation, and conformer ranking functions</done>
</task>

<task type="auto">
  <name>Task 2: Create unit tests for xTB ranking</name>
  <files>tests/test_xtb_ranking.py</files>
  <action>
Create tests/test_xtb_ranking.py with tests that work with or without xTB installed:

```python
"""Tests for xTB-based conformer ranking.

These tests are designed to work whether xTB is installed or not.
Tests requiring xTB are skipped if the binary is not available.
"""

import pytest
from rdkit import Chem
from rdkit.Chem import AllChem

from qm_nmr_calc.conformers.xtb_ranking import (
    detect_xtb_available,
    get_xtb_version,
    calculate_xtb_energy,
    rank_conformers_by_xtb,
    _map_solvent_to_alpb,
    HARTREE_TO_KCAL,
)


# Skip decorator for tests requiring xTB
requires_xtb = pytest.mark.skipif(
    not detect_xtb_available(),
    reason="xTB binary not available"
)


class TestXtbDetection:
    """Tests for xTB availability detection."""

    def test_detect_returns_bool(self):
        """Detection should return boolean."""
        result = detect_xtb_available()
        assert isinstance(result, bool)

    def test_version_returns_string_or_none(self):
        """Version should return string if available, None otherwise."""
        version = get_xtb_version()
        if detect_xtb_available():
            assert isinstance(version, str)
        else:
            assert version is None


class TestSolventMapping:
    """Tests for solvent name mapping."""

    def test_chloroform_variants(self):
        """All chloroform variants should map to chcl3."""
        assert _map_solvent_to_alpb("chcl3") == "chcl3"
        assert _map_solvent_to_alpb("chloroform") == "chcl3"
        assert _map_solvent_to_alpb("CDCl3") == "chcl3"

    def test_dmso_variants(self):
        """DMSO variants should map correctly."""
        assert _map_solvent_to_alpb("dmso") == "dmso"
        assert _map_solvent_to_alpb("DMSO-d6") == "dmso"

    def test_water_variants(self):
        """Water variants should map correctly."""
        assert _map_solvent_to_alpb("water") == "water"
        assert _map_solvent_to_alpb("H2O") == "water"
        assert _map_solvent_to_alpb("D2O") == "water"

    def test_unknown_solvent(self):
        """Unknown solvent should return None."""
        assert _map_solvent_to_alpb("unknown_solvent") is None

    def test_case_insensitive(self):
        """Mapping should be case-insensitive."""
        assert _map_solvent_to_alpb("CHCL3") == "chcl3"
        assert _map_solvent_to_alpb("Methanol") == "methanol"


@requires_xtb
class TestXtbEnergyCalculation:
    """Tests for xTB energy calculation (requires xTB installed)."""

    def test_simple_molecule(self):
        """Should calculate energy for simple molecule."""
        # Methane XYZ
        xyz = """5

C    0.000000    0.000000    0.000000
H    0.629118    0.629118    0.629118
H   -0.629118   -0.629118    0.629118
H   -0.629118    0.629118   -0.629118
H    0.629118   -0.629118   -0.629118
"""
        energy = calculate_xtb_energy(xyz)

        assert isinstance(energy, float)
        assert energy < 0  # Total energy should be negative

    def test_with_solvent(self):
        """Should run with solvation model."""
        xyz = """5

C    0.000000    0.000000    0.000000
H    0.629118    0.629118    0.629118
H   -0.629118   -0.629118    0.629118
H   -0.629118    0.629118   -0.629118
H    0.629118   -0.629118   -0.629118
"""
        energy_gas = calculate_xtb_energy(xyz, solvent=None)
        energy_solv = calculate_xtb_energy(xyz, solvent="chcl3")

        # Both should be valid energies
        assert isinstance(energy_gas, float)
        assert isinstance(energy_solv, float)
        # Solvation should change energy (slightly)
        assert energy_gas != energy_solv

    def test_charged_molecule(self):
        """Should handle charged molecules."""
        # Hydronium ion H3O+
        xyz = """4

O    0.000000    0.000000    0.000000
H    0.960000    0.000000    0.000000
H   -0.480000    0.831384    0.000000
H   -0.480000   -0.831384    0.000000
"""
        energy = calculate_xtb_energy(xyz, charge=1)
        assert isinstance(energy, float)


@requires_xtb
class TestRankConformersByXtb:
    """Tests for conformer ranking (requires xTB installed)."""

    @pytest.fixture
    def ethane_conformers(self):
        """Create ethane with conformers."""
        mol = Chem.MolFromSmiles("CC")
        mol = Chem.AddHs(mol)
        params = AllChem.ETKDGv3()
        params.randomSeed = 42
        AllChem.EmbedMultipleConfs(mol, numConfs=5, params=params)
        return mol

    def test_returns_relative_energies(self, ethane_conformers):
        """Should return energies relative to minimum."""
        mol = ethane_conformers
        conf_ids = [conf.GetId() for conf in mol.GetConformers()]

        energies = rank_conformers_by_xtb(mol, conf_ids)

        # All energies should be non-negative (relative to min)
        assert all(e >= 0 for e in energies.values())
        # Minimum should be zero
        assert min(energies.values()) == pytest.approx(0.0, abs=1e-6)
        # Energies should be in kcal/mol (reasonable range)
        assert max(energies.values()) < 50  # No conformer should be 50 kcal/mol above min

    def test_returns_dict_for_all_conformers(self, ethane_conformers):
        """Should return energy for each conformer."""
        mol = ethane_conformers
        conf_ids = [conf.GetId() for conf in mol.GetConformers()]

        energies = rank_conformers_by_xtb(mol, conf_ids)

        assert len(energies) == len(conf_ids)
        assert all(cid in energies for cid in conf_ids)


class TestXtbNotAvailable:
    """Tests for behavior when xTB is not installed."""

    def test_rank_raises_when_unavailable(self):
        """Should raise clear error when xTB not available."""
        if detect_xtb_available():
            pytest.skip("xTB is available, cannot test unavailable behavior")

        mol = Chem.MolFromSmiles("C")
        mol = Chem.AddHs(mol)
        AllChem.EmbedMolecule(mol)

        with pytest.raises(RuntimeError, match="xTB not available"):
            rank_conformers_by_xtb(mol, [0])

    def test_calculate_raises_when_unavailable(self):
        """Should raise clear error when xTB not available."""
        if detect_xtb_available():
            pytest.skip("xTB is available, cannot test unavailable behavior")

        with pytest.raises(RuntimeError, match="xTB binary not found"):
            calculate_xtb_energy("1\n\nC 0 0 0")
```
  </action>
  <verify>
Run tests:
```bash
uv run pytest tests/test_xtb_ranking.py -v
# Tests should pass (some may be skipped if xTB not installed)
```
  </verify>
  <done>Unit tests created for xTB ranking with proper skip handling for xTB availability</done>
</task>

</tasks>

<verification>
After both tasks complete:

1. Module imports correctly:
```bash
uv run python -c "from qm_nmr_calc.conformers.xtb_ranking import detect_xtb_available; print(f'xTB available: {detect_xtb_available()}')"
```

2. All tests pass (some skipped if xTB not installed):
```bash
uv run pytest tests/test_xtb_ranking.py -v
```

3. If xTB is installed, test real calculation:
```bash
uv run python -c "
from qm_nmr_calc.conformers.xtb_ranking import detect_xtb_available, get_xtb_version
if detect_xtb_available():
    print(f'xTB version: {get_xtb_version()}')
else:
    print('xTB not installed - ranking will fall back to MMFF')
"
```
</verification>

<success_criteria>
- xtb_ranking.py module exists with documented functions
- xTB detection works correctly
- Solvent mapping covers common NMR solvents
- Energy parsing handles xTB output format
- Tests pass (with appropriate skips when xTB not available)
- Clear error messages when xTB unavailable
</success_criteria>

<output>
After completion, create `.planning/phases/24-conformer-preselection/24-02-SUMMARY.md`
</output>
