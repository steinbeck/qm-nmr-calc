---
phase: 24-conformer-preselection
plan: 03
type: execute
wave: 3
depends_on: ["24-01", "24-02"]
files_modified:
  - src/qm_nmr_calc/conformers/pipeline.py
  - src/qm_nmr_calc/conformers/__init__.py
  - tests/test_conformer_pipeline.py
autonomous: true

must_haves:
  truths:
    - "Pipeline reduces 40+ conformers to target ~8 for DFT via clustering"
    - "xTB ranking used when available, MMFF fallback otherwise"
    - "Clustering happens after MMFF optimization but before file writing"
    - "ConformerEnsemble metadata tracks clustering statistics"
  artifacts:
    - path: "src/qm_nmr_calc/conformers/pipeline.py"
      provides: "Updated pipeline with clustering integration"
      contains: "cluster_and_select"
  key_links:
    - from: "pipeline.py"
      to: "clustering.py"
      via: "import cluster_and_select"
      pattern: "from .clustering import"
    - from: "pipeline.py"
      to: "xtb_ranking.py"
      via: "import rank_conformers_by_xtb"
      pattern: "from .xtb_ranking import"
---

<objective>
Integrate RMSD clustering and xTB ranking into the conformer pipeline to reduce 40+ conformers to ~8 diverse representatives before DFT.

Purpose: The current pipeline sends all conformers passing the energy window filter to expensive DFT optimization. For flexible molecules this can be 40+ conformers = 10+ hours of DFT. By clustering structurally similar conformers and selecting representatives, we target ~8 conformers for DFT while maintaining conformational diversity.

Output: Updated pipeline.py with clustering integration, updated __init__.py exports, and integration tests.
</objective>

<context>
Pipeline flow before this change (RDKit path):
1. Calculate adaptive conformer count
2. Generate conformers (KDG)
3. Optimize with MMFF
4. Extract conformer IDs and energies
5. Deduplicate by RMSD (0.5 Å threshold)
6. Filter to deduped conformers
7. Energy window filter (6.0 kcal/mol)
8. Create directories and write XYZ files

Pipeline flow after this change:
1-7. Same as before
8. NEW: Cluster by RMSD (1.5 Å threshold for diversity)
9. NEW: Rank with xTB if available, else use MMFF
10. NEW: Select representatives (target 8 conformers)
11. Create directories and write XYZ files

Dependencies:
- clustering.py (Plan 24-01): cluster_conformers_by_rmsd, select_cluster_representatives, cluster_and_select
- xtb_ranking.py (Plan 24-02): detect_xtb_available, rank_conformers_by_xtb
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update pipeline.py with clustering integration</name>
  <files>src/qm_nmr_calc/conformers/pipeline.py</files>
  <action>
Update src/qm_nmr_calc/conformers/pipeline.py to integrate clustering.

1. Add imports at the top:
```python
from .clustering import cluster_and_select
from .xtb_ranking import detect_xtb_available, rank_conformers_by_xtb
```

2. Add new parameter to generate_conformer_ensemble:
```python
def generate_conformer_ensemble(
    smiles: str,
    job_id: str,
    max_conformers: int | None = None,
    energy_window_kcal: float = 6.0,
    rmsd_threshold: float = 0.5,
    random_seed: int = 0xF00D,
    conformer_method: str = "rdkit_kdg",
    solvent: str = "chcl3",
    charge: int = 0,
    timeout_seconds: int = 7200,
    target_conformers_for_dft: int = 8,  # NEW
    clustering_rmsd_threshold: float = 1.5,  # NEW
) -> ConformerEnsemble:
```

3. Update the docstring to document new parameters:
```
        target_conformers_for_dft: Target number of conformers to send to DFT (default: 8).
            After clustering, select up to this many diverse representatives.
        clustering_rmsd_threshold: RMSD threshold for diversity clustering (default: 1.5 Å).
            Larger than deduplication threshold to group similar conformations.
```

4. After step 7 (energy window filter), insert clustering logic before step 8:

Replace the section after `final_conf_ids, final_energies = filter_by_energy_window(...)` and before creating `conformer_string_ids`:

```python
    # Step 8: Cluster conformers by RMSD for diversity selection
    # Only cluster if we have more conformers than the target
    if len(final_conf_ids) > target_conformers_for_dft:
        # Build energy lookup for ranking within clusters
        # Try xTB for better ranking correlation with DFT
        if detect_xtb_available():
            try:
                ranking_energies = rank_conformers_by_xtb(
                    mol, final_conf_ids,
                    charge=charge,
                    solvent=solvent,
                )
                ranking_method = "xtb_gfn2"
            except Exception:
                # Fall back to MMFF if xTB fails
                ranking_energies = dict(zip(final_conf_ids, final_energies))
                ranking_method = "mmff94s"
        else:
            ranking_energies = dict(zip(final_conf_ids, final_energies))
            ranking_method = "mmff94s"

        # Cluster and select representatives
        selected_conf_ids, num_clusters = cluster_and_select(
            mol, ranking_energies,
            rmsd_threshold=clustering_rmsd_threshold,
            max_conformers=target_conformers_for_dft,
        )

        # Filter to selected conformers
        selected_energies = [ranking_energies[cid] for cid in selected_conf_ids]

        # Track statistics
        pre_cluster_count = len(final_conf_ids)
        final_conf_ids = selected_conf_ids
        final_energies = selected_energies
    else:
        num_clusters = len(final_conf_ids)
        pre_cluster_count = len(final_conf_ids)
        ranking_method = "mmff94s"

    # Step 9: Create conformer string IDs (1-based, zero-padded)
    conformer_string_ids = [f"conf_{i+1:03d}" for i in range(len(final_conf_ids))]
```

5. Update ConformerEnsemble construction to include clustering metadata:

```python
    # Step 12: Build and return ConformerEnsemble
    ensemble = ConformerEnsemble(
        method="rdkit_kdg",
        conformers=conformer_data_list,
        pre_dft_energy_window_kcal=energy_window_kcal,
        total_generated=total_generated,
        total_after_pre_filter=pre_cluster_count,  # Was: len(final_conf_ids) before clustering
        # Clustering metadata (new fields if model supports, else logged)
    )
```

Note: Step numbers after insertion will shift (8→9, 9→10, etc.)
  </action>
  <verify>
Verify imports work:
```bash
uv run python -c "from qm_nmr_calc.conformers.pipeline import generate_conformer_ensemble; print('OK')"
```

Check clustering import:
```bash
grep -c "from .clustering import" src/qm_nmr_calc/conformers/pipeline.py
# Should return 1
```
  </verify>
  <done>Pipeline updated with clustering and xTB integration</done>
</task>

<task type="auto">
  <name>Task 2: Update __init__.py exports</name>
  <files>src/qm_nmr_calc/conformers/__init__.py</files>
  <action>
Update src/qm_nmr_calc/conformers/__init__.py to export new modules.

Read the current __init__.py first, then add exports for:
- clustering module functions
- xtb_ranking module functions (detection only, not internals)

Add to existing exports:
```python
from .clustering import (
    cluster_conformers_by_rmsd,
    select_cluster_representatives,
    cluster_and_select,
)
from .xtb_ranking import (
    detect_xtb_available,
    get_xtb_version,
    rank_conformers_by_xtb,
)
```

Update __all__ if present.
  </action>
  <verify>
```bash
uv run python -c "from qm_nmr_calc.conformers import cluster_and_select, detect_xtb_available; print('OK')"
```
  </verify>
  <done>__init__.py updated with new exports</done>
</task>

<task type="auto">
  <name>Task 3: Add integration tests for pipeline clustering</name>
  <files>tests/test_conformer_pipeline.py</files>
  <action>
Add integration tests to tests/test_conformer_pipeline.py (or create if doesn't exist).

Add these test cases:

```python
class TestPipelineClusteringIntegration:
    """Tests for clustering integration in pipeline."""

    def test_flexible_molecule_reduces_to_target(self):
        """Flexible molecule should be reduced to target conformer count."""
        # Hexane - flexible, should generate many conformers
        ensemble = generate_conformer_ensemble(
            smiles="CCCCCC",
            job_id="test_clustering_integration",
            target_conformers_for_dft=8,
        )

        # Should be at or below target
        assert len(ensemble.conformers) <= 10  # Allow small buffer
        # Should have some conformers
        assert len(ensemble.conformers) >= 1
        # Total generated should be higher
        assert ensemble.total_generated > len(ensemble.conformers)

    def test_rigid_molecule_not_over_reduced(self):
        """Rigid molecule with few conformers should not be affected."""
        # Benzene - rigid, very few conformers
        ensemble = generate_conformer_ensemble(
            smiles="c1ccccc1",
            job_id="test_rigid_clustering",
            target_conformers_for_dft=8,
        )

        # Should keep what it has (likely 1-3 conformers)
        assert len(ensemble.conformers) >= 1
        assert len(ensemble.conformers) <= 5

    def test_clustering_threshold_affects_output(self):
        """Different clustering thresholds should affect conformer count."""
        smiles = "CCCCCCCC"  # Octane - very flexible

        # Tight clustering (more clusters, more representatives)
        ensemble_tight = generate_conformer_ensemble(
            smiles=smiles,
            job_id="test_tight_cluster",
            clustering_rmsd_threshold=0.8,
            target_conformers_for_dft=15,
        )

        # Loose clustering (fewer clusters, fewer representatives)
        ensemble_loose = generate_conformer_ensemble(
            smiles=smiles,
            job_id="test_loose_cluster",
            clustering_rmsd_threshold=2.5,
            target_conformers_for_dft=15,
        )

        # Tight should have >= loose (or equal if both hit target)
        # This is probabilistic but generally true
        assert ensemble_tight is not None
        assert ensemble_loose is not None
```
  </action>
  <verify>
```bash
uv run pytest tests/test_conformer_pipeline.py -v -k "clustering"
# Tests should pass
```
  </verify>
  <done>Integration tests added for pipeline clustering</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Full import check:
```bash
uv run python -c "
from qm_nmr_calc.conformers import (
    generate_conformer_ensemble,
    cluster_and_select,
    detect_xtb_available,
)
print('All imports OK')
print(f'xTB available: {detect_xtb_available()}')
"
```

2. Run all conformer tests:
```bash
uv run pytest tests/test_clustering.py tests/test_xtb_ranking.py tests/test_conformer_pipeline.py -v
```

3. Integration test with real molecule (hexanol):
```bash
uv run python -c "
from qm_nmr_calc.conformers import generate_conformer_ensemble

print('Testing hexanol (flexible molecule)...')
ensemble = generate_conformer_ensemble(
    smiles='CCCCCCO',
    job_id='test_hexanol_clustering',
    target_conformers_for_dft=8,
)
print(f'Generated: {ensemble.total_generated} conformers')
print(f'After filtering: {ensemble.total_after_pre_filter} conformers')
print(f'For DFT: {len(ensemble.conformers)} conformers')
print('SUCCESS: Reduced conformers for DFT optimization')
"
```
</verification>

<success_criteria>
- Pipeline integrates clustering after energy window filter
- xTB ranking used when available, MMFF fallback works
- Flexible molecules (hexanol, hexane) reduced to ~8 conformers
- Rigid molecules pass through unchanged
- All tests pass
- Integration test shows reduction from 40+ to ~8
</success_criteria>

<output>
After completion, create `.planning/phases/24-conformer-preselection/24-03-SUMMARY.md`
</output>
