---
phase: 24-conformer-preselection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/qm_nmr_calc/conformers/clustering.py
  - tests/test_clustering.py
autonomous: true

must_haves:
  truths:
    - "Butina RMSD clustering reduces 40+ conformers to 8-12 clusters"
    - "Clustering uses symmetry-aware RMSD (GetBestRMS)"
    - "Cluster representative selection picks lowest-energy conformer from each cluster"
    - "Configurable RMSD threshold (default 1.5 Angstrom)"
  artifacts:
    - path: "src/qm_nmr_calc/conformers/clustering.py"
      provides: "RMSD clustering functions"
      contains: "cluster_conformers_by_rmsd"
  key_links:
    - from: "clustering.py"
      to: "rdkit.ML.Cluster.Butina"
      via: "import and ClusterData call"
      pattern: "Butina.ClusterData"
---

<objective>
Implement RMSD-based conformer clustering using RDKit's Butina algorithm to reduce redundant conformers before DFT optimization.

Purpose: 40+ conformers after MMFF filtering contain many structurally similar conformers (same conformational basin). Clustering identifies unique conformational families, allowing selection of ~8 diverse representatives for expensive DFT calculations.

Output: New clustering.py module with cluster_conformers_by_rmsd and select_cluster_representatives functions, plus unit tests.
</objective>

<context>
Research findings (.planning/research/CONFORMER_PRESELECTION.md):
- Butina algorithm with 1.5 Angstrom threshold typically reduces 40 conformers to 8-12 clusters
- Symmetry-aware RMSD (GetBestRMS) handles molecular symmetry correctly
- Select lowest-energy conformer from each cluster as representative

Existing code to reference:
- src/qm_nmr_calc/conformers/filters.py - existing filtering functions
- src/qm_nmr_calc/conformers/generator.py - conformer generation
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create clustering.py module</name>
  <files>src/qm_nmr_calc/conformers/clustering.py</files>
  <action>
Create new module src/qm_nmr_calc/conformers/clustering.py with:

```python
"""RMSD-based conformer clustering for pre-DFT selection.

Uses Butina algorithm to group structurally similar conformers,
then selects diverse representatives for expensive DFT calculations.
"""

from rdkit import Chem
from rdkit.Chem import AllChem, rdMolAlign
from rdkit.ML.Cluster import Butina


def cluster_conformers_by_rmsd(
    mol: Chem.Mol,
    rmsd_threshold: float = 1.5,
) -> list[list[int]]:
    """Cluster conformers using Butina algorithm with symmetry-aware RMSD.

    Groups structurally similar conformers into clusters. Each cluster
    represents a unique conformational basin.

    Args:
        mol: RDKit Mol with multiple conformers
        rmsd_threshold: RMSD threshold in Angstroms for clustering.
            Typical values: 0.5 (strict), 1.0 (balanced), 1.5 (aggressive)

    Returns:
        List of clusters, each cluster is a list of conformer IDs.
        Clusters are sorted by size (largest first).
        First conformer in each cluster is the centroid.
    """
    conf_ids = [conf.GetId() for conf in mol.GetConformers()]
    n_confs = len(conf_ids)

    if n_confs <= 1:
        return [[conf_ids[0]]] if conf_ids else []

    # Build distance matrix (lower triangle for Butina)
    # Uses symmetry-aware RMSD via GetBestRMS
    dists = []
    for i in range(1, n_confs):
        for j in range(i):
            rmsd = rdMolAlign.GetBestRMS(
                mol, mol,
                prbId=conf_ids[i],
                refId=conf_ids[j]
            )
            dists.append(rmsd)

    # Butina clustering returns tuple of tuples
    clusters = Butina.ClusterData(
        dists,
        n_confs,
        distThresh=rmsd_threshold,
        isDistData=True
    )

    # Convert indices back to conformer IDs
    return [[conf_ids[idx] for idx in cluster] for cluster in clusters]


def select_cluster_representatives(
    clusters: list[list[int]],
    energies: dict[int, float],
    max_representatives: int = 8,
) -> list[int]:
    """Select lowest-energy conformer from each cluster.

    Args:
        clusters: List of clusters from cluster_conformers_by_rmsd
        energies: Dict mapping conformer ID to energy (any unit, lower is better)
        max_representatives: Maximum number of representatives to return

    Returns:
        List of conformer IDs (one per cluster, lowest energy).
        Returns up to max_representatives conformers.
    """
    representatives = []

    for cluster in clusters:
        if len(representatives) >= max_representatives:
            break

        # Find lowest energy conformer in this cluster
        cluster_with_energy = [
            (cid, energies.get(cid, float('inf')))
            for cid in cluster
        ]
        cluster_with_energy.sort(key=lambda x: x[1])
        representatives.append(cluster_with_energy[0][0])

    return representatives


def cluster_and_select(
    mol: Chem.Mol,
    energies: dict[int, float],
    rmsd_threshold: float = 1.5,
    max_conformers: int = 8,
) -> tuple[list[int], int]:
    """Convenience function: cluster conformers and select representatives.

    Args:
        mol: RDKit Mol with multiple conformers
        energies: Dict mapping conformer ID to energy
        rmsd_threshold: RMSD threshold for clustering
        max_conformers: Target number of conformers to select

    Returns:
        Tuple of (selected_conf_ids, num_clusters)
    """
    clusters = cluster_conformers_by_rmsd(mol, rmsd_threshold)
    selected = select_cluster_representatives(clusters, energies, max_conformers)
    return selected, len(clusters)
```
  </action>
  <verify>
File exists and has correct structure:
```bash
grep -c "def cluster_conformers_by_rmsd" src/qm_nmr_calc/conformers/clustering.py
# Should return 1

grep -c "Butina.ClusterData" src/qm_nmr_calc/conformers/clustering.py
# Should return 1

grep -c "GetBestRMS" src/qm_nmr_calc/conformers/clustering.py
# Should return 1
```
  </verify>
  <done>clustering.py created with cluster_conformers_by_rmsd, select_cluster_representatives, and cluster_and_select functions</done>
</task>

<task type="auto">
  <name>Task 2: Create unit tests for clustering</name>
  <files>tests/test_clustering.py</files>
  <action>
Create tests/test_clustering.py with comprehensive tests:

```python
"""Tests for conformer clustering functionality."""

import pytest
from rdkit import Chem
from rdkit.Chem import AllChem

from qm_nmr_calc.conformers.clustering import (
    cluster_conformers_by_rmsd,
    select_cluster_representatives,
    cluster_and_select,
)


@pytest.fixture
def flexible_mol_with_conformers():
    """Create a flexible molecule (heptane) with multiple conformers."""
    mol = Chem.MolFromSmiles("CCCCCCC")
    mol = Chem.AddHs(mol)

    # Generate many conformers
    params = AllChem.ETKDGv3()
    params.randomSeed = 42
    AllChem.EmbedMultipleConfs(mol, numConfs=30, params=params)

    # Optimize with MMFF
    AllChem.MMFFOptimizeMoleculeConfs(mol, maxIters=200)

    return mol


@pytest.fixture
def rigid_mol_with_conformers():
    """Create a rigid molecule (benzene) with conformers."""
    mol = Chem.MolFromSmiles("c1ccccc1")
    mol = Chem.AddHs(mol)

    params = AllChem.ETKDGv3()
    params.randomSeed = 42
    AllChem.EmbedMultipleConfs(mol, numConfs=10, params=params)
    AllChem.MMFFOptimizeMoleculeConfs(mol, maxIters=200)

    return mol


class TestClusterConformersByRMSD:
    """Tests for RMSD clustering function."""

    def test_reduces_conformer_count(self, flexible_mol_with_conformers):
        """Clustering should reduce conformer count."""
        mol = flexible_mol_with_conformers
        n_initial = mol.GetNumConformers()

        clusters = cluster_conformers_by_rmsd(mol, rmsd_threshold=1.5)

        assert len(clusters) < n_initial
        assert len(clusters) >= 1

    def test_all_conformers_assigned(self, flexible_mol_with_conformers):
        """Every conformer should be in exactly one cluster."""
        mol = flexible_mol_with_conformers
        conf_ids = {conf.GetId() for conf in mol.GetConformers()}

        clusters = cluster_conformers_by_rmsd(mol, rmsd_threshold=1.5)

        clustered_ids = set()
        for cluster in clusters:
            for cid in cluster:
                assert cid not in clustered_ids, "Conformer in multiple clusters"
                clustered_ids.add(cid)

        assert clustered_ids == conf_ids

    def test_single_conformer(self):
        """Single conformer should return single cluster."""
        mol = Chem.MolFromSmiles("C")
        mol = Chem.AddHs(mol)
        AllChem.EmbedMolecule(mol)

        clusters = cluster_conformers_by_rmsd(mol, rmsd_threshold=1.5)

        assert len(clusters) == 1
        assert len(clusters[0]) == 1

    def test_threshold_affects_cluster_count(self, flexible_mol_with_conformers):
        """Tighter threshold should produce more clusters."""
        mol = flexible_mol_with_conformers

        clusters_tight = cluster_conformers_by_rmsd(mol, rmsd_threshold=0.5)
        clusters_loose = cluster_conformers_by_rmsd(mol, rmsd_threshold=2.0)

        assert len(clusters_tight) >= len(clusters_loose)

    def test_rigid_molecule_few_clusters(self, rigid_mol_with_conformers):
        """Rigid molecule should have few unique conformers."""
        mol = rigid_mol_with_conformers

        clusters = cluster_conformers_by_rmsd(mol, rmsd_threshold=0.5)

        # Benzene conformers should all be similar
        assert len(clusters) <= 3


class TestSelectClusterRepresentatives:
    """Tests for representative selection function."""

    def test_selects_lowest_energy(self):
        """Should select lowest energy from each cluster."""
        clusters = [[0, 1, 2], [3, 4], [5]]
        energies = {0: 10.0, 1: 8.0, 2: 12.0, 3: 5.0, 4: 6.0, 5: 15.0}

        reps = select_cluster_representatives(clusters, energies, max_representatives=3)

        assert reps == [1, 3, 5]  # Lowest from each cluster

    def test_respects_max_representatives(self):
        """Should not exceed max_representatives."""
        clusters = [[0], [1], [2], [3], [4]]
        energies = {i: float(i) for i in range(5)}

        reps = select_cluster_representatives(clusters, energies, max_representatives=3)

        assert len(reps) == 3

    def test_handles_missing_energies(self):
        """Should handle conformers without energy gracefully."""
        clusters = [[0, 1], [2]]
        energies = {0: 10.0}  # Missing energies for 1 and 2

        reps = select_cluster_representatives(clusters, energies, max_representatives=2)

        assert 0 in reps  # Should select known-energy conformer

    def test_empty_clusters(self):
        """Should handle empty cluster list."""
        reps = select_cluster_representatives([], {}, max_representatives=8)
        assert reps == []


class TestClusterAndSelect:
    """Tests for convenience function."""

    def test_full_pipeline(self, flexible_mol_with_conformers):
        """Test complete cluster and select workflow."""
        mol = flexible_mol_with_conformers

        # Create mock energies
        energies = {
            conf.GetId(): float(i)
            for i, conf in enumerate(mol.GetConformers())
        }

        selected, n_clusters = cluster_and_select(
            mol, energies,
            rmsd_threshold=1.5,
            max_conformers=8
        )

        assert len(selected) <= 8
        assert len(selected) <= n_clusters
        assert n_clusters >= 1

    def test_returns_cluster_count(self, flexible_mol_with_conformers):
        """Should return number of clusters found."""
        mol = flexible_mol_with_conformers
        energies = {conf.GetId(): 0.0 for conf in mol.GetConformers()}

        _, n_clusters = cluster_and_select(mol, energies)

        assert n_clusters > 0
        assert n_clusters <= mol.GetNumConformers()
```
  </action>
  <verify>
Run tests:
```bash
uv run pytest tests/test_clustering.py -v
# All tests should pass
```
  </verify>
  <done>Unit tests created and passing for clustering functionality</done>
</task>

</tasks>

<verification>
After both tasks complete:

1. Module imports correctly:
```bash
uv run python -c "from qm_nmr_calc.conformers.clustering import cluster_and_select; print('OK')"
```

2. All tests pass:
```bash
uv run pytest tests/test_clustering.py -v
```

3. Quick integration check with real molecule:
```bash
uv run python -c "
from rdkit import Chem
from rdkit.Chem import AllChem
from qm_nmr_calc.conformers.clustering import cluster_and_select

mol = Chem.MolFromSmiles('CCCCCC')  # Hexane
mol = Chem.AddHs(mol)
AllChem.EmbedMultipleConfs(mol, numConfs=30)
AllChem.MMFFOptimizeMoleculeConfs(mol)

energies = {c.GetId(): float(i) for i, c in enumerate(mol.GetConformers())}
selected, n_clusters = cluster_and_select(mol, energies, max_conformers=8)
print(f'Reduced {mol.GetNumConformers()} conformers to {len(selected)} (from {n_clusters} clusters)')
"
```
</verification>

<success_criteria>
- clustering.py module exists with documented functions
- Butina algorithm used for RMSD clustering
- Symmetry-aware RMSD via GetBestRMS
- Tests verify cluster reduction and representative selection
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/24-conformer-preselection/24-01-SUMMARY.md`
</output>
