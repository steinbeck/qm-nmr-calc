---
phase: 50-machine-selection-and-resource-calculation
plan: 02
type: execute
wave: 2
depends_on: ["50-01"]
files_modified:
  - gcp/lib/machine.sh
autonomous: true

must_haves:
  truths:
    - "Bash scripts can select machine type by sourcing machine.sh and calling select_machine()"
    - "Bash scripts can get Docker resource limits by calling get_docker_resources()"
    - "Bash scripts can generate a startup script by calling generate_startup()"
    - "All functions return structured data parseable with jq"
  artifacts:
    - path: "gcp/lib/machine.sh"
      provides: "Bash wrapper functions for Python machine selection module"
      min_lines: 40
  key_links:
    - from: "gcp/lib/machine.sh"
      to: "gcp/select_machine.py"
      via: "calls Python script and parses JSON output with jq"
      pattern: "python3.*select_machine\\.py"
    - from: "gcp/lib/machine.sh"
      to: "gcp/lib/config.sh"
      via: "uses $CPU_CORES and $RAM_GB environment variables set by config.sh"
      pattern: "CPU_CORES.*RAM_GB"
---

<objective>
Bash library wrapper for the Python machine selection module, following the established pattern from Phase 49 (config.sh wraps validate_config.py, pricing.sh wraps query_pricing.py).

Purpose: Phase 51 (Deployment Orchestration) needs to call machine selection and resource calculation from bash scripts. This plan creates gcp/lib/machine.sh with shell functions that wrap the Python module's CLI.

Output: `gcp/lib/machine.sh` with functions: select_machine(), get_docker_resources(), generate_startup()
</objective>

<execution_context>
@/Users/steinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/steinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/50-machine-selection-and-resource-calculation/50-RESEARCH.md
@gcp/lib/config.sh
@gcp/lib/pricing.sh
@gcp/select_machine.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create gcp/lib/machine.sh bash wrapper library</name>
  <files>gcp/lib/machine.sh</files>
  <action>
    Create gcp/lib/machine.sh following the exact pattern established by pricing.sh and config.sh:
    - Use `script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"` for reliable path resolution
    - Call `python3 "$script_dir/select_machine.py"` with appropriate flags
    - Parse JSON output with jq

    Functions to implement:

    **select_machine(cpu_cores, ram_gb)**
    - Calls Python CLI: `python3 select_machine.py --cpu-cores $1 --ram-gb $2`
    - Python module internally iterates ranked regions from pricing query
    - Returns JSON object with machine_type, zone, region, worker_memory_limit, nwchem_nproc
    - On failure, prints error to stderr and returns 1

    **get_docker_resources(cpu_cores, ram_gb)**
    - Calls select_machine() and extracts worker_memory_limit and nwchem_nproc
    - Prints two lines: WORKER_MEMORY_LIMIT=Xg and NWCHEM_NPROC=N
    - Designed for `eval $(get_docker_resources 8 32)` pattern

    **generate_startup(cpu_cores, ram_gb, resource_prefix, disk_size_gb)**
    - Calls Python CLI with --generate-startup-script flag
    - Outputs the startup script to stdout (for piping to file)
    - Example: `generate_startup 8 32 qm-nmr-calc 100 > startup-generated.sh`

    **get_machine_info(cpu_cores, ram_gb)**
    - Calls select_machine() and formats human-readable output
    - Prints: "Machine type: n2-standard-8 in us-central1-a (32GB RAM, 8 CPUs)"
    - For deployment progress display in Phase 51

    Header comment should document usage:
    ```
    # Machine selection library for v2.7 automated deployment
    # Wraps gcp/select_machine.py for bash consumption
    #
    # Usage:
    #   source gcp/lib/machine.sh
    #   result_json=$(select_machine 8 32)
    #   eval $(get_docker_resources 8 32)
    #   generate_startup 8 32 qm-nmr-calc 100 > startup.sh
    ```

    Important: Do NOT duplicate any logic from the Python module. The bash functions are thin wrappers only -- all logic lives in Python for testability.
  </action>
  <verify>
    ```bash
    # Verify file exists and is valid bash
    bash -n gcp/lib/machine.sh

    # Verify functions are defined (source and check)
    bash -c 'source gcp/lib/machine.sh && type select_machine && type get_docker_resources && type generate_startup && type get_machine_info'

    # Verify it references the Python module
    grep -q "select_machine.py" gcp/lib/machine.sh

    # Verify jq usage for JSON parsing
    grep -q "jq" gcp/lib/machine.sh
    ```
  </verify>
  <done>
    gcp/lib/machine.sh exists with four functions (select_machine, get_docker_resources, generate_startup, get_machine_info) that wrap gcp/select_machine.py CLI. Functions follow the same pattern as pricing.sh. File passes bash syntax check. All existing tests still pass.
  </done>
</task>

</tasks>

<verification>
```bash
# Bash syntax validation
bash -n gcp/lib/machine.sh

# All functions defined
bash -c 'source gcp/lib/machine.sh && type select_machine && type get_docker_resources && type generate_startup && type get_machine_info' 2>&1 | grep -c "is a function"
# Expected: 4

# Python module still works
python -c "from gcp.select_machine import select_machine_type, calculate_docker_resources, generate_startup_script; print('OK')"

# All tests pass (no regressions)
cd /Users/steinbeck/Dropbox/develop/qm-nmr-calc && python -m pytest tests/test_gcp_config.py tests/test_gcp_pricing.py tests/test_gcp_machine.py -v
```
</verification>

<success_criteria>
- gcp/lib/machine.sh exists with select_machine(), get_docker_resources(), generate_startup(), get_machine_info()
- Functions follow established pattern from pricing.sh (script_dir resolution, python3 call, jq parsing)
- Bash syntax check passes
- No logic duplication -- all computation in Python, bash is thin wrapper
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/50-machine-selection-and-resource-calculation/50-02-SUMMARY.md`
</output>
