---
phase: 50-machine-selection-and-resource-calculation
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - gcp/select_machine.py
  - tests/test_gcp_machine.py
autonomous: true

must_haves:
  truths:
    - "Given CPU/RAM requirements, system returns the correct GCP machine type name"
    - "Given a zone, system validates whether the requested machine type exists there"
    - "When primary zone lacks the machine type, system tries next-cheapest zone and succeeds"
    - "Docker memory limit equals VM RAM minus 8GB OS overhead, with 'g' suffix"
    - "NWCHEM_NPROC matches the machine type's CPU count"
    - "Startup script template contains computed WORKER_MEMORY_LIMIT and uses nproc for CPU detection"
  artifacts:
    - path: "gcp/select_machine.py"
      provides: "Machine type selection, validation, fallback, resource calculation, startup script generation"
      exports: ["select_machine_type", "validate_machine_in_zone", "find_available_zone", "calculate_docker_resources", "generate_startup_script"]
    - path: "tests/test_gcp_machine.py"
      provides: "Tests for all machine selection and resource calculation logic"
      min_lines: 100
  key_links:
    - from: "gcp/select_machine.py"
      to: "gcp/query_pricing.py"
      via: "find_available_zone() calls get_ranked_regions(cpu_cores, ram_gb) to obtain sorted region list for zone iteration"
      pattern: "from gcp\\.query_pricing import get_ranked_regions"
    - from: "gcp/select_machine.py"
      to: "gcp/validate_config.py"
      via: "uses GCPConfig model for type safety"
      pattern: "from gcp\\.validate_config import GCPConfig"
---

<objective>
Machine type selection, zone validation with fallback, Docker resource calculation, and startup script generation -- all as a testable Python module following the Phase 49 TDD pattern.

Purpose: This is the core logic that maps user config (CPU/RAM) to the right GCP machine type, validates availability across zones, calculates Docker memory limits, and generates the startup script. All of this logic has defined inputs/outputs and must be correct -- TDD ensures it.

Output: `gcp/select_machine.py` with full test coverage in `tests/test_gcp_machine.py`
</objective>

<execution_context>
@/Users/steinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/steinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/50-machine-selection-and-resource-calculation/50-RESEARCH.md
@gcp/validate_config.py
@gcp/query_pricing.py
@gcp/startup.sh
@tests/test_gcp_config.py
@tests/test_gcp_pricing.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write failing tests for machine selection module</name>
  <files>tests/test_gcp_machine.py</files>
  <action>
Create test file `tests/test_gcp_machine.py` with tests for the machine selection module. Import from `gcp.select_machine`.

All gcloud interactions are isolated behind a `_run_gcloud(args) -> str` helper. Tests mock this single function using `unittest.mock.patch`.

Test cases to write (all should FAIL since implementation doesn't exist yet):

**select_machine_type tests:**
1. **test_select_machine_type_returns_name** - Mock `_run_gcloud` to return JSON `[{"name":"n2-standard-8","guestCpus":8,"memoryMb":32768}]`. Call `select_machine_type(8, 32, "us-central1-a")`. Assert returns `"n2-standard-8"`.
2. **test_select_machine_type_empty_result** - Mock `_run_gcloud` to return `[]`. Assert raises `ValueError("No machine types found")`.
3. **test_select_machine_type_gcloud_failure** - Mock `_run_gcloud` to raise `RuntimeError`. Assert raises `RuntimeError`.

**validate_machine_in_zone tests:**
4. **test_validate_machine_exists** - Mock `_run_gcloud` to return `"n2-standard-8"`. Assert `validate_machine_in_zone("n2-standard-8", "us-central1-a")` returns `True`.
5. **test_validate_machine_missing** - Mock `_run_gcloud` to return `""`. Assert returns `False`.

**find_available_zone tests (integration with get_ranked_regions):**
6. **test_find_available_zone_first_succeeds** - Mock `_run_gcloud` to return valid machine JSON on first call. Call `find_available_zone(8, 32)` (no ranked_regions param -- function calls `get_ranked_regions()` internally). Also mock `gcp.select_machine.get_ranked_regions` to return `[{"zone":"us-central1-a","region":"us-central1"}, {"zone":"us-east4-a","region":"us-east4"}]`. Assert result contains `zone`, `region`, `machine_type` keys.
7. **test_find_available_zone_fallback_to_second** - Mock `_run_gcloud` to raise `ValueError` on first call, return valid JSON on second. Mock `get_ranked_regions` to return two regions. Assert returns second zone info.
8. **test_find_available_zone_all_exhausted** - Mock `_run_gcloud` to always raise `ValueError`. Mock `get_ranked_regions` to return one region. Assert raises `RuntimeError("All regions exhausted")`.
9. **test_find_available_zone_calls_get_ranked_regions** - Mock both `_run_gcloud` and `get_ranked_regions`. Call `find_available_zone(8, 32)`. Assert `get_ranked_regions` was called with `cpu_cores=8, ram_gb=32`.

**calculate_docker_resources tests:**
10. **test_calculate_resources_standard** - Mock `_run_gcloud` to return JSON `{"guestCpus":8,"memoryMb":32768}`. Assert `calculate_docker_resources("n2-standard-8", "us-central1-a")` returns `{"worker_memory_limit":"24g", "nwchem_nproc":8, "total_ram_gb":32, "total_cpus":8}`.
11. **test_calculate_resources_highmem** - Mock with `memoryMb=32768, guestCpus=4`. Assert `nwchem_nproc=4`, `worker_memory_limit="24g"`.
12. **test_calculate_resources_insufficient_ram** - Mock with `memoryMb=8192` (8GB total, only 0GB after overhead). Assert raises `ValueError("Insufficient RAM")`.

**generate_startup_script tests:**
13. **test_startup_script_contains_memory_limit** - Assert output contains `WORKER_MEMORY_LIMIT=24g`.
14. **test_startup_script_uses_nproc** - Assert output contains `$(nproc)` (runtime CPU detection, not hardcoded).
15. **test_startup_script_contains_docker_compose** - Assert output contains `docker compose`.
16. **test_startup_script_has_strict_mode** - Assert output contains `set -euo pipefail`.
17. **test_startup_script_uses_oversubscribe** - Assert output contains `--oversubscribe` (MPI fix from v2.6).

**CLI tests:**
18. **test_cli_help** - Run `main()` with `--help` via argparse (capture SystemExit).
19. **test_cli_json_output** - Mock `_run_gcloud` and `get_ranked_regions`, capture stdout, assert valid JSON output.

Use `unittest.mock.patch` for mocking `gcp.select_machine._run_gcloud` and `gcp.select_machine.get_ranked_regions`. Use `tmp_path` fixture where needed.

Run tests: `cd /Users/steinbeck/Dropbox/develop/qm-nmr-calc && python -m pytest tests/test_gcp_machine.py -v`
Tests MUST fail (ImportError since gcp/select_machine.py doesn't exist yet).
  </action>
  <verify>
Run `python -m pytest tests/test_gcp_machine.py -v 2>&1 | head -50` and confirm all tests fail with ImportError (RED phase).
  </verify>
  <done>19 test cases exist in tests/test_gcp_machine.py, all failing because implementation doesn't exist yet.</done>
</task>

<task type="auto">
  <name>Task 2: Implement machine selection module and make tests pass</name>
  <files>gcp/select_machine.py</files>
  <action>
Create `gcp/select_machine.py` as a Python module that is BOTH importable and runnable as a CLI script.

**Critical import -- wiring to query_pricing.py (PRC-02):**
```python
from gcp.query_pricing import get_ranked_regions
```
This import is used by `find_available_zone()` to obtain the sorted region list. The function calls `get_ranked_regions(cpu_cores, ram_gb)` internally rather than receiving ranked_regions as a parameter. This ensures the caller doesn't need to know about the pricing module.

**Functions to implement:**

1. `_run_gcloud(args: list[str]) -> str`:
   - Runs `gcloud` with given args via `subprocess.run(capture_output=True, text=True, check=False)`
   - Returns stdout stripped
   - Raises `RuntimeError` on non-zero exit code (include stderr in message)
   - This is the single mock target for ALL tests

2. `select_machine_type(cpu_cores: int, ram_gb: int, zone: str) -> str`:
   - Convert `ram_gb` to `ram_mb = ram_gb * 1024`
   - Call `_run_gcloud` with: `compute machine-types list --zones=ZONE --filter="guestCpus>=CPU AND memoryMb>=RAM_MB" --format=json --sort-by=memoryMb --limit=1 --quiet`
   - Parse JSON output with `json.loads()`
   - Return first match `name` field
   - Raise `ValueError("No machine types found matching ...")` if empty result

3. `validate_machine_in_zone(machine_type: str, zone: str) -> bool`:
   - Call `_run_gcloud` with: `compute machine-types list --zones=ZONE --filter="name=MACHINE_TYPE" --format="value(name)" --quiet`
   - Return `True` if output stripped matches machine_type, `False` otherwise

4. `find_available_zone(cpu_cores: int, ram_gb: int) -> dict`:
   - **Calls `get_ranked_regions(cpu_cores, ram_gb)` internally** to obtain the sorted region list from query_pricing.py (cache/API/fallback)
   - Loops through each region entry from the ranked list
   - For each, tries `select_machine_type(cpu_cores, ram_gb, region["zone"])`
   - On `ValueError` (no match) or `RuntimeError` (gcloud fail), logs warning to stderr and continues to next region
   - On success, returns `{"zone": zone, "region": region, "machine_type": name}`
   - If ALL regions exhausted, raises `RuntimeError("All regions exhausted: no zone has a machine type matching ...")`

5. `calculate_docker_resources(machine_type: str, zone: str) -> dict`:
   - Call `_run_gcloud` with: `compute machine-types describe MACHINE_TYPE --zone=ZONE --format=json --quiet`
   - Parse JSON to get `guestCpus` and `memoryMb`
   - `total_ram_gb = memoryMb // 1024`
   - `worker_memory_gb = total_ram_gb - 8` (8GB OS overhead)
   - Validate `worker_memory_gb >= 4`, raise `ValueError("Insufficient RAM after OS overhead")` if not
   - Return `{"worker_memory_limit": f"{worker_memory_gb}g", "nwchem_nproc": guestCpus, "total_ram_gb": total_ram_gb, "total_cpus": guestCpus}`

6. `generate_startup_script(worker_memory_limit: str, resource_prefix: str, disk_size_gb: int) -> str`:
   - Return multiline string with complete startup script
   - Script uses `nproc` at runtime for CPU detection (not hardcoded)
   - Script writes `.env` with `WORKER_MEMORY_LIMIT` and `NWCHEM_NPROC=$(nproc)`
   - Includes `set -euo pipefail`
   - Installs Docker if not present
   - Pulls images from GHCR
   - Downloads docker-compose.yml from GitHub
   - Creates HTTP-only docker-compose.gcp.yml override (port 80, no Caddy/HTTPS)
   - Starts services with `docker compose`
   - Uses `--oversubscribe` for MPI compatibility (v2.6 fix)

7. `main()` CLI: argparse with `--cpu-cores`, `--ram-gb`, `--zone`, `--generate-startup-script`, `--resource-prefix`, `--disk-size-gb`
   - Default mode: call `find_available_zone()` then `calculate_docker_resources()`, output JSON
   - With `--generate-startup-script`: output startup script to stdout

Run `python -m pytest tests/test_gcp_machine.py -v` and iterate until all tests pass (GREEN phase).
Also run existing tests: `python -m pytest tests/test_gcp_config.py tests/test_gcp_pricing.py tests/test_gcp_machine.py -v`
  </action>
  <verify>
1. `python -m pytest tests/test_gcp_machine.py -v` -- all 19 tests pass
2. `python -m pytest tests/test_gcp_config.py tests/test_gcp_pricing.py tests/test_gcp_machine.py -v` -- all GCP tests pass, no regressions
3. `python -c "from gcp.select_machine import select_machine_type, validate_machine_in_zone, find_available_zone, calculate_docker_resources, generate_startup_script; print('All imports OK')"` -- imports work
4. `python3 gcp/select_machine.py --help` -- CLI shows usage
  </verify>
  <done>
Machine selection module implements all 5 functions + CLI. find_available_zone() calls get_ranked_regions(cpu_cores, ram_gb) internally from query_pricing.py to obtain sorted regions. All 19 tests pass. No regressions in existing tests.
  </done>
</task>

</tasks>

<verification>
```bash
# Run all Phase 50 tests
cd /Users/steinbeck/Dropbox/develop/qm-nmr-calc && python -m pytest tests/test_gcp_machine.py -v

# Run all GCP tests together to ensure no regressions
python -m pytest tests/test_gcp_config.py tests/test_gcp_pricing.py tests/test_gcp_machine.py -v

# Verify module is importable
python -c "from gcp.select_machine import select_machine_type, validate_machine_in_zone, find_available_zone, calculate_docker_resources, generate_startup_script; print('All imports OK')"

# Verify the critical get_ranked_regions import exists
python -c "import ast; tree = ast.parse(open('gcp/select_machine.py').read()); imports = [n for n in ast.walk(tree) if isinstance(n, ast.ImportFrom) and n.module == 'gcp.query_pricing']; assert imports, 'Missing import from gcp.query_pricing'; print('get_ranked_regions import verified')"

# Verify CLI runs (will fail without gcloud but should show usage)
python3 gcp/select_machine.py --help
```
</verification>

<success_criteria>
- All tests in test_gcp_machine.py pass
- All existing tests (test_gcp_config.py, test_gcp_pricing.py) still pass
- select_machine_type correctly maps CPU/RAM to machine type name from gcloud JSON
- validate_machine_in_zone returns bool based on gcloud output
- find_available_zone calls get_ranked_regions(cpu_cores, ram_gb) internally and iterates regions with fallback
- calculate_docker_resources subtracts 8GB OS overhead and returns "Xg" format
- generate_startup_script produces valid bash with nproc detection, .env creation, Docker setup, HTTP-only
- Module importable and runnable as CLI
- Requirements covered: MCH-01, MCH-02, MCH-03, MCH-04, PRC-02
</success_criteria>

<output>
After completion, create `.planning/phases/50-machine-selection-and-resource-calculation/50-01-SUMMARY.md`
</output>
