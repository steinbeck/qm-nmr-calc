{% extends "base.html" %}

{% block title %}Job Status | QM NMR Calculator{% endblock %}

{% block head %}
<script src="https://cdnjs.cloudflare.com/ajax/libs/3Dmol/2.5.3/3Dmol-min.js"></script>
{% endblock %}

{% block content %}
<article>
    <header>
        <h2>Job Status: {{ job.job_id }}</h2>
    </header>

    <div id="status-display">
        <dl class="metadata-grid">
            <dt>Status</dt>
            <dd><span id="job-status" data-status="{{ job.status }}">{{ job.status }}</span></dd>

            <dt>Total Elapsed</dt>
            <dd><span id="elapsed-time">--</span></dd>

            {% if job.input_name %}
            <dt>Molecule</dt>
            <dd>{{ job.input_name }}</dd>
            {% endif %}

            <dt>SMILES</dt>
            <dd><code>{{ job.input_smiles }}</code></dd>

            <dt>Solvent</dt>
            <dd>{{ job.solvent }}</dd>

            <dt>Preset</dt>
            <dd>{{ job.preset }}</dd>
        </dl>
    </div>

    <!-- 3D Molecule Viewer -->
    <div id="viewer-section" style="margin-top: 1.5rem;">
        <h4>Molecular Structure</h4>
        <div id="viewer-container-3d"></div>
        <small class="muted">RDKit-generated geometry. Final optimized structure available when complete.</small>
    </div>

    <!-- Step Progress Section -->
    <div id="progress-section" style="display: none; margin-top: 1.5rem;">
        <h4>Progress</h4>

        <!-- Current Step -->
        <div id="current-step-display" style="display: none; margin-bottom: 1rem;">
            <div class="step-indicator">
                <span class="status-indicator status-running"></span>
                <strong id="current-step-label">--</strong>
                <span class="muted"> - <span id="step-elapsed">--</span></span>
            </div>
        </div>

        <!-- Completed Steps -->
        <div id="completed-steps" style="display: none;">
            <table role="grid" class="steps-table">
                <thead>
                    <tr>
                        <th>Step</th>
                        <th>Duration</th>
                    </tr>
                </thead>
                <tbody id="steps-tbody">
                </tbody>
            </table>
        </div>
    </div>

    <div id="error-display" style="display: none;" role="alert">
        <p id="error-message"></p>
    </div>

    <footer>
        <small id="polling-status">Page refreshes automatically while job is running</small>
        <br>
        <a href="/">Submit another job</a>
    </footer>
</article>
{% endblock %}

{% block scripts %}
<script>
(function() {
    const JOB_ID = "{{ job.job_id }}";
    const CREATED_AT = new Date("{{ job.created_at }}");
    const POLL_INTERVAL = 3000; // 3 seconds

    const statusSpan = document.getElementById('job-status');
    const elapsedSpan = document.getElementById('elapsed-time');
    const errorDisplay = document.getElementById('error-display');
    const errorMessage = document.getElementById('error-message');
    const pollingStatus = document.getElementById('polling-status');

    // Step progress elements
    const progressSection = document.getElementById('progress-section');
    const currentStepDisplay = document.getElementById('current-step-display');
    const currentStepLabel = document.getElementById('current-step-label');
    const stepElapsed = document.getElementById('step-elapsed');
    const completedStepsDiv = document.getElementById('completed-steps');
    const stepsTbody = document.getElementById('steps-tbody');

    let currentStepStartedAt = null;

    // 3D Viewer
    let viewer = null;

    function initViewer() {
        const container = document.getElementById('viewer-container-3d');
        if (!container) return;

        viewer = $3Dmol.createViewer(container, {
            backgroundColor: 'white'
        });
        loadGeometry(false);  // No labels for running job
    }

    async function loadGeometry(showLabels) {
        if (!viewer) return;

        try {
            const response = await fetch('/api/v1/jobs/' + JOB_ID + '/geometry.json');
            if (!response.ok) return;

            const data = await response.json();

            viewer.removeAllModels();
            viewer.removeAllLabels();

            const model = viewer.addModel(data.xyz, 'xyz', {assignBonds: true});

            viewer.setStyle({}, {
                stick: {radius: 0.12, colorscheme: 'Jmol'},
                sphere: {scale: 0.25, colorscheme: 'Jmol'}
            });

            viewer.zoomTo();
            viewer.render();
        } catch (error) {
            console.error('Error loading geometry:', error);
        }
    }

    function formatElapsed(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        if (mins > 0) {
            return mins + 'm ' + secs + 's';
        }
        return secs + 's';
    }

    function formatDuration(seconds) {
        if (seconds < 60) {
            return seconds.toFixed(1) + 's';
        }
        const mins = Math.floor(seconds / 60);
        const secs = (seconds % 60).toFixed(0);
        return mins + 'm ' + secs + 's';
    }

    function updateElapsedTime() {
        const now = new Date();
        const elapsed = Math.floor((now - CREATED_AT) / 1000);
        elapsedSpan.textContent = formatElapsed(elapsed);

        // Update current step elapsed time
        if (currentStepStartedAt) {
            const stepSecs = (now - currentStepStartedAt) / 1000;
            stepElapsed.textContent = formatElapsed(stepSecs);
        }
    }

    function updateStepProgress(data) {
        // Show progress section if there's any step info
        if (data.current_step || data.steps_completed.length > 0) {
            progressSection.style.display = 'block';
        }

        // Update current step
        if (data.current_step_label) {
            currentStepDisplay.style.display = 'block';
            currentStepLabel.textContent = data.current_step_label;
            currentStepStartedAt = data.step_started_at ? new Date(data.step_started_at) : null;
        } else {
            currentStepDisplay.style.display = 'none';
            currentStepStartedAt = null;
        }

        // Update completed steps table
        if (data.steps_completed && data.steps_completed.length > 0) {
            completedStepsDiv.style.display = 'block';
            stepsTbody.innerHTML = data.steps_completed.map(step =>
                `<tr>
                    <td><span class="status-indicator status-complete"></span>${step.label}</td>
                    <td>${formatDuration(step.duration_seconds)}</td>
                </tr>`
            ).join('');
        }
    }

    async function checkStatus() {
        try {
            const response = await fetch('/api/v1/jobs/' + JOB_ID);
            const data = await response.json();

            // Update status display
            statusSpan.textContent = data.status;
            statusSpan.setAttribute('data-status', data.status);
            updateElapsedTime();

            // Update step progress
            updateStepProgress(data);

            if (data.status === 'complete') {
                // Redirect to results page
                pollingStatus.textContent = 'Job complete! Redirecting to results...';
                window.location.href = '/results/' + JOB_ID;
            } else if (data.status === 'failed') {
                // Show error message
                errorDisplay.style.display = 'block';
                errorMessage.textContent = data.error_message || 'An unknown error occurred';
                pollingStatus.textContent = 'Job failed. No automatic refresh.';
            } else {
                // Continue polling
                setTimeout(checkStatus, POLL_INTERVAL);
            }
        } catch (error) {
            console.error('Error checking job status:', error);
            // Retry with longer interval on error
            setTimeout(checkStatus, POLL_INTERVAL * 2);
        }
    }

    // Start polling and elapsed time updates when DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
        initViewer();
        checkStatus();
        setInterval(updateElapsedTime, 1000);
    });
})();
</script>
{% endblock %}
